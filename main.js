"use strict";
var parquetjs = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      init_esbuild_shims();
      exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
        var e2, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer2[offset + i];
        i += d;
        e2 = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        m = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
        var e2, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e2)) < 1) {
            e2--;
            c *= 2;
          }
          if (e2 + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e2++;
            c /= 2;
          }
          if (e2 + eBias >= eMax) {
            m = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
        }
        buffer2[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer6;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer6.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer6.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer6.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer6.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer6.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer6.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer6.prototype);
        return buf;
      }
      function Buffer6(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer6.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString2(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance2(value, ArrayBuffer) || value && isInstance2(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance2(value, SharedArrayBuffer) || value && isInstance2(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer6.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer6.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer6.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer6.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer6, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer6.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer6.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer6.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString2(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer6.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance2(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer6.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer6.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer6.alloc(+length);
      }
      Buffer6.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer6.prototype;
      };
      Buffer6.compare = function compare2(a, b) {
        if (isInstance2(a, Uint8Array)) a = Buffer6.from(a, a.offset, a.byteLength);
        if (isInstance2(b, Uint8Array)) b = Buffer6.from(b, b.offset, b.byteLength);
        if (!Buffer6.isBuffer(a) || !Buffer6.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer6.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer6.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer6.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer2 = Buffer6.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance2(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer6.isBuffer(buf)) buf = Buffer6.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer6.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength(string, encoding) {
        if (Buffer6.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance2(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer6.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer6.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer6.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer6.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer6.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer6.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer6.prototype.toLocaleString = Buffer6.prototype.toString;
      Buffer6.prototype.equals = function equals2(b) {
        if (!Buffer6.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer6.compare(this, b) === 0;
      };
      Buffer6.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer6.prototype[customInspectSymbol] = Buffer6.prototype.inspect;
      }
      Buffer6.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (isInstance2(target, Uint8Array)) {
          target = Buffer6.from(target, target.offset, target.byteLength);
        }
        if (!Buffer6.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val2, byteOffset, encoding, dir) {
        if (buffer2.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir) return -1;
          else byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val2 === "string") {
          val2 = Buffer6.from(val2, encoding);
        }
        if (Buffer6.isBuffer(val2)) {
          if (val2.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val2, byteOffset, encoding, dir);
        } else if (typeof val2 === "number") {
          val2 = val2 & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val2, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val2, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val2], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val2.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val2.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val2, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer6.prototype.includes = function includes(val2, byteOffset, encoding) {
        return this.indexOf(val2, byteOffset, encoding) !== -1;
      };
      Buffer6.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
      };
      Buffer6.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer6.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer6.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer6.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer6.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer6.prototype.readUintLE = Buffer6.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val2 = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val2 += this[offset + i] * mul;
        }
        return val2;
      };
      Buffer6.prototype.readUintBE = Buffer6.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val2 = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val2 += this[offset + --byteLength2] * mul;
        }
        return val2;
      };
      Buffer6.prototype.readUint8 = Buffer6.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer6.prototype.readUint16LE = Buffer6.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer6.prototype.readUint16BE = Buffer6.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer6.prototype.readUint32LE = Buffer6.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer6.prototype.readUint32BE = Buffer6.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer6.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer6.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer6.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val2 = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val2 += this[offset + i] * mul;
        }
        mul *= 128;
        if (val2 >= mul) val2 -= Math.pow(2, 8 * byteLength2);
        return val2;
      };
      Buffer6.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val2 = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val2 += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val2 >= mul) val2 -= Math.pow(2, 8 * byteLength2);
        return val2;
      };
      Buffer6.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer6.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val2 = this[offset] | this[offset + 1] << 8;
        return val2 & 32768 ? val2 | 4294901760 : val2;
      };
      Buffer6.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val2 = this[offset + 1] | this[offset] << 8;
        return val2 & 32768 ? val2 | 4294901760 : val2;
      };
      Buffer6.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer6.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer6.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val2 = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val2) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer6.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val2 = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val2) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer6.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer6.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer6.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer6.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer6.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer6.prototype.writeUintLE = Buffer6.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer6.prototype.writeUintBE = Buffer6.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer6.prototype.writeUint8 = Buffer6.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer6.prototype.writeUint16LE = Buffer6.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer6.prototype.writeUint16BE = Buffer6.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer6.prototype.writeUint32LE = Buffer6.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer6.prototype.writeUint32BE = Buffer6.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer6.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer6.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer6.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer6.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer6.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer6.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer6.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer6.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer6.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer6.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer6.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer6.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer6.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer6.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer6.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer6.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer6.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer6.prototype.fill = function fill(val2, start, end, encoding) {
        if (typeof val2 === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer6.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val2.length === 1) {
            const code = val2.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val2 = code;
            }
          }
        } else if (typeof val2 === "number") {
          val2 = val2 & 255;
        } else if (typeof val2 === "boolean") {
          val2 = Number(val2);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val2) val2 = 0;
        let i;
        if (typeof val2 === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val2;
          }
        } else {
          const bytes = Buffer6.isBuffer(val2) ? val2 : Buffer6.from(val2, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val2) {
        let res = "";
        let i = val2.length;
        const start = val2[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val2.slice(i - 3, i)}${res}`;
        }
        return `${val2.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance2(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // esbuild-shims.js
  var buffer, Buffer2;
  var init_esbuild_shims = __esm({
    "esbuild-shims.js"() {
      "use strict";
      buffer = require_buffer().Buffer;
      Buffer2 = buffer;
    }
  });

  // node_modules/node-int64/Int64.js
  var require_Int64 = __commonJS({
    "node_modules/node-int64/Int64.js"(exports, module) {
      init_esbuild_shims();
      var VAL32 = 4294967296;
      var _HEX = [];
      for (i = 0; i < 256; i++) {
        _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
      }
      var i;
      var Int644 = module.exports = function(a1, a2) {
        if (a1 instanceof Buffer2) {
          this.buffer = a1;
          this.offset = a2 || 0;
        } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
          this.buffer = new Buffer2(a1);
          this.offset = a2 || 0;
        } else {
          this.buffer = this.buffer || new Buffer2(8);
          this.offset = 0;
          this.setValue.apply(this, arguments);
        }
      };
      Int644.MAX_INT = Math.pow(2, 53);
      Int644.MIN_INT = -Math.pow(2, 53);
      Int644.prototype = {
        constructor: Int644,
        /**
         * Do in-place 2's compliment.  See
         * http://en.wikipedia.org/wiki/Two's_complement
         */
        _2scomp: function() {
          var b = this.buffer, o = this.offset, carry = 1;
          for (var i2 = o + 7; i2 >= o; i2--) {
            var v = (b[i2] ^ 255) + carry;
            b[i2] = v & 255;
            carry = v >> 8;
          }
        },
        /**
         * Set the value. Takes any of the following arguments:
         *
         * setValue(string) - A hexidecimal string
         * setValue(number) - Number (throws if n is outside int64 range)
         * setValue(hi, lo) - Raw bits as two 32-bit values
         */
        setValue: function(hi, lo) {
          var negate2 = false;
          if (arguments.length == 1) {
            if (typeof hi == "number") {
              negate2 = hi < 0;
              hi = Math.abs(hi);
              lo = hi % VAL32;
              hi = hi / VAL32;
              if (hi > VAL32) throw new RangeError(hi + " is outside Int64 range");
              hi = hi | 0;
            } else if (typeof hi == "string") {
              hi = (hi + "").replace(/^0x/, "");
              lo = hi.substr(-8);
              hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
              hi = parseInt(hi, 16);
              lo = parseInt(lo, 16);
            } else {
              throw new Error(hi + " must be a Number or String");
            }
          }
          var b = this.buffer, o = this.offset;
          for (var i2 = 7; i2 >= 0; i2--) {
            b[o + i2] = lo & 255;
            lo = i2 == 4 ? hi : lo >>> 8;
          }
          if (negate2) this._2scomp();
        },
        /**
         * Convert to a native JS number.
         *
         * WARNING: Do not expect this value to be accurate to integer precision for
         * large (positive or negative) numbers!
         *
         * @param allowImprecise If true, no check is performed to verify the
         * returned value is accurate to integer precision.  If false, imprecise
         * numbers (very large positive or negative numbers) will be forced to +/-
         * Infinity.
         */
        toNumber: function(allowImprecise) {
          var b = this.buffer, o = this.offset;
          var negate2 = b[o] & 128, x = 0, carry = 1;
          for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
            var v = b[o + i2];
            if (negate2) {
              v = (v ^ 255) + carry;
              carry = v >> 8;
              v = v & 255;
            }
            x += v * m;
          }
          if (!allowImprecise && x >= Int644.MAX_INT) {
            return negate2 ? -Infinity : Infinity;
          }
          return negate2 ? -x : x;
        },
        /**
         * Convert to a JS Number. Returns +/-Infinity for values that can't be
         * represented to integer precision.
         */
        valueOf: function() {
          return this.toNumber(false);
        },
        /**
         * Return string value
         *
         * @param radix Just like Number#toString()'s radix
         */
        toString: function(radix) {
          return this.valueOf().toString(radix || 10);
        },
        /**
         * Return a string showing the buffer octets, with MSB on the left.
         *
         * @param sep separator string. default is '' (empty string)
         */
        toOctetString: function(sep) {
          var out = new Array(8);
          var b = this.buffer, o = this.offset;
          for (var i2 = 0; i2 < 8; i2++) {
            out[i2] = _HEX[b[o + i2]];
          }
          return out.join(sep || "");
        },
        /**
         * Returns the int64's 8 bytes in a buffer.
         *
         * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
         *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
         */
        toBuffer: function(rawBuffer) {
          if (rawBuffer && this.offset === 0) return this.buffer;
          var out = new Buffer2(8);
          this.buffer.copy(out, 0, this.offset, this.offset + 8);
          return out;
        },
        /**
         * Copy 8 bytes of int64 into target buffer at target offset.
         *
         * @param {Buffer} targetBuffer       Buffer to copy into.
         * @param {number} [targetOffset=0]   Offset into target buffer.
         */
        copy: function(targetBuffer, targetOffset) {
          this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
        },
        /**
         * Returns a number indicating whether this comes before or after or is the
         * same as the other in sort order.
         *
         * @param {Int64} other  Other Int64 to compare.
         */
        compare: function(other) {
          if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
            return other.buffer[other.offset] - this.buffer[this.offset];
          }
          for (var i2 = 0; i2 < 8; i2++) {
            if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
              return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
            }
          }
          return 0;
        },
        /**
         * Returns a boolean indicating if this integer is equal to other.
         *
         * @param {Int64} other  Other Int64 to compare.
         */
        equals: function(other) {
          return this.compare(other) === 0;
        },
        /**
         * Pretty output in console.log
         */
        inspect: function() {
          return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
        }
      };
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/es-errors/index.js
  var require_es_errors = __commonJS({
    "node_modules/es-errors/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = Error;
    }
  });

  // node_modules/es-errors/eval.js
  var require_eval = __commonJS({
    "node_modules/es-errors/eval.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = EvalError;
    }
  });

  // node_modules/es-errors/range.js
  var require_range = __commonJS({
    "node_modules/es-errors/range.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = RangeError;
    }
  });

  // node_modules/es-errors/ref.js
  var require_ref = __commonJS({
    "node_modules/es-errors/ref.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = ReferenceError;
    }
  });

  // node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = SyntaxError;
    }
  });

  // node_modules/es-errors/type.js
  var require_type = __commonJS({
    "node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = TypeError;
    }
  });

  // node_modules/es-errors/uri.js
  var require_uri = __commonJS({
    "node_modules/es-errors/uri.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = URIError;
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "node_modules/has-proto/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var test = {
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/hasown/index.js
  var require_hasown = __commonJS({
    "node_modules/hasown/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = require_function_bind();
      module.exports = bind.call(call, $hasOwn);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var undefined2;
      var $Error = require_es_errors();
      var $EvalError = require_eval();
      var $RangeError = require_range();
      var $ReferenceError = require_ref();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var $URIError = require_uri();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e2) {
          errorProto = getProto(getProto(e2));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_hasown();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e2) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/set-function-length/index.js
  var require_set_function_length = __commonJS({
    "node_modules/set-function-length/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var GetIntrinsic = require_get_intrinsic();
      var define2 = require_define_data_property();
      var hasDescriptors = require_has_property_descriptors()();
      var gOPD = require_gopd();
      var $TypeError = require_type();
      var $floor = GetIntrinsic("%Math.floor%");
      module.exports = function setFunctionLength(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD) {
          var desc = gOPD(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length,
              true,
              true
            );
          } else {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length
            );
          }
        }
        return fn;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var setFunctionLength = require_set_function_length();
      var $TypeError = require_type();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $defineProperty = require_es_define_property();
      var $max = GetIntrinsic("%Math.max%");
      module.exports = function callBind(originalFunction) {
        if (typeof originalFunction !== "function") {
          throw new $TypeError("a function is required");
        }
        var func = $reflectApply(bind, $call, arguments);
        return setFunctionLength(
          func,
          1 + $max(0, originalFunction.length - (arguments.length - 1)),
          true
        );
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e2) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e2) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e2) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e2) {
          if (e2 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? window : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e2) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g[typedArray] === "function") {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e2) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e2) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer2(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer2;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      init_esbuild_shims();
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      init_esbuild_shims();
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      init_esbuild_shims();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%") return "%";
          if (i >= len) return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (false) {
        debugEnv = false;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val2, idx) {
          hash[val2] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e2) {
        return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add2) {
        if (!add2 || !isObject(add2)) return origin;
        var keys = Object.keys(add2);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add2[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve2, reject) {
            promiseResolve = resolve2;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/thrift.js
  var require_thrift = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/thrift.js"(exports, module) {
      init_esbuild_shims();
      var util = require_util();
      var Type = exports.Type = {
        STOP: 0,
        VOID: 1,
        BOOL: 2,
        BYTE: 3,
        I08: 3,
        DOUBLE: 4,
        I16: 6,
        I32: 8,
        I64: 10,
        STRING: 11,
        UTF7: 11,
        STRUCT: 12,
        MAP: 13,
        SET: 14,
        LIST: 15,
        UTF8: 16,
        UTF16: 17
      };
      exports.MessageType = {
        CALL: 1,
        REPLY: 2,
        EXCEPTION: 3,
        ONEWAY: 4
      };
      exports.TException = TException;
      function TException(message) {
        Error.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = this.constructor.name;
        this.message = message;
      }
      util.inherits(TException, Error);
      var TApplicationExceptionType = exports.TApplicationExceptionType = {
        UNKNOWN: 0,
        UNKNOWN_METHOD: 1,
        INVALID_MESSAGE_TYPE: 2,
        WRONG_METHOD_NAME: 3,
        BAD_SEQUENCE_ID: 4,
        MISSING_RESULT: 5,
        INTERNAL_ERROR: 6,
        PROTOCOL_ERROR: 7,
        INVALID_TRANSFORM: 8,
        INVALID_PROTOCOL: 9,
        UNSUPPORTED_CLIENT_TYPE: 10
      };
      exports.TApplicationException = TApplicationException;
      function TApplicationException(type, message) {
        TException.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.type = type || TApplicationExceptionType.UNKNOWN;
        this.name = this.constructor.name;
        this.message = message;
      }
      util.inherits(TApplicationException, TException);
      TApplicationException.prototype.read = function(input) {
        var ftype;
        var ret = input.readStructBegin("TApplicationException");
        while (1) {
          ret = input.readFieldBegin();
          if (ret.ftype == Type.STOP)
            break;
          switch (ret.fid) {
            case 1:
              if (ret.ftype == Type.STRING) {
                ret = input.readString();
                this.message = ret;
              } else {
                ret = input.skip(ret.ftype);
              }
              break;
            case 2:
              if (ret.ftype == Type.I32) {
                ret = input.readI32();
                this.type = ret;
              } else {
                ret = input.skip(ret.ftype);
              }
              break;
            default:
              ret = input.skip(ret.ftype);
              break;
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
      };
      TApplicationException.prototype.write = function(output) {
        output.writeStructBegin("TApplicationException");
        if (this.message) {
          output.writeFieldBegin("message", Type.STRING, 1);
          output.writeString(this.message);
          output.writeFieldEnd();
        }
        if (this.code) {
          output.writeFieldBegin("type", Type.I32, 2);
          output.writeI32(this.code);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
      };
      var TProtocolExceptionType = exports.TProtocolExceptionType = {
        UNKNOWN: 0,
        INVALID_DATA: 1,
        NEGATIVE_SIZE: 2,
        SIZE_LIMIT: 3,
        BAD_VERSION: 4,
        NOT_IMPLEMENTED: 5,
        DEPTH_LIMIT: 6
      };
      exports.TProtocolException = TProtocolException;
      function TProtocolException(type, message) {
        Error.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = this.constructor.name;
        this.type = type;
        this.message = message;
      }
      util.inherits(TProtocolException, Error);
      exports.objectLength = function(obj) {
        return Object.keys(obj).length;
      };
      exports.inherits = function(constructor, superConstructor) {
        util.inherits(constructor, superConstructor);
      };
      var copyList;
      var copyMap;
      copyList = function(lst, types3) {
        if (!lst) {
          return lst;
        }
        var type;
        if (types3.shift === void 0) {
          type = types3;
        } else {
          type = types3[0];
        }
        var Type2 = type;
        var len = lst.length, result = [], i, val2;
        for (i = 0; i < len; i++) {
          val2 = lst[i];
          if (type === null) {
            result.push(val2);
          } else if (type === copyMap || type === copyList) {
            result.push(type(val2, types3.slice(1)));
          } else {
            result.push(new Type2(val2));
          }
        }
        return result;
      };
      copyMap = function(obj, types3) {
        if (!obj) {
          return obj;
        }
        var type;
        if (types3.shift === void 0) {
          type = types3;
        } else {
          type = types3[0];
        }
        var Type2 = type;
        var result = {}, val2;
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            val2 = obj[prop];
            if (type === null) {
              result[prop] = val2;
            } else if (type === copyMap || type === copyList) {
              result[prop] = type(val2, types3.slice(1));
            } else {
              result[prop] = new Type2(val2);
            }
          }
        }
        return result;
      };
      module.exports.copyMap = copyMap;
      module.exports.copyList = copyList;
    }
  });

  // node_modules/isomorphic-ws/browser.js
  var require_browser = __commonJS({
    "node_modules/isomorphic-ws/browser.js"(exports, module) {
      init_esbuild_shims();
      var ws = null;
      if (typeof WebSocket !== "undefined") {
        ws = WebSocket;
      } else if (typeof MozWebSocket !== "undefined") {
        ws = MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      } else if (typeof self !== "undefined") {
        ws = self.WebSocket || self.MozWebSocket;
      }
      module.exports = ws;
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve2, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve2([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/binary.js
  var require_binary = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/binary.js"(exports) {
      init_esbuild_shims();
      var POW_8 = Math.pow(2, 8);
      var POW_16 = Math.pow(2, 16);
      var POW_24 = Math.pow(2, 24);
      var POW_32 = Math.pow(2, 32);
      var POW_40 = Math.pow(2, 40);
      var POW_48 = Math.pow(2, 48);
      var POW_52 = Math.pow(2, 52);
      var POW_1022 = Math.pow(2, 1022);
      exports.readByte = function(b) {
        return b > 127 ? b - 256 : b;
      };
      exports.readI16 = function(buff, off) {
        off = off || 0;
        var v = buff[off + 1];
        v += buff[off] << 8;
        if (buff[off] & 128) {
          v -= POW_16;
        }
        return v;
      };
      exports.readI32 = function(buff, off) {
        off = off || 0;
        var v = buff[off + 3];
        v += buff[off + 2] << 8;
        v += buff[off + 1] << 16;
        v += buff[off] * POW_24;
        if (buff[off] & 128) {
          v -= POW_32;
        }
        return v;
      };
      exports.writeI16 = function(buff, v) {
        buff[1] = v & 255;
        v >>= 8;
        buff[0] = v & 255;
        return buff;
      };
      exports.writeI32 = function(buff, v) {
        buff[3] = v & 255;
        v >>= 8;
        buff[2] = v & 255;
        v >>= 8;
        buff[1] = v & 255;
        v >>= 8;
        buff[0] = v & 255;
        return buff;
      };
      exports.readDouble = function(buff, off) {
        off = off || 0;
        var signed = buff[off] & 128;
        var e2 = (buff[off + 1] & 240) >> 4;
        e2 += (buff[off] & 127) << 4;
        var m = buff[off + 7];
        m += buff[off + 6] << 8;
        m += buff[off + 5] << 16;
        m += buff[off + 4] * POW_24;
        m += buff[off + 3] * POW_32;
        m += buff[off + 2] * POW_40;
        m += (buff[off + 1] & 15) * POW_48;
        switch (e2) {
          case 0:
            e2 = -1022;
            break;
          case 2047:
            return m ? NaN : signed ? -Infinity : Infinity;
          default:
            m += POW_52;
            e2 -= 1023;
        }
        if (signed) {
          m *= -1;
        }
        return m * Math.pow(2, e2 - 52);
      };
      exports.writeDouble = function(buff, v) {
        var m, e2, c;
        buff[0] = v < 0 ? 128 : 0;
        v = Math.abs(v);
        if (v !== v) {
          m = 2251799813685248;
          e2 = 2047;
        } else if (v === Infinity) {
          m = 0;
          e2 = 2047;
        } else {
          e2 = Math.floor(Math.log(v) / Math.LN2);
          c = Math.pow(2, -e2);
          if (v * c < 1) {
            e2--;
            c *= 2;
          }
          if (e2 + 1023 >= 2047) {
            m = 0;
            e2 = 2047;
          } else if (e2 + 1023 >= 1) {
            m = (v * c - 1) * POW_52;
            e2 += 1023;
          } else {
            m = v * POW_1022 * POW_52;
            e2 = 0;
          }
        }
        buff[1] = e2 << 4 & 240;
        buff[0] |= e2 >> 4 & 127;
        buff[7] = m & 255;
        m = Math.floor(m / POW_8);
        buff[6] = m & 255;
        m = Math.floor(m / POW_8);
        buff[5] = m & 255;
        m = Math.floor(m / POW_8);
        buff[4] = m & 255;
        m >>= 8;
        buff[3] = m & 255;
        m >>= 8;
        buff[2] = m & 255;
        m >>= 8;
        buff[1] |= m & 15;
        return buff;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/input_buffer_underrun_error.js
  var require_input_buffer_underrun_error = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/input_buffer_underrun_error.js"(exports, module) {
      init_esbuild_shims();
      var util = require_util();
      module.exports = InputBufferUnderrunError;
      function InputBufferUnderrunError(message) {
        Error.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = this.constructor.name;
        this.message = message;
      }
      util.inherits(InputBufferUnderrunError, Error);
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/log.js
  var require_log = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/log.js"(exports) {
      init_esbuild_shims();
      var util = require_util();
      var disabled = function() {
      };
      var logFunc = console.log;
      var logLevel = "error";
      function factory(level) {
        return function() {
          var args = ["thrift: [" + level + "] "].concat(Array.from(arguments));
          return logFunc(util.format.apply(null, args));
        };
      }
      var trace = disabled;
      var debug = disabled;
      var error = disabled;
      var warning = disabled;
      var info = disabled;
      exports.setLogFunc = function(func) {
        logFunc = func;
      };
      var setLogLevel = exports.setLogLevel = function(level) {
        trace = debug = error = warning = info = disabled;
        logLevel = level;
        switch (logLevel) {
          case "trace":
            trace = factory("TRACE");
          case "debug":
            debug = factory("DEBUG");
          case "error":
            error = factory("ERROR");
          case "warning":
            warning = factory("WARN");
          case "info":
            info = factory("INFO");
        }
      };
      setLogLevel(logLevel);
      exports.getLogLevel = function() {
        return logLevel;
      };
      exports.trace = function() {
        return trace.apply(null, arguments);
      };
      exports.debug = function() {
        return debug.apply(null, arguments);
      };
      exports.error = function() {
        return error.apply(null, arguments);
      };
      exports.warning = function() {
        return warning.apply(null, arguments);
      };
      exports.info = function() {
        return info.apply(null, arguments);
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/compact_protocol.js
  var require_compact_protocol = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/compact_protocol.js"(exports, module) {
      init_esbuild_shims();
      var log = require_log();
      var Int644 = require_Int64();
      var Thrift = require_thrift();
      var Type = Thrift.Type;
      module.exports = TCompactProtocol;
      var POW_8 = Math.pow(2, 8);
      var POW_24 = Math.pow(2, 24);
      var POW_32 = Math.pow(2, 32);
      var POW_40 = Math.pow(2, 40);
      var POW_48 = Math.pow(2, 48);
      var POW_52 = Math.pow(2, 52);
      var POW_1022 = Math.pow(2, 1022);
      function TCompactProtocol(trans) {
        this.trans = trans;
        this.lastField_ = [];
        this.lastFieldId_ = 0;
        this.string_limit_ = 0;
        this.string_buf_ = null;
        this.string_buf_size_ = 0;
        this.container_limit_ = 0;
        this.booleanField_ = {
          name: null,
          hasBoolValue: false
        };
        this.boolValue_ = {
          hasBoolValue: false,
          boolValue: false
        };
      }
      TCompactProtocol.PROTOCOL_ID = -126;
      TCompactProtocol.VERSION_N = 1;
      TCompactProtocol.VERSION_MASK = 31;
      TCompactProtocol.TYPE_MASK = -32;
      TCompactProtocol.TYPE_BITS = 7;
      TCompactProtocol.TYPE_SHIFT_AMOUNT = 5;
      TCompactProtocol.Types = {
        CT_STOP: 0,
        CT_BOOLEAN_TRUE: 1,
        CT_BOOLEAN_FALSE: 2,
        CT_BYTE: 3,
        CT_I16: 4,
        CT_I32: 5,
        CT_I64: 6,
        CT_DOUBLE: 7,
        CT_BINARY: 8,
        CT_LIST: 9,
        CT_SET: 10,
        CT_MAP: 11,
        CT_STRUCT: 12
      };
      TCompactProtocol.TTypeToCType = [
        TCompactProtocol.Types.CT_STOP,
        // T_STOP
        0,
        // unused
        TCompactProtocol.Types.CT_BOOLEAN_TRUE,
        // T_BOOL
        TCompactProtocol.Types.CT_BYTE,
        // T_BYTE
        TCompactProtocol.Types.CT_DOUBLE,
        // T_DOUBLE
        0,
        // unused
        TCompactProtocol.Types.CT_I16,
        // T_I16
        0,
        // unused
        TCompactProtocol.Types.CT_I32,
        // T_I32
        0,
        // unused
        TCompactProtocol.Types.CT_I64,
        // T_I64
        TCompactProtocol.Types.CT_BINARY,
        // T_STRING
        TCompactProtocol.Types.CT_STRUCT,
        // T_STRUCT
        TCompactProtocol.Types.CT_MAP,
        // T_MAP
        TCompactProtocol.Types.CT_SET,
        // T_SET
        TCompactProtocol.Types.CT_LIST
        // T_LIST
      ];
      TCompactProtocol.prototype.getTransport = function() {
        return this.trans;
      };
      TCompactProtocol.prototype.getCompactType = function(ttype) {
        return TCompactProtocol.TTypeToCType[ttype];
      };
      TCompactProtocol.prototype.getTType = function(type) {
        switch (type) {
          case Type.STOP:
            return Type.STOP;
          case TCompactProtocol.Types.CT_BOOLEAN_FALSE:
          case TCompactProtocol.Types.CT_BOOLEAN_TRUE:
            return Type.BOOL;
          case TCompactProtocol.Types.CT_BYTE:
            return Type.BYTE;
          case TCompactProtocol.Types.CT_I16:
            return Type.I16;
          case TCompactProtocol.Types.CT_I32:
            return Type.I32;
          case TCompactProtocol.Types.CT_I64:
            return Type.I64;
          case TCompactProtocol.Types.CT_DOUBLE:
            return Type.DOUBLE;
          case TCompactProtocol.Types.CT_BINARY:
            return Type.STRING;
          case TCompactProtocol.Types.CT_LIST:
            return Type.LIST;
          case TCompactProtocol.Types.CT_SET:
            return Type.SET;
          case TCompactProtocol.Types.CT_MAP:
            return Type.MAP;
          case TCompactProtocol.Types.CT_STRUCT:
            return Type.STRUCT;
          default:
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Unknown type: " + type);
        }
        return Type.STOP;
      };
      TCompactProtocol.prototype.flush = function() {
        return this.trans.flush();
      };
      TCompactProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
        this.writeByte(TCompactProtocol.PROTOCOL_ID);
        this.writeByte(TCompactProtocol.VERSION_N & TCompactProtocol.VERSION_MASK | type << TCompactProtocol.TYPE_SHIFT_AMOUNT & TCompactProtocol.TYPE_MASK);
        this.writeVarint32(seqid);
        this.writeString(name);
        if (this._seqid) {
          log.warning("SeqId already set", { "name": name });
        } else {
          this._seqid = seqid;
          this.trans.setCurrSeqId(seqid);
        }
      };
      TCompactProtocol.prototype.writeMessageEnd = function() {
      };
      TCompactProtocol.prototype.writeStructBegin = function(name) {
        this.lastField_.push(this.lastFieldId_);
        this.lastFieldId_ = 0;
      };
      TCompactProtocol.prototype.writeStructEnd = function() {
        this.lastFieldId_ = this.lastField_.pop();
      };
      TCompactProtocol.prototype.writeFieldBegin = function(name, type, id) {
        if (type != Type.BOOL) {
          return this.writeFieldBeginInternal(name, type, id, -1);
        }
        this.booleanField_.name = name;
        this.booleanField_.fieldType = type;
        this.booleanField_.fieldId = id;
      };
      TCompactProtocol.prototype.writeFieldEnd = function() {
      };
      TCompactProtocol.prototype.writeFieldStop = function() {
        this.writeByte(TCompactProtocol.Types.CT_STOP);
      };
      TCompactProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
        if (size === 0) {
          this.writeByte(0);
        } else {
          this.writeVarint32(size);
          this.writeByte(this.getCompactType(keyType) << 4 | this.getCompactType(valType));
        }
      };
      TCompactProtocol.prototype.writeMapEnd = function() {
      };
      TCompactProtocol.prototype.writeListBegin = function(elemType, size) {
        this.writeCollectionBegin(elemType, size);
      };
      TCompactProtocol.prototype.writeListEnd = function() {
      };
      TCompactProtocol.prototype.writeSetBegin = function(elemType, size) {
        this.writeCollectionBegin(elemType, size);
      };
      TCompactProtocol.prototype.writeSetEnd = function() {
      };
      TCompactProtocol.prototype.writeBool = function(value) {
        if (this.booleanField_.name !== null) {
          this.writeFieldBeginInternal(
            this.booleanField_.name,
            this.booleanField_.fieldType,
            this.booleanField_.fieldId,
            value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE : TCompactProtocol.Types.CT_BOOLEAN_FALSE
          );
          this.booleanField_.name = null;
        } else {
          this.writeByte(value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE : TCompactProtocol.Types.CT_BOOLEAN_FALSE);
        }
      };
      TCompactProtocol.prototype.writeByte = function(b) {
        this.trans.write(new Buffer2([b]));
      };
      TCompactProtocol.prototype.writeI16 = function(i16) {
        this.writeVarint32(this.i32ToZigzag(i16));
      };
      TCompactProtocol.prototype.writeI32 = function(i32) {
        this.writeVarint32(this.i32ToZigzag(i32));
      };
      TCompactProtocol.prototype.writeI64 = function(i64) {
        this.writeVarint64(this.i64ToZigzag(i64));
      };
      TCompactProtocol.prototype.writeDouble = function(v) {
        var buff = new Buffer2(8);
        var m, e2, c;
        buff[7] = v < 0 ? 128 : 0;
        v = Math.abs(v);
        if (v !== v) {
          m = 2251799813685248;
          e2 = 2047;
        } else if (v === Infinity) {
          m = 0;
          e2 = 2047;
        } else {
          e2 = Math.floor(Math.log(v) / Math.LN2);
          c = Math.pow(2, -e2);
          if (v * c < 1) {
            e2--;
            c *= 2;
          }
          if (e2 + 1023 >= 2047) {
            m = 0;
            e2 = 2047;
          } else if (e2 + 1023 >= 1) {
            m = (v * c - 1) * POW_52;
            e2 += 1023;
          } else {
            m = v * POW_1022 * POW_52;
            e2 = 0;
          }
        }
        buff[6] = e2 << 4 & 240;
        buff[7] |= e2 >> 4 & 127;
        buff[0] = m & 255;
        m = Math.floor(m / POW_8);
        buff[1] = m & 255;
        m = Math.floor(m / POW_8);
        buff[2] = m & 255;
        m = Math.floor(m / POW_8);
        buff[3] = m & 255;
        m >>= 8;
        buff[4] = m & 255;
        m >>= 8;
        buff[5] = m & 255;
        m >>= 8;
        buff[6] |= m & 15;
        this.trans.write(buff);
      };
      TCompactProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
        if (typeof arg === "string") {
          this.writeVarint32(Buffer2.byteLength(arg, encoding));
          this.trans.write(new Buffer2(arg, encoding));
        } else if (arg instanceof Buffer2 || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
          this.writeVarint32(arg.length);
          this.trans.write(arg);
        } else {
          throw new Error(name + " called without a string/Buffer argument: " + arg);
        }
      };
      TCompactProtocol.prototype.writeString = function(arg) {
        this.writeStringOrBinary("writeString", "utf8", arg);
      };
      TCompactProtocol.prototype.writeBinary = function(arg) {
        this.writeStringOrBinary("writeBinary", "binary", arg);
      };
      TCompactProtocol.prototype.writeFieldBeginInternal = function(name, fieldType, fieldId, typeOverride) {
        var typeToWrite = typeOverride == -1 ? this.getCompactType(fieldType) : typeOverride;
        if (fieldId > this.lastFieldId_ && fieldId - this.lastFieldId_ <= 15) {
          this.writeByte(fieldId - this.lastFieldId_ << 4 | typeToWrite);
        } else {
          this.writeByte(typeToWrite);
          this.writeI16(fieldId);
        }
        this.lastFieldId_ = fieldId;
      };
      TCompactProtocol.prototype.writeCollectionBegin = function(elemType, size) {
        if (size <= 14) {
          this.writeByte(size << 4 | this.getCompactType(elemType));
        } else {
          this.writeByte(240 | this.getCompactType(elemType));
          this.writeVarint32(size);
        }
      };
      TCompactProtocol.prototype.writeVarint32 = function(n) {
        var buf = new Buffer2(5);
        var wsize = 0;
        while (true) {
          if ((n & ~127) === 0) {
            buf[wsize++] = n;
            break;
          } else {
            buf[wsize++] = n & 127 | 128;
            n = n >>> 7;
          }
        }
        var wbuf = new Buffer2(wsize);
        buf.copy(wbuf, 0, 0, wsize);
        this.trans.write(wbuf);
      };
      TCompactProtocol.prototype.writeVarint64 = function(n) {
        if (typeof n === "number") {
          n = new Int644(n);
        }
        if (!(n instanceof Int644)) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + n);
        }
        var buf = new Buffer2(10);
        var wsize = 0;
        var hi = n.buffer.readUInt32BE(0, true);
        var lo = n.buffer.readUInt32BE(4, true);
        var mask = 0;
        while (true) {
          if ((lo & ~127) === 0 && hi === 0) {
            buf[wsize++] = lo;
            break;
          } else {
            buf[wsize++] = lo & 127 | 128;
            mask = hi << 25;
            lo = lo >>> 7;
            hi = hi >>> 7;
            lo = lo | mask;
          }
        }
        var wbuf = new Buffer2(wsize);
        buf.copy(wbuf, 0, 0, wsize);
        this.trans.write(wbuf);
      };
      TCompactProtocol.prototype.i64ToZigzag = function(l) {
        if (typeof l === "string") {
          l = new Int644(parseInt(l, 10));
        } else if (typeof l === "number") {
          l = new Int644(l);
        }
        if (!(l instanceof Int644)) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + l);
        }
        var hi = l.buffer.readUInt32BE(0, true);
        var lo = l.buffer.readUInt32BE(4, true);
        var sign = hi >>> 31;
        hi = (hi << 1 | lo >>> 31) ^ (!!sign ? 4294967295 : 0);
        lo = lo << 1 ^ (!!sign ? 4294967295 : 0);
        return new Int644(hi, lo);
      };
      TCompactProtocol.prototype.i32ToZigzag = function(n) {
        return n << 1 ^ (n & 2147483648 ? 4294967295 : 0);
      };
      TCompactProtocol.prototype.readMessageBegin = function() {
        var protocolId = this.trans.readByte();
        if (protocolId != TCompactProtocol.PROTOCOL_ID) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol identifier " + protocolId);
        }
        var versionAndType = this.trans.readByte();
        var version2 = versionAndType & TCompactProtocol.VERSION_MASK;
        if (version2 != TCompactProtocol.VERSION_N) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol version " + version2);
        }
        var type = versionAndType >> TCompactProtocol.TYPE_SHIFT_AMOUNT & TCompactProtocol.TYPE_BITS;
        var seqid = this.readVarint32();
        var name = this.readString();
        return { fname: name, mtype: type, rseqid: seqid };
      };
      TCompactProtocol.prototype.readMessageEnd = function() {
      };
      TCompactProtocol.prototype.readStructBegin = function() {
        this.lastField_.push(this.lastFieldId_);
        this.lastFieldId_ = 0;
        return { fname: "" };
      };
      TCompactProtocol.prototype.readStructEnd = function() {
        this.lastFieldId_ = this.lastField_.pop();
      };
      TCompactProtocol.prototype.readFieldBegin = function() {
        var fieldId = 0;
        var b = this.trans.readByte(b);
        var type = b & 15;
        if (type == TCompactProtocol.Types.CT_STOP) {
          return { fname: null, ftype: Thrift.Type.STOP, fid: 0 };
        }
        var modifier = (b & 240) >>> 4;
        if (modifier === 0) {
          fieldId = this.readI16();
        } else {
          fieldId = this.lastFieldId_ + modifier;
        }
        var fieldType = this.getTType(type);
        if (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE || type == TCompactProtocol.Types.CT_BOOLEAN_FALSE) {
          this.boolValue_.hasBoolValue = true;
          this.boolValue_.boolValue = type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ? true : false;
        }
        this.lastFieldId_ = fieldId;
        return { fname: null, ftype: fieldType, fid: fieldId };
      };
      TCompactProtocol.prototype.readFieldEnd = function() {
      };
      TCompactProtocol.prototype.readMapBegin = function() {
        var msize = this.readVarint32();
        if (msize < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative map size");
        }
        var kvType = 0;
        if (msize !== 0) {
          kvType = this.trans.readByte();
        }
        var keyType = this.getTType((kvType & 240) >>> 4);
        var valType = this.getTType(kvType & 15);
        return { ktype: keyType, vtype: valType, size: msize };
      };
      TCompactProtocol.prototype.readMapEnd = function() {
      };
      TCompactProtocol.prototype.readListBegin = function() {
        var size_and_type = this.trans.readByte();
        var lsize = size_and_type >>> 4 & 15;
        if (lsize == 15) {
          lsize = this.readVarint32();
        }
        if (lsize < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative list size");
        }
        var elemType = this.getTType(size_and_type & 15);
        return { etype: elemType, size: lsize };
      };
      TCompactProtocol.prototype.readListEnd = function() {
      };
      TCompactProtocol.prototype.readSetBegin = function() {
        return this.readListBegin();
      };
      TCompactProtocol.prototype.readSetEnd = function() {
      };
      TCompactProtocol.prototype.readBool = function() {
        var value = false;
        var rsize = 0;
        if (this.boolValue_.hasBoolValue === true) {
          value = this.boolValue_.boolValue;
          this.boolValue_.hasBoolValue = false;
        } else {
          var res = this.trans.readByte();
          rsize = res.rsize;
          value = res.value == TCompactProtocol.Types.CT_BOOLEAN_TRUE;
        }
        return value;
      };
      TCompactProtocol.prototype.readByte = function() {
        return this.trans.readByte();
      };
      TCompactProtocol.prototype.readI16 = function() {
        return this.readI32();
      };
      TCompactProtocol.prototype.readI32 = function() {
        return this.zigzagToI32(this.readVarint32());
      };
      TCompactProtocol.prototype.readI64 = function() {
        return this.zigzagToI64(this.readVarint64());
      };
      TCompactProtocol.prototype.readDouble = function() {
        var buff = this.trans.read(8);
        var off = 0;
        var signed = buff[off + 7] & 128;
        var e2 = (buff[off + 6] & 240) >> 4;
        e2 += (buff[off + 7] & 127) << 4;
        var m = buff[off];
        m += buff[off + 1] << 8;
        m += buff[off + 2] << 16;
        m += buff[off + 3] * POW_24;
        m += buff[off + 4] * POW_32;
        m += buff[off + 5] * POW_40;
        m += (buff[off + 6] & 15) * POW_48;
        switch (e2) {
          case 0:
            e2 = -1022;
            break;
          case 2047:
            return m ? NaN : signed ? -Infinity : Infinity;
          default:
            m += POW_52;
            e2 -= 1023;
        }
        if (signed) {
          m *= -1;
        }
        return m * Math.pow(2, e2 - 52);
      };
      TCompactProtocol.prototype.readBinary = function() {
        var size = this.readVarint32();
        if (size === 0) {
          return new Buffer2(0);
        }
        if (size < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
        }
        return this.trans.read(size);
      };
      TCompactProtocol.prototype.readString = function() {
        var size = this.readVarint32();
        if (size === 0) {
          return "";
        }
        if (size < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
        }
        return this.trans.readString(size);
      };
      TCompactProtocol.prototype.readVarint32 = function() {
        return this.readVarint64().toNumber();
      };
      TCompactProtocol.prototype.readVarint64 = function() {
        var rsize = 0;
        var lo = 0;
        var hi = 0;
        var shift = 0;
        while (true) {
          var b = this.trans.readByte();
          rsize++;
          if (shift <= 25) {
            lo = lo | (b & 127) << shift;
          } else if (25 < shift && shift < 32) {
            lo = lo | (b & 127) << shift;
            hi = hi | (b & 127) >>> 32 - shift;
          } else {
            hi = hi | (b & 127) << shift - 32;
          }
          shift += 7;
          if (!(b & 128)) {
            break;
          }
          if (rsize >= 10) {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Variable-length int over 10 bytes.");
          }
        }
        return new Int644(hi, lo);
      };
      TCompactProtocol.prototype.zigzagToI32 = function(n) {
        return n >>> 1 ^ -1 * (n & 1);
      };
      TCompactProtocol.prototype.zigzagToI64 = function(n) {
        var hi = n.buffer.readUInt32BE(0, true);
        var lo = n.buffer.readUInt32BE(4, true);
        var neg = new Int644(hi & 0, lo & 1);
        neg._2scomp();
        var hi_neg = neg.buffer.readUInt32BE(0, true);
        var lo_neg = neg.buffer.readUInt32BE(4, true);
        var hi_lo = hi << 31;
        hi = hi >>> 1 ^ hi_neg;
        lo = (lo >>> 1 | hi_lo) ^ lo_neg;
        return new Int644(hi, lo);
      };
      TCompactProtocol.prototype.skip = function(type) {
        switch (type) {
          case Type.BOOL:
            this.readBool();
            break;
          case Type.BYTE:
            this.readByte();
            break;
          case Type.I16:
            this.readI16();
            break;
          case Type.I32:
            this.readI32();
            break;
          case Type.I64:
            this.readI64();
            break;
          case Type.DOUBLE:
            this.readDouble();
            break;
          case Type.STRING:
            this.readString();
            break;
          case Type.STRUCT:
            this.readStructBegin();
            while (true) {
              var r = this.readFieldBegin();
              if (r.ftype === Type.STOP) {
                break;
              }
              this.skip(r.ftype);
              this.readFieldEnd();
            }
            this.readStructEnd();
            break;
          case Type.MAP:
            var mapBegin = this.readMapBegin();
            for (var i = 0; i < mapBegin.size; ++i) {
              this.skip(mapBegin.ktype);
              this.skip(mapBegin.vtype);
            }
            this.readMapEnd();
            break;
          case Type.SET:
            var setBegin = this.readSetBegin();
            for (var i2 = 0; i2 < setBegin.size; ++i2) {
              this.skip(setBegin.etype);
            }
            this.readSetEnd();
            break;
          case Type.LIST:
            var listBegin = this.readListBegin();
            for (var i3 = 0; i3 < listBegin.size; ++i3) {
              this.skip(listBegin.etype);
            }
            this.readListEnd();
            break;
          default:
            throw new Error("Invalid type: " + type);
        }
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/binary_protocol.js
  var require_binary_protocol = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/binary_protocol.js"(exports, module) {
      init_esbuild_shims();
      var log = require_log();
      var binary = require_binary();
      var Int644 = require_Int64();
      var Thrift = require_thrift();
      var Type = Thrift.Type;
      module.exports = TBinaryProtocol;
      var VERSION_MASK = -65536;
      var VERSION_1 = -2147418112;
      var TYPE_MASK = 255;
      TBinaryProtocol.VERSION_MASK = VERSION_MASK;
      TBinaryProtocol.VERSION_1 = VERSION_1;
      TBinaryProtocol.TYPE_MASK = TYPE_MASK;
      function TBinaryProtocol(trans, strictRead, strictWrite) {
        this.trans = trans;
        this.strictRead = strictRead !== void 0 ? strictRead : false;
        this.strictWrite = strictWrite !== void 0 ? strictWrite : true;
        this._seqid = null;
      }
      TBinaryProtocol.prototype.flush = function() {
        return this.trans.flush();
      };
      TBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
        if (this.strictWrite) {
          this.writeI32(VERSION_1 | type);
          this.writeString(name);
          this.writeI32(seqid);
        } else {
          this.writeString(name);
          this.writeByte(type);
          this.writeI32(seqid);
        }
        if (this._seqid !== null) {
          log.warning("SeqId already set", { "name": name });
        } else {
          this._seqid = seqid;
          this.trans.setCurrSeqId(seqid);
        }
      };
      TBinaryProtocol.prototype.writeMessageEnd = function() {
        if (this._seqid !== null) {
          this._seqid = null;
        } else {
          log.warning("No seqid to unset");
        }
      };
      TBinaryProtocol.prototype.writeStructBegin = function(name) {
      };
      TBinaryProtocol.prototype.writeStructEnd = function() {
      };
      TBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {
        this.writeByte(type);
        this.writeI16(id);
      };
      TBinaryProtocol.prototype.writeFieldEnd = function() {
      };
      TBinaryProtocol.prototype.writeFieldStop = function() {
        this.writeByte(Type.STOP);
      };
      TBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
        this.writeByte(ktype);
        this.writeByte(vtype);
        this.writeI32(size);
      };
      TBinaryProtocol.prototype.writeMapEnd = function() {
      };
      TBinaryProtocol.prototype.writeListBegin = function(etype, size) {
        this.writeByte(etype);
        this.writeI32(size);
      };
      TBinaryProtocol.prototype.writeListEnd = function() {
      };
      TBinaryProtocol.prototype.writeSetBegin = function(etype, size) {
        this.writeByte(etype);
        this.writeI32(size);
      };
      TBinaryProtocol.prototype.writeSetEnd = function() {
      };
      TBinaryProtocol.prototype.writeBool = function(bool) {
        if (bool) {
          this.writeByte(1);
        } else {
          this.writeByte(0);
        }
      };
      TBinaryProtocol.prototype.writeByte = function(b) {
        this.trans.write(new Buffer2([b]));
      };
      TBinaryProtocol.prototype.writeI16 = function(i16) {
        this.trans.write(binary.writeI16(new Buffer2(2), i16));
      };
      TBinaryProtocol.prototype.writeI32 = function(i32) {
        this.trans.write(binary.writeI32(new Buffer2(4), i32));
      };
      TBinaryProtocol.prototype.writeI64 = function(i64) {
        if (i64.buffer) {
          this.trans.write(i64.buffer);
        } else {
          this.trans.write(new Int644(i64).buffer);
        }
      };
      TBinaryProtocol.prototype.writeDouble = function(dub) {
        this.trans.write(binary.writeDouble(new Buffer2(8), dub));
      };
      TBinaryProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
        if (typeof arg === "string") {
          this.writeI32(Buffer2.byteLength(arg, encoding));
          this.trans.write(new Buffer2(arg, encoding));
        } else if (arg instanceof Buffer2 || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
          this.writeI32(arg.length);
          this.trans.write(arg);
        } else {
          throw new Error(name + " called without a string/Buffer argument: " + arg);
        }
      };
      TBinaryProtocol.prototype.writeString = function(arg) {
        this.writeStringOrBinary("writeString", "utf8", arg);
      };
      TBinaryProtocol.prototype.writeBinary = function(arg) {
        this.writeStringOrBinary("writeBinary", "binary", arg);
      };
      TBinaryProtocol.prototype.readMessageBegin = function() {
        var sz = this.readI32();
        var type, name, seqid;
        if (sz < 0) {
          var version2 = sz & VERSION_MASK;
          if (version2 != VERSION_1) {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad version in readMessageBegin: " + sz);
          }
          type = sz & TYPE_MASK;
          name = this.readString();
          seqid = this.readI32();
        } else {
          if (this.strictRead) {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "No protocol version header");
          }
          name = this.trans.read(sz);
          type = this.readByte();
          seqid = this.readI32();
        }
        return { fname: name, mtype: type, rseqid: seqid };
      };
      TBinaryProtocol.prototype.readMessageEnd = function() {
      };
      TBinaryProtocol.prototype.readStructBegin = function() {
        return { fname: "" };
      };
      TBinaryProtocol.prototype.readStructEnd = function() {
      };
      TBinaryProtocol.prototype.readFieldBegin = function() {
        var type = this.readByte();
        if (type == Type.STOP) {
          return { fname: null, ftype: type, fid: 0 };
        }
        var id = this.readI16();
        return { fname: null, ftype: type, fid: id };
      };
      TBinaryProtocol.prototype.readFieldEnd = function() {
      };
      TBinaryProtocol.prototype.readMapBegin = function() {
        var ktype = this.readByte();
        var vtype = this.readByte();
        var size = this.readI32();
        return { ktype, vtype, size };
      };
      TBinaryProtocol.prototype.readMapEnd = function() {
      };
      TBinaryProtocol.prototype.readListBegin = function() {
        var etype = this.readByte();
        var size = this.readI32();
        return { etype, size };
      };
      TBinaryProtocol.prototype.readListEnd = function() {
      };
      TBinaryProtocol.prototype.readSetBegin = function() {
        var etype = this.readByte();
        var size = this.readI32();
        return { etype, size };
      };
      TBinaryProtocol.prototype.readSetEnd = function() {
      };
      TBinaryProtocol.prototype.readBool = function() {
        var b = this.readByte();
        if (b === 0) {
          return false;
        }
        return true;
      };
      TBinaryProtocol.prototype.readByte = function() {
        return this.trans.readByte();
      };
      TBinaryProtocol.prototype.readI16 = function() {
        return this.trans.readI16();
      };
      TBinaryProtocol.prototype.readI32 = function() {
        return this.trans.readI32();
      };
      TBinaryProtocol.prototype.readI64 = function() {
        var buff = this.trans.read(8);
        return new Int644(buff);
      };
      TBinaryProtocol.prototype.readDouble = function() {
        return this.trans.readDouble();
      };
      TBinaryProtocol.prototype.readBinary = function() {
        var len = this.readI32();
        if (len === 0) {
          return new Buffer2(0);
        }
        if (len < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
        }
        return this.trans.read(len);
      };
      TBinaryProtocol.prototype.readString = function() {
        var len = this.readI32();
        if (len === 0) {
          return "";
        }
        if (len < 0) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
        }
        return this.trans.readString(len);
      };
      TBinaryProtocol.prototype.getTransport = function() {
        return this.trans;
      };
      TBinaryProtocol.prototype.skip = function(type) {
        switch (type) {
          case Type.BOOL:
            this.readBool();
            break;
          case Type.BYTE:
            this.readByte();
            break;
          case Type.I16:
            this.readI16();
            break;
          case Type.I32:
            this.readI32();
            break;
          case Type.I64:
            this.readI64();
            break;
          case Type.DOUBLE:
            this.readDouble();
            break;
          case Type.STRING:
            this.readString();
            break;
          case Type.STRUCT:
            this.readStructBegin();
            while (true) {
              var r = this.readFieldBegin();
              if (r.ftype === Type.STOP) {
                break;
              }
              this.skip(r.ftype);
              this.readFieldEnd();
            }
            this.readStructEnd();
            break;
          case Type.MAP:
            var mapBegin = this.readMapBegin();
            for (var i = 0; i < mapBegin.size; ++i) {
              this.skip(mapBegin.ktype);
              this.skip(mapBegin.vtype);
            }
            this.readMapEnd();
            break;
          case Type.SET:
            var setBegin = this.readSetBegin();
            for (var i2 = 0; i2 < setBegin.size; ++i2) {
              this.skip(setBegin.etype);
            }
            this.readSetEnd();
            break;
          case Type.LIST:
            var listBegin = this.readListBegin();
            for (var i3 = 0; i3 < listBegin.size; ++i3) {
              this.skip(listBegin.etype);
            }
            this.readListEnd();
            break;
          default:
            throw new Error("Invalid type: " + type);
        }
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/header_transport.js
  var require_header_transport = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/header_transport.js"(exports, module) {
      init_esbuild_shims();
      var util = require_util();
      var TCompactProtocol = require_compact_protocol();
      var TBinaryProtocol = require_binary_protocol();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      function THeaderTransportError(message) {
        Error.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = this.constructor.name;
        this.message = message;
      }
      util.inherits(THeaderTransportError, Error);
      module.exports = THeaderTransport;
      var COMPACT_PROTOCOL_OFFSET = 0;
      var COMPACT_PROTOCOL_VERSION_OFFSET = 1;
      var FRAME_SIZE_OFFSET = 0;
      var HEADER_MAGIC_OFFSET = 32 / 8;
      var FLAGS_OFFSET = 48 / 8;
      var SEQID_OFFSET = 64 / 8;
      var HEADER_SIZE_OFFSET = 96 / 8;
      var HEADER_START_OFFSET = 112 / 8;
      var HEADER_MAGIC = 4095;
      var TINFO_HEADER_KEY_VALUE_TYPE = 1;
      var MAX_FRAME_SIZE = 1073741823;
      function VarintHelper(readBuffer) {
        var TBufferedTransport = require_buffered_transport();
        this.outputBuffer = null;
        var _this = this;
        this.transport = new TBufferedTransport(null, function(output) {
          _this.outputBuffer = output;
        });
        this.transport.inBuf = readBuffer || Buffer2.alloc(0);
        this.transport.writeCursor = this.transport.inBuf.length;
        this.protocol = new TCompactProtocol(this.transport);
      }
      VarintHelper.prototype.readVarint32 = function() {
        return this.protocol.readVarint32();
      };
      VarintHelper.prototype.writeVarint32 = function(i) {
        this.protocol.writeVarint32(i);
      };
      VarintHelper.prototype.readString = function() {
        return this.protocol.readString();
      };
      VarintHelper.prototype.writeString = function(str) {
        this.protocol.writeString(str);
      };
      VarintHelper.prototype.getOutCount = function() {
        return this.transport.outCount;
      };
      VarintHelper.prototype.write = function(str) {
        this.transport.write(str);
      };
      VarintHelper.prototype.toBuffer = function() {
        this.transport.flush();
        return this.outputBuffer;
      };
      THeaderTransport.SubprotocolId = {
        BINARY: 0,
        JSON: 1,
        COMPACT: 2
      };
      function THeaderTransport() {
        this.maxFrameSize = MAX_FRAME_SIZE;
        this.protocolId = THeaderTransport.SubprotocolId.BINARY;
        this.rheaders = {};
        this.wheaders = {};
        this.inBuf = Buffer2.alloc(0);
        this.outCount = 0;
        this.flags = null;
        this.seqid = 0;
        this.shouldWriteHeaders = true;
      }
      var validateHeaders = function(key, value) {
        if (typeof key !== "string" || typeof value !== "string") {
          throw new THeaderTransportError("Header key and values must be strings");
        }
      };
      var validateProtocolId = function(protocolId) {
        var protocols = Object.keys(THeaderTransport.SubprotocolId);
        for (var i = 0; i < protocols.length; i++) {
          if (protocolId === THeaderTransport.SubprotocolId[protocols[i]]) return true;
        }
        throw new Error(protocolId + " is not a valid protocol id");
      };
      THeaderTransport.prototype.setSeqId = function(seqid) {
        this.seqid = seqid;
      };
      THeaderTransport.prototype.getSeqId = function(seqid) {
        return this.seqid;
      };
      THeaderTransport.prototype.setFlags = function(flags) {
        this.flags = flags;
      };
      THeaderTransport.prototype.getReadHeaders = function() {
        return this.rheaders;
      };
      THeaderTransport.prototype.setReadHeader = function(key, value) {
        validateHeaders(key, value);
        this.rheaders[key] = value;
      };
      THeaderTransport.prototype.clearReadHeaders = function() {
        this.rheaders = {};
      };
      THeaderTransport.prototype.getWriteHeaders = function() {
        return this.wheaders;
      };
      THeaderTransport.prototype.setWriteHeader = function(key, value) {
        validateHeaders(key, value);
        this.wheaders[key] = value;
      };
      THeaderTransport.prototype.clearWriteHeaders = function() {
        this.wheaders = {};
      };
      THeaderTransport.prototype.setMaxFrameSize = function(frameSize) {
        this.maxFrameSize = frameSize;
      };
      THeaderTransport.prototype.setProtocolId = function(protocolId) {
        validateProtocolId(protocolId);
        this.protocolId = protocolId;
      };
      THeaderTransport.prototype.getProtocolId = function() {
        return this.protocolId;
      };
      var isUnframedBinary = function(readBuffer) {
        var version2 = readBuffer.readInt32BE();
        return (version2 & TBinaryProtocol.VERSION_MASK) === TBinaryProtocol.VERSION_1;
      };
      var isUnframedCompact = function(readBuffer) {
        var protocolId = readBuffer.readInt8(COMPACT_PROTOCOL_OFFSET);
        var version2 = readBuffer.readInt8(COMPACT_PROTOCOL_VERSION_OFFSET);
        return protocolId === TCompactProtocol.PROTOCOL_ID && (version2 & TCompactProtocol.VERSION_MASK) === TCompactProtocol.VERSION_N;
      };
      THeaderTransport.prototype.readHeaders = function() {
        var readBuffer = this.inBuf;
        var isUnframed = false;
        if (isUnframedBinary(readBuffer)) {
          this.setProtocolId(THeaderTransport.SubprotocolId.BINARY);
          isUnframed = true;
        }
        if (isUnframedCompact(readBuffer)) {
          this.setProtocolId(THeaderTransport.SubprotocolId.COMPACT);
          isUnframed = true;
        }
        if (isUnframed) {
          this.shouldWriteHeaders = false;
          return;
        }
        var frameSize = readBuffer.readInt32BE(FRAME_SIZE_OFFSET);
        if (frameSize > this.maxFrameSize) {
          throw new THeaderTransportError("Frame exceeds maximum frame size");
        }
        var headerMagic = readBuffer.readInt16BE(HEADER_MAGIC_OFFSET);
        this.shouldWriteHeaders = headerMagic === HEADER_MAGIC;
        if (!this.shouldWriteHeaders) {
          return;
        }
        this.setFlags(readBuffer.readInt16BE(FLAGS_OFFSET));
        this.setSeqId(readBuffer.readInt32BE(SEQID_OFFSET));
        var headerSize = readBuffer.readInt16BE(HEADER_SIZE_OFFSET) * 4;
        var endOfHeaders = HEADER_START_OFFSET + headerSize;
        if (endOfHeaders > readBuffer.length) {
          throw new THeaderTransportError("Header size is greater than frame size");
        }
        var headerBuffer = Buffer2.alloc(headerSize);
        readBuffer.copy(headerBuffer, 0, HEADER_START_OFFSET, endOfHeaders);
        var varintHelper = new VarintHelper(headerBuffer);
        this.setProtocolId(varintHelper.readVarint32());
        var transformCount = varintHelper.readVarint32();
        if (transformCount > 0) {
          throw new THeaderTransportError("Transforms are not yet supported");
        }
        while (true) {
          try {
            var headerType = varintHelper.readVarint32();
            if (headerType !== TINFO_HEADER_KEY_VALUE_TYPE) {
              break;
            }
            var numberOfHeaders = varintHelper.readVarint32();
            for (var i = 0; i < numberOfHeaders; i++) {
              var key = varintHelper.readString();
              var value = varintHelper.readString();
              this.setReadHeader(key, value);
            }
          } catch (e2) {
            if (e2 instanceof InputBufferUnderrunError) {
              break;
            }
            throw e2;
          }
        }
        this.read(endOfHeaders);
        return this.getReadHeaders();
      };
      THeaderTransport.prototype.writeHeaders = function() {
        if (!this.shouldWriteHeaders) {
          return;
        }
        var headers = this.getWriteHeaders();
        var varintWriter = new VarintHelper();
        varintWriter.writeVarint32(this.protocolId);
        varintWriter.writeVarint32(0);
        var headerKeys = Object.keys(headers);
        if (headerKeys.length > 0) {
          varintWriter.writeVarint32(TINFO_HEADER_KEY_VALUE_TYPE);
          varintWriter.writeVarint32(headerKeys.length);
          for (var i = 0; i < headerKeys.length; i++) {
            var key = headerKeys[i];
            var value = headers[key];
            varintWriter.writeString(key);
            varintWriter.writeString(value);
          }
        }
        var headerSizeWithoutPadding = varintWriter.getOutCount();
        var paddingNeeded = (4 - headerSizeWithoutPadding % 4) % 4;
        var headerSize = Buffer2.alloc(2);
        headerSize.writeInt16BE(Math.floor((headerSizeWithoutPadding + paddingNeeded) / 4));
        var paddingBuffer = Buffer2.alloc(paddingNeeded);
        paddingBuffer.fill(0);
        varintWriter.write(paddingBuffer);
        var headerContentBuffer = varintWriter.toBuffer();
        var frameSize = Buffer2.alloc(4);
        frameSize.writeInt32BE(10 + this.outCount + headerContentBuffer.length);
        var headerMagic = Buffer2.alloc(2);
        headerMagic.writeInt16BE(HEADER_MAGIC);
        var flags = Buffer2.alloc(2);
        flags.writeInt16BE(0);
        var seqid = Buffer2.alloc(4);
        seqid.writeInt32BE(this.getSeqId());
        var headerBuffer = Buffer2.concat([
          frameSize,
          headerMagic,
          flags,
          seqid,
          headerSize,
          headerContentBuffer
        ]);
        this.outBuffers.unshift(headerBuffer);
        this.outCount += headerBuffer.length;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/buffered_transport.js
  var require_buffered_transport = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/buffered_transport.js"(exports, module) {
      init_esbuild_shims();
      var binary = require_binary();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      var THeaderTransport = require_header_transport();
      module.exports = TBufferedTransport;
      function TBufferedTransport(buffer2, callback) {
        THeaderTransport.call(this);
        this.defaultReadBufferSize = 1024;
        this.writeBufferSize = 512;
        this.inBuf = new Buffer2(this.defaultReadBufferSize);
        this.readCursor = 0;
        this.writeCursor = 0;
        this.outBuffers = [];
        this.outCount = 0;
        this.onFlush = callback;
      }
      Object.setPrototypeOf(TBufferedTransport.prototype, THeaderTransport.prototype);
      TBufferedTransport.prototype.reset = function() {
        this.inBuf = new Buffer2(this.defaultReadBufferSize);
        this.readCursor = 0;
        this.writeCursor = 0;
        this.outBuffers = [];
        this.outCount = 0;
      };
      TBufferedTransport.receiver = function(callback, seqid) {
        var reader = new TBufferedTransport();
        return function(data) {
          if (reader.writeCursor + data.length > reader.inBuf.length) {
            var buf = new Buffer2(reader.writeCursor + data.length);
            reader.inBuf.copy(buf, 0, 0, reader.writeCursor);
            reader.inBuf = buf;
          }
          data.copy(reader.inBuf, reader.writeCursor, 0);
          reader.writeCursor += data.length;
          callback(reader, seqid);
        };
      };
      TBufferedTransport.prototype.commitPosition = function() {
        var unreadSize = this.writeCursor - this.readCursor;
        var bufSize = unreadSize * 2 > this.defaultReadBufferSize ? unreadSize * 2 : this.defaultReadBufferSize;
        var buf = new Buffer2(bufSize);
        if (unreadSize > 0) {
          this.inBuf.copy(buf, 0, this.readCursor, this.writeCursor);
        }
        this.readCursor = 0;
        this.writeCursor = unreadSize;
        this.inBuf = buf;
      };
      TBufferedTransport.prototype.rollbackPosition = function() {
        this.readCursor = 0;
      };
      TBufferedTransport.prototype.isOpen = function() {
        return true;
      };
      TBufferedTransport.prototype.open = function() {
      };
      TBufferedTransport.prototype.close = function() {
      };
      TBufferedTransport.prototype.setCurrSeqId = function(seqid) {
        this._seqid = seqid;
      };
      TBufferedTransport.prototype.ensureAvailable = function(len) {
        if (this.readCursor + len > this.writeCursor) {
          throw new InputBufferUnderrunError();
        }
      };
      TBufferedTransport.prototype.read = function(len) {
        this.ensureAvailable(len);
        var buf = new Buffer2(len);
        this.inBuf.copy(buf, 0, this.readCursor, this.readCursor + len);
        this.readCursor += len;
        return buf;
      };
      TBufferedTransport.prototype.readByte = function() {
        this.ensureAvailable(1);
        return binary.readByte(this.inBuf[this.readCursor++]);
      };
      TBufferedTransport.prototype.readI16 = function() {
        this.ensureAvailable(2);
        var i16 = binary.readI16(this.inBuf, this.readCursor);
        this.readCursor += 2;
        return i16;
      };
      TBufferedTransport.prototype.readI32 = function() {
        this.ensureAvailable(4);
        var i32 = binary.readI32(this.inBuf, this.readCursor);
        this.readCursor += 4;
        return i32;
      };
      TBufferedTransport.prototype.readDouble = function() {
        this.ensureAvailable(8);
        var d = binary.readDouble(this.inBuf, this.readCursor);
        this.readCursor += 8;
        return d;
      };
      TBufferedTransport.prototype.readString = function(len) {
        this.ensureAvailable(len);
        var str = this.inBuf.toString("utf8", this.readCursor, this.readCursor + len);
        this.readCursor += len;
        return str;
      };
      TBufferedTransport.prototype.borrow = function() {
        var obj = { buf: this.inBuf, readIndex: this.readCursor, writeIndex: this.writeCursor };
        return obj;
      };
      TBufferedTransport.prototype.consume = function(bytesConsumed) {
        this.readCursor += bytesConsumed;
      };
      TBufferedTransport.prototype.write = function(buf) {
        if (typeof buf === "string") {
          buf = new Buffer2(buf, "utf8");
        }
        this.outBuffers.push(buf);
        this.outCount += buf.length;
      };
      TBufferedTransport.prototype.flush = function() {
        var seqid = this._seqid;
        this._seqid = null;
        if (this.outCount < 1) {
          return;
        }
        var msg = new Buffer2(this.outCount), pos = 0;
        this.outBuffers.forEach(function(buf) {
          buf.copy(msg, pos, 0);
          pos += buf.length;
        });
        if (this.onFlush) {
          this.onFlush(msg, seqid);
        }
        this.outBuffers = [];
        this.outCount = 0;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/int64_util.js
  var require_int64_util = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/int64_util.js"(exports, module) {
      init_esbuild_shims();
      var Int644 = require_Int64();
      var Int64Util = module.exports = {};
      var POW2_24 = Math.pow(2, 24);
      var POW2_31 = Math.pow(2, 31);
      var POW2_32 = Math.pow(2, 32);
      var POW10_11 = Math.pow(10, 11);
      Int64Util.toDecimalString = function(i64) {
        var b = i64.buffer;
        var o = i64.offset;
        if (!b[o] && !(b[o + 1] & 224) || !~b[o] && !~(b[o + 1] & 224)) {
          return i64.toString();
        } else {
          var negative = b[o] & 128;
          if (negative) {
            var incremented = false;
            var buffer2 = new Buffer2(8);
            for (var i = 7; i >= 0; --i) {
              buffer2[i] = ~b[o + i] + (incremented ? 0 : 1) & 255;
              incremented |= b[o + i];
            }
            b = buffer2;
          }
          var high2 = b[o + 1] + (b[o] << 8);
          var low = b[o + 7] + (b[o + 6] << 8) + (b[o + 5] << 16) + b[o + 4] * POW2_24 + (b[o + 3] + (b[o + 2] << 8)) * POW2_32 + high2 * 74976710656;
          var high = Math.floor(low / POW10_11) + high2 * 2814;
          low = ("00000000000" + String(low % POW10_11)).slice(-11);
          return (negative ? "-" : "") + String(high) + low;
        }
      };
      Int64Util.fromDecimalString = function(text) {
        var negative = text.charAt(0) === "-";
        if (text.length < (negative ? 17 : 16)) {
          return new Int644(+text);
        } else if (text.length > (negative ? 20 : 19)) {
          throw new RangeError("Too many digits for Int64: " + text);
        } else {
          var high5 = +text.slice(negative ? 1 : 0, -15);
          var low = +text.slice(-15) + high5 * 2764472320;
          var high = Math.floor(low / POW2_32) + high5 * 232830;
          low = low % POW2_32;
          if (high >= POW2_31 && !(negative && high == POW2_31 && low == 0)) {
            throw new RangeError("The magnitude is too large for Int64.");
          }
          if (negative) {
            high = ~high;
            if (low === 0) {
              high = high + 1 & 4294967295;
            } else {
              low = ~low + 1;
            }
            high = 2147483648 | high;
          }
          return new Int644(high, low);
        }
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/json_parse.js
  var require_json_parse = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/json_parse.js"(exports, module) {
      init_esbuild_shims();
      var Int644 = require_Int64();
      var Int64Util = require_int64_util();
      var json_parse = module.exports = function() {
        "use strict";
        var at, ch, escapee = {
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	"
        }, text, error = function(m) {
          throw new SyntaxError(m);
        }, next = function(c) {
          if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
          }
          ch = text.charAt(at);
          at += 1;
          return ch;
        }, number = function() {
          var number2, string2 = "";
          if (ch === "-") {
            string2 = "-";
            next("-");
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
          if (ch === ".") {
            string2 += ".";
            while (next() && ch >= "0" && ch <= "9") {
              string2 += ch;
            }
          }
          if (ch === "e" || ch === "E") {
            string2 += ch;
            next();
            if (ch === "-" || ch === "+") {
              string2 += ch;
              next();
            }
            while (ch >= "0" && ch <= "9") {
              string2 += ch;
              next();
            }
          }
          number2 = +string2;
          if (!isFinite(number2)) {
            error("Bad number");
          } else if (number2 >= Int644.MAX_INT || number2 <= Int644.MIN_INT) {
            return string2;
          } else {
            return number2;
          }
        }, string = function() {
          var hex, i, string2 = "", uffff;
          if (ch === '"') {
            while (next()) {
              if (ch === '"') {
                next();
                return string2;
              }
              if (ch === "\\") {
                next();
                if (ch === "u") {
                  uffff = 0;
                  for (i = 0; i < 4; i += 1) {
                    hex = parseInt(next(), 16);
                    if (!isFinite(hex)) {
                      break;
                    }
                    uffff = uffff * 16 + hex;
                  }
                  string2 += String.fromCharCode(uffff);
                } else if (typeof escapee[ch] === "string") {
                  string2 += escapee[ch];
                } else {
                  break;
                }
              } else {
                string2 += ch;
              }
            }
          }
          error("Bad string");
        }, white = function() {
          while (ch && ch <= " ") {
            next();
          }
        }, word = function() {
          switch (ch) {
            case "t":
              next("t");
              next("r");
              next("u");
              next("e");
              return true;
            case "f":
              next("f");
              next("a");
              next("l");
              next("s");
              next("e");
              return false;
            case "n":
              next("n");
              next("u");
              next("l");
              next("l");
              return null;
          }
          error("Unexpected '" + ch + "'");
        }, value, array = function() {
          var array2 = [];
          if (ch === "[") {
            next("[");
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            while (ch) {
              array2.push(value());
              white();
              if (ch === "]") {
                next("]");
                return array2;
              }
              next(",");
              white();
            }
          }
          error("Bad array");
        }, object = function() {
          var key, object2 = {};
          if (ch === "{") {
            next("{");
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            while (ch) {
              key = string();
              white();
              next(":");
              if (Object.hasOwnProperty.call(object2, key)) {
                error('Duplicate key "' + key + '"');
              }
              object2[key] = value();
              white();
              if (ch === "}") {
                next("}");
                return object2;
              }
              next(",");
              white();
            }
          }
          error("Bad object");
        };
        value = function() {
          white();
          switch (ch) {
            case "{":
              return object();
            case "[":
              return array();
            case '"':
              return string();
            case "-":
              return number();
            default:
              return ch >= "0" && ch <= "9" ? number() : word();
          }
        };
        return function(source) {
          var result;
          text = source;
          at = 0;
          ch = " ";
          result = value();
          white();
          if (ch) {
            error("Syntax error");
          }
          return result;
        };
      }();
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/json_protocol.js
  var require_json_protocol = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/json_protocol.js"(exports, module) {
      init_esbuild_shims();
      var Int644 = require_Int64();
      var Thrift = require_thrift();
      var Type = Thrift.Type;
      var util = require_util();
      var Int64Util = require_int64_util();
      var json_parse = require_json_parse();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      module.exports = TJSONProtocol;
      function TJSONProtocol(trans) {
        this.tstack = [];
        this.tpos = [];
        this.trans = trans;
      }
      TJSONProtocol.Type = {};
      TJSONProtocol.Type[Type.BOOL] = '"tf"';
      TJSONProtocol.Type[Type.BYTE] = '"i8"';
      TJSONProtocol.Type[Type.I16] = '"i16"';
      TJSONProtocol.Type[Type.I32] = '"i32"';
      TJSONProtocol.Type[Type.I64] = '"i64"';
      TJSONProtocol.Type[Type.DOUBLE] = '"dbl"';
      TJSONProtocol.Type[Type.STRUCT] = '"rec"';
      TJSONProtocol.Type[Type.STRING] = '"str"';
      TJSONProtocol.Type[Type.MAP] = '"map"';
      TJSONProtocol.Type[Type.LIST] = '"lst"';
      TJSONProtocol.Type[Type.SET] = '"set"';
      TJSONProtocol.RType = {};
      TJSONProtocol.RType.tf = Type.BOOL;
      TJSONProtocol.RType.i8 = Type.BYTE;
      TJSONProtocol.RType.i16 = Type.I16;
      TJSONProtocol.RType.i32 = Type.I32;
      TJSONProtocol.RType.i64 = Type.I64;
      TJSONProtocol.RType.dbl = Type.DOUBLE;
      TJSONProtocol.RType.rec = Type.STRUCT;
      TJSONProtocol.RType.str = Type.STRING;
      TJSONProtocol.RType.map = Type.MAP;
      TJSONProtocol.RType.lst = Type.LIST;
      TJSONProtocol.RType.set = Type.SET;
      TJSONProtocol.Version = 1;
      TJSONProtocol.prototype.flush = function() {
        this.writeToTransportIfStackIsFlushable();
        return this.trans.flush();
      };
      TJSONProtocol.prototype.writeToTransportIfStackIsFlushable = function() {
        if (this.tstack.length === 1) {
          this.trans.write(this.tstack.pop());
        }
      };
      TJSONProtocol.prototype.writeMessageBegin = function(name, messageType, seqid) {
        this.tstack.push([TJSONProtocol.Version, '"' + name + '"', messageType, seqid]);
      };
      TJSONProtocol.prototype.writeMessageEnd = function() {
        var obj = this.tstack.pop();
        this.wobj = this.tstack.pop();
        this.wobj.push(obj);
        this.wbuf = "[" + this.wobj.join(",") + "]";
        this.trans.write(this.wbuf);
      };
      TJSONProtocol.prototype.writeStructBegin = function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
      };
      TJSONProtocol.prototype.writeStructEnd = function() {
        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = "{";
        var first = true;
        for (var key in struct) {
          if (first) {
            first = false;
          } else {
            str += ",";
          }
          str += key + ":" + struct[key];
        }
        str += "}";
        this.tstack[p] = str;
        this.writeToTransportIfStackIsFlushable();
      };
      TJSONProtocol.prototype.writeFieldBegin = function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({
          "fieldId": '"' + fieldId + '"',
          "fieldType": TJSONProtocol.Type[fieldType]
        });
      };
      TJSONProtocol.prototype.writeFieldEnd = function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();
        if (":" + value === ":[object Object]") {
          this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = "{" + fieldInfo.fieldType + ":" + JSON.stringify(value) + "}";
        } else {
          this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = "{" + fieldInfo.fieldType + ":" + value + "}";
        }
        this.tpos.pop();
        this.writeToTransportIfStackIsFlushable();
      };
      TJSONProtocol.prototype.writeFieldStop = function() {
      };
      TJSONProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([TJSONProtocol.Type[keyType], TJSONProtocol.Type[valType], 0]);
      };
      TJSONProtocol.prototype.writeMapEnd = function() {
        var p = this.tpos.pop();
        if (p == this.tstack.length) {
          return;
        }
        if ((this.tstack.length - p - 1) % 2 !== 0) {
          this.tstack.push("");
        }
        var size = (this.tstack.length - p - 1) / 2;
        this.tstack[p][this.tstack[p].length - 1] = size;
        var map2 = "}";
        var first = true;
        while (this.tstack.length > p + 1) {
          var v = this.tstack.pop();
          var k = this.tstack.pop();
          if (first) {
            first = false;
          } else {
            map2 = "," + map2;
          }
          if (!isNaN(k)) {
            k = '"' + k + '"';
          }
          map2 = k + ":" + v + map2;
        }
        map2 = "{" + map2;
        this.tstack[p].push(map2);
        this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
        this.writeToTransportIfStackIsFlushable();
      };
      TJSONProtocol.prototype.writeListBegin = function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([TJSONProtocol.Type[elemType], size]);
      };
      TJSONProtocol.prototype.writeListEnd = function() {
        var p = this.tpos.pop();
        while (this.tstack.length > p + 1) {
          var tmpVal = this.tstack[p + 1];
          this.tstack.splice(p + 1, 1);
          this.tstack[p].push(tmpVal);
        }
        this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
        this.writeToTransportIfStackIsFlushable();
      };
      TJSONProtocol.prototype.writeSetBegin = function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([TJSONProtocol.Type[elemType], size]);
      };
      TJSONProtocol.prototype.writeSetEnd = function() {
        var p = this.tpos.pop();
        while (this.tstack.length > p + 1) {
          var tmpVal = this.tstack[p + 1];
          this.tstack.splice(p + 1, 1);
          this.tstack[p].push(tmpVal);
        }
        this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
        this.writeToTransportIfStackIsFlushable();
      };
      TJSONProtocol.prototype.writeBool = function(bool) {
        this.tstack.push(bool ? 1 : 0);
      };
      TJSONProtocol.prototype.writeByte = function(byte) {
        this.tstack.push(byte);
      };
      TJSONProtocol.prototype.writeI16 = function(i16) {
        this.tstack.push(i16);
      };
      TJSONProtocol.prototype.writeI32 = function(i32) {
        this.tstack.push(i32);
      };
      TJSONProtocol.prototype.writeI64 = function(i64) {
        if (i64 instanceof Int644) {
          this.tstack.push(Int64Util.toDecimalString(i64));
        } else {
          this.tstack.push(i64);
        }
      };
      TJSONProtocol.prototype.writeDouble = function(dub) {
        this.tstack.push(dub);
      };
      TJSONProtocol.prototype.writeString = function(arg) {
        if (arg === null) {
          this.tstack.push(null);
        } else {
          if (typeof arg === "string") {
            var str = arg;
          } else if (arg instanceof Buffer2) {
            var str = arg.toString("utf8");
          } else {
            throw new Error("writeString called without a string/Buffer argument: " + arg);
          }
          var escapedString = "";
          for (var i = 0; i < str.length; i++) {
            var ch = str.charAt(i);
            if (ch === '"') {
              escapedString += '\\"';
            } else if (ch === "\\") {
              escapedString += "\\\\";
            } else if (ch === "\b") {
              escapedString += "\\b";
            } else if (ch === "\f") {
              escapedString += "\\f";
            } else if (ch === "\n") {
              escapedString += "\\n";
            } else if (ch === "\r") {
              escapedString += "\\r";
            } else if (ch === "	") {
              escapedString += "\\t";
            } else {
              escapedString += ch;
            }
          }
          this.tstack.push('"' + escapedString + '"');
        }
      };
      TJSONProtocol.prototype.writeBinary = function(arg) {
        if (typeof arg === "string") {
          var buf = new Buffer2(arg, "binary");
        } else if (arg instanceof Buffer2 || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
          var buf = arg;
        } else {
          throw new Error("writeBinary called without a string/Buffer argument: " + arg);
        }
        this.tstack.push('"' + buf.toString("base64") + '"');
      };
      TJSONProtocol.prototype.readMessageBegin = function() {
        this.rstack = [];
        this.rpos = [];
        var transBuf = this.trans.borrow();
        if (transBuf.readIndex >= transBuf.writeIndex) {
          throw new InputBufferUnderrunError();
        }
        var cursor = transBuf.readIndex;
        if (transBuf.buf[cursor] !== 91) {
          throw new Error("Malformed JSON input, no opening bracket");
        }
        cursor++;
        var openBracketCount = 1;
        var inString = false;
        for (; cursor < transBuf.writeIndex; cursor++) {
          var chr = transBuf.buf[cursor];
          if (inString) {
            if (chr === 34) {
              inString = false;
            } else if (chr === 92) {
              cursor += 1;
            }
          } else {
            if (chr === 91) {
              openBracketCount += 1;
            } else if (chr === 93) {
              openBracketCount -= 1;
              if (openBracketCount === 0) {
                break;
              }
            } else if (chr === 34) {
              inString = true;
            }
          }
        }
        if (openBracketCount !== 0) {
          throw new InputBufferUnderrunError();
        }
        this.robj = json_parse(transBuf.buf.slice(transBuf.readIndex, cursor + 1).toString());
        this.trans.consume(cursor + 1 - transBuf.readIndex);
        var version2 = this.robj.shift();
        if (version2 != TJSONProtocol.Version) {
          throw new Error("Wrong thrift protocol version: " + version2);
        }
        var r = {};
        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();
        this.rstack.push(this.robj.shift());
        return r;
      };
      TJSONProtocol.prototype.readMessageEnd = function() {
      };
      TJSONProtocol.prototype.readStructBegin = function() {
        var r = {};
        r.fname = "";
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
          this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }
        return r;
      };
      TJSONProtocol.prototype.readStructEnd = function() {
        this.rstack.pop();
      };
      TJSONProtocol.prototype.readFieldBegin = function() {
        var r = {};
        var fid = -1;
        var ftype = Type.STOP;
        for (var f in this.rstack[this.rstack.length - 1]) {
          if (f === null) {
            continue;
          }
          fid = parseInt(f, 10);
          this.rpos.push(this.rstack.length);
          var field = this.rstack[this.rstack.length - 1][fid];
          delete this.rstack[this.rstack.length - 1][fid];
          this.rstack.push(field);
          break;
        }
        if (fid != -1) {
          for (var i in this.rstack[this.rstack.length - 1]) {
            if (TJSONProtocol.RType[i] === null) {
              continue;
            }
            ftype = TJSONProtocol.RType[i];
            this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][i];
          }
        }
        r.fname = "";
        r.ftype = ftype;
        r.fid = fid;
        return r;
      };
      TJSONProtocol.prototype.readFieldEnd = function() {
        var pos = this.rpos.pop();
        while (this.rstack.length > pos) {
          this.rstack.pop();
        }
      };
      TJSONProtocol.prototype.readMapBegin = function() {
        var map2 = this.rstack.pop();
        var first = map2.shift();
        if (first instanceof Array) {
          this.rstack.push(map2);
          map2 = first;
          first = map2.shift();
        }
        var r = {};
        r.ktype = TJSONProtocol.RType[first];
        r.vtype = TJSONProtocol.RType[map2.shift()];
        r.size = map2.shift();
        this.rpos.push(this.rstack.length);
        this.rstack.push(map2.shift());
        return r;
      };
      TJSONProtocol.prototype.readMapEnd = function() {
        this.readFieldEnd();
      };
      TJSONProtocol.prototype.readListBegin = function() {
        var list = this.rstack[this.rstack.length - 1];
        var r = {};
        r.etype = TJSONProtocol.RType[list.shift()];
        r.size = list.shift();
        this.rpos.push(this.rstack.length);
        this.rstack.push(list.shift());
        return r;
      };
      TJSONProtocol.prototype.readListEnd = function() {
        var pos = this.rpos.pop() - 2;
        var st = this.rstack;
        st.pop();
        if (st instanceof Array && st.length > pos && st[pos].length > 0) {
          st.push(st[pos].shift());
        }
      };
      TJSONProtocol.prototype.readSetBegin = function() {
        return this.readListBegin();
      };
      TJSONProtocol.prototype.readSetEnd = function() {
        return this.readListEnd();
      };
      TJSONProtocol.prototype.readBool = function() {
        return this.readValue() == "1";
      };
      TJSONProtocol.prototype.readByte = function() {
        return this.readI32();
      };
      TJSONProtocol.prototype.readI16 = function() {
        return this.readI32();
      };
      TJSONProtocol.prototype.readI32 = function(f) {
        return +this.readValue();
      };
      TJSONProtocol.prototype.readValue = function(f) {
        if (f === void 0) {
          f = this.rstack[this.rstack.length - 1];
        }
        var r = {};
        if (f instanceof Array) {
          if (f.length === 0) {
            r.value = void 0;
          } else {
            r.value = f.shift();
          }
        } else if (!(f instanceof Int644) && f instanceof Object) {
          for (var i in f) {
            if (i === null) {
              continue;
            }
            this.rstack.push(f[i]);
            delete f[i];
            r.value = i;
            break;
          }
        } else {
          r.value = f;
          this.rstack.pop();
        }
        return r.value;
      };
      TJSONProtocol.prototype.readI64 = function() {
        var n = this.readValue();
        if (typeof n === "string") {
          return Int64Util.fromDecimalString(n);
        } else {
          return new Int644(n);
        }
      };
      TJSONProtocol.prototype.readDouble = function() {
        return this.readI32();
      };
      TJSONProtocol.prototype.readBinary = function() {
        return new Buffer2(this.readValue(), "base64");
      };
      TJSONProtocol.prototype.readString = function() {
        return this.readValue();
      };
      TJSONProtocol.prototype.getTransport = function() {
        return this.trans;
      };
      TJSONProtocol.prototype.skip = function(type) {
        switch (type) {
          case Type.BOOL:
            this.readBool();
            break;
          case Type.BYTE:
            this.readByte();
            break;
          case Type.I16:
            this.readI16();
            break;
          case Type.I32:
            this.readI32();
            break;
          case Type.I64:
            this.readI64();
            break;
          case Type.DOUBLE:
            this.readDouble();
            break;
          case Type.STRING:
            this.readString();
            break;
          case Type.STRUCT:
            this.readStructBegin();
            while (true) {
              var r = this.readFieldBegin();
              if (r.ftype === Type.STOP) {
                break;
              }
              this.skip(r.ftype);
              this.readFieldEnd();
            }
            this.readStructEnd();
            break;
          case Type.MAP:
            var mapBegin = this.readMapBegin();
            for (var i = 0; i < mapBegin.size; ++i) {
              this.skip(mapBegin.ktype);
              this.skip(mapBegin.vtype);
            }
            this.readMapEnd();
            break;
          case Type.SET:
            var setBegin = this.readSetBegin();
            for (var i2 = 0; i2 < setBegin.size; ++i2) {
              this.skip(setBegin.etype);
            }
            this.readSetEnd();
            break;
          case Type.LIST:
            var listBegin = this.readListBegin();
            for (var i3 = 0; i3 < listBegin.size; ++i3) {
              this.skip(listBegin.etype);
            }
            this.readListEnd();
            break;
          default:
            throw new Error("Invalid type: " + type);
        }
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/create_client.js
  var require_create_client = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/create_client.js"(exports, module) {
      init_esbuild_shims();
      module.exports = createClient;
      function createClient(ServiceClient, connection) {
        if (ServiceClient.Client) {
          ServiceClient = ServiceClient.Client;
        }
        var writeCb = function(buf, seqid) {
          connection.write(buf, seqid);
        };
        var transport = new connection.transport(void 0, writeCb);
        var client = new ServiceClient(transport, connection.protocol);
        transport.client = client;
        connection.client = client;
        return client;
      }
    }
  });

  // node_modules/browser-or-node/lib/index.js
  var require_lib = __commonJS({
    "node_modules/browser-or-node/lib/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
      var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
      var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      var isJsDom = function isJsDom2() {
        return typeof window !== "undefined" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
      };
      exports.isBrowser = isBrowser;
      exports.isWebWorker = isWebWorker;
      exports.isNode = isNode;
      exports.isJsDom = isJsDom;
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/ws_connection.js
  var require_ws_connection = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/ws_connection.js"(exports) {
      init_esbuild_shims();
      var util = require_util();
      var WebSocket2 = require_browser();
      var EventEmitter = require_events().EventEmitter;
      var thrift2 = require_thrift();
      var TBufferedTransport = require_buffered_transport();
      var TJSONProtocol = require_json_protocol();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      var createClient = require_create_client();
      var jsEnv = require_lib();
      exports.WSConnection = WSConnection;
      function WSConnection(host, port, options) {
        EventEmitter.call(this);
        this.options = options || {};
        this.host = host;
        this.port = port;
        this.secure = this.options.secure || false;
        this.transport = this.options.transport || TBufferedTransport;
        this.protocol = this.options.protocol || TJSONProtocol;
        this.path = this.options.path;
        this.send_pending = [];
        this.seqId2Service = {};
        this.wsOptions = {
          host: this.host,
          port: this.port || 80,
          path: this.options.path || "/",
          headers: this.options.headers || {}
        };
        for (var attrname in this.options.wsOptions) {
          this.wsOptions[attrname] = this.options.wsOptions[attrname];
        }
      }
      util.inherits(WSConnection, EventEmitter);
      WSConnection.prototype.__reset = function() {
        this.socket = null;
        this.send_pending = [];
      };
      WSConnection.prototype.__onOpen = function() {
        this.emit("open");
        if (this.send_pending.length > 0) {
          this.send_pending.forEach(function(data) {
            this.socket.send(data);
          }, this);
          this.send_pending = [];
        }
      };
      WSConnection.prototype.__onClose = function(evt) {
        this.emit("close");
        this.__reset();
      };
      WSConnection.prototype.__decodeCallback = function(transport_with_data) {
        var proto = new this.protocol(transport_with_data);
        try {
          while (true) {
            var header = proto.readMessageBegin();
            var dummy_seqid = header.rseqid * -1;
            var client = this.client;
            var service_name = this.seqId2Service[header.rseqid];
            if (service_name) {
              client = this.client[service_name];
              delete this.seqId2Service[header.rseqid];
            }
            client._reqs[dummy_seqid] = function(err, success) {
              transport_with_data.commitPosition();
              var clientCallback = client._reqs[header.rseqid];
              delete client._reqs[header.rseqid];
              if (clientCallback) {
                clientCallback(err, success);
              }
            };
            if (client["recv_" + header.fname]) {
              client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
            } else {
              delete client._reqs[dummy_seqid];
              this.emit(
                "error",
                new thrift2.TApplicationException(
                  thrift2.TApplicationExceptionType.WRONG_METHOD_NAME,
                  "Received a response to an unknown RPC function"
                )
              );
            }
          }
        } catch (e2) {
          if (e2 instanceof InputBufferUnderrunError) {
            transport_with_data.rollbackPosition();
          } else {
            throw e2;
          }
        }
      };
      WSConnection.prototype.__onData = function(data) {
        if (Object.prototype.toString.call(data) === "[object ArrayBuffer]") {
          data = new Uint8Array(data);
        }
        var buf = new Buffer2(data);
        this.transport.receiver(this.__decodeCallback.bind(this))(buf);
      };
      WSConnection.prototype.__onMessage = function(evt) {
        this.__onData(evt.data);
      };
      WSConnection.prototype.__onError = function(evt) {
        this.emit("error", evt);
        this.socket.close();
      };
      WSConnection.prototype.isOpen = function() {
        return this.socket && this.socket.readyState === this.socket.OPEN;
      };
      WSConnection.prototype.open = function() {
        if (this.socket && this.socket.readyState !== this.socket.CLOSED) {
          return;
        }
        if (jsEnv.isBrowser) {
          this.socket = new WebSocket2(this.uri());
        } else {
          this.socket = new WebSocket2(this.uri(), "", this.wsOptions);
        }
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = this.__onOpen.bind(this);
        this.socket.onmessage = this.__onMessage.bind(this);
        this.socket.onerror = this.__onError.bind(this);
        this.socket.onclose = this.__onClose.bind(this);
      };
      WSConnection.prototype.close = function() {
        this.socket.close();
      };
      WSConnection.prototype.uri = function() {
        var schema = this.secure ? "wss" : "ws";
        var port = "";
        var path = this.path || "/";
        var host = this.host;
        if (this.port && ("wss" === schema && this.port !== 443 || "ws" === schema && this.port !== 80)) {
          port = ":" + this.port;
        }
        return schema + "://" + host + port + path;
      };
      WSConnection.prototype.write = function(data) {
        if (this.isOpen()) {
          this.socket.send(data);
        } else {
          this.send_pending.push(data);
        }
      };
      exports.createWSConnection = function(host, port, options) {
        return new WSConnection(host, port, options);
      };
      exports.createWSClient = createClient;
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/xhr_connection.js
  var require_xhr_connection = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/xhr_connection.js"(exports) {
      init_esbuild_shims();
      var util = require_util();
      var EventEmitter = require_events().EventEmitter;
      var thrift2 = require_thrift();
      var TBufferedTransport = require_buffered_transport();
      var TJSONProtocol = require_json_protocol();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      var createClient = require_create_client();
      exports.XHRConnection = XHRConnection;
      function XHRConnection(host, port, options) {
        this.options = options || {};
        this.wpos = 0;
        this.rpos = 0;
        this.useCORS = options && options.useCORS;
        this.send_buf = "";
        this.recv_buf = "";
        this.transport = options.transport || TBufferedTransport;
        this.protocol = options.protocol || TJSONProtocol;
        this.headers = options.headers || {};
        host = host || window.location.host;
        port = port || window.location.port;
        var prefix = options.https ? "https://" : "http://";
        var path = options.path || "/";
        if (port === "") {
          port = void 0;
        }
        if (!port || port === 80 || port === "80") {
          this.url = prefix + host + path;
        } else {
          this.url = prefix + host + ":" + port + path;
        }
        this.seqId2Service = {};
      }
      util.inherits(XHRConnection, EventEmitter);
      XHRConnection.prototype.getXmlHttpRequestObject = function() {
        try {
          return new XMLHttpRequest();
        } catch (e1) {
        }
        try {
          return new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e2) {
        }
        try {
          return new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e3) {
        }
        throw "Your browser doesn't support XHR.";
      };
      XHRConnection.prototype.flush = function() {
        var self2 = this;
        if (this.url === void 0 || this.url === "") {
          return this.send_buf;
        }
        var xreq = this.getXmlHttpRequestObject();
        if (xreq.overrideMimeType) {
          xreq.overrideMimeType("application/json");
        }
        xreq.onreadystatechange = function() {
          if (this.readyState == 4 && this.status == 200) {
            self2.setRecvBuffer(this.responseText);
          }
        };
        xreq.open("POST", this.url, true);
        Object.keys(this.headers).forEach(function(headerKey) {
          xreq.setRequestHeader(headerKey, self2.headers[headerKey]);
        });
        xreq.send(this.send_buf);
      };
      XHRConnection.prototype.setRecvBuffer = function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
        if (Object.prototype.toString.call(buf) == "[object ArrayBuffer]") {
          var data = new Uint8Array(buf);
        }
        var thing = new Buffer2(data || buf);
        this.transport.receiver(this.__decodeCallback.bind(this))(thing);
      };
      XHRConnection.prototype.__decodeCallback = function(transport_with_data) {
        var proto = new this.protocol(transport_with_data);
        try {
          while (true) {
            var header = proto.readMessageBegin();
            var dummy_seqid = header.rseqid * -1;
            var client = this.client;
            var service_name = this.seqId2Service[header.rseqid];
            if (service_name) {
              client = this.client[service_name];
              delete this.seqId2Service[header.rseqid];
            }
            client._reqs[dummy_seqid] = function(err, success) {
              transport_with_data.commitPosition();
              var clientCallback = client._reqs[header.rseqid];
              delete client._reqs[header.rseqid];
              if (clientCallback) {
                clientCallback(err, success);
              }
            };
            if (client["recv_" + header.fname]) {
              client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
            } else {
              delete client._reqs[dummy_seqid];
              this.emit(
                "error",
                new thrift2.TApplicationException(
                  thrift2.TApplicationExceptionType.WRONG_METHOD_NAME,
                  "Received a response to an unknown RPC function"
                )
              );
            }
          }
        } catch (e2) {
          if (e2 instanceof InputBufferUnderrunError) {
            transport_with_data.rollbackPosition();
          } else {
            throw e2;
          }
        }
      };
      XHRConnection.prototype.isOpen = function() {
        return true;
      };
      XHRConnection.prototype.open = function() {
      };
      XHRConnection.prototype.close = function() {
      };
      XHRConnection.prototype.read = function(len) {
        var avail = this.wpos - this.rpos;
        if (avail === 0) {
          return "";
        }
        var give = len;
        if (avail < len) {
          give = avail;
        }
        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;
        return ret;
      };
      XHRConnection.prototype.readAll = function() {
        return this.recv_buf;
      };
      XHRConnection.prototype.write = function(buf) {
        this.send_buf = buf;
        this.flush();
      };
      XHRConnection.prototype.getSendBuffer = function() {
        return this.send_buf;
      };
      exports.createXHRConnection = function(host, port, options) {
        return new XHRConnection(host, port, options);
      };
      exports.createXHRClient = createClient;
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/ohos_connection.js
  var require_ohos_connection = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/ohos_connection.js"(exports) {
      init_esbuild_shims();
      var util = require_util();
      var EventEmitter = require_events().EventEmitter;
      var thrift2 = require_thrift();
      var TBufferedTransport = require_buffered_transport();
      var TBinaryProtocol = require_binary_protocol();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      var createClient = require_create_client();
      var OhosConnection = exports.OhosConnection = function(options) {
        EventEmitter.call(this);
        var self2 = this;
        this.options = options || {};
        this.host = this.options.host;
        this.port = this.options.port;
        this.path = this.options.path || "/";
        this.url = this.port === 80 ? this.host.replace(/\/$/, "") + this.path : this.host.replace(/\/$/, "") + ":" + this.port + this.path;
        this.transport = this.options.transport || TBufferedTransport;
        this.protocol = this.options.protocol || TBinaryProtocol;
        this.createHttp = this.options.createHttp;
        this.requestOptions = {
          method: "POST",
          header: this.options.header || {},
          readTimeout: this.options.readTimeout || 6e4,
          connectTimeout: this.options.connectTimeout || 6e4
        };
        for (var attrname in this.options.requestOptions) {
          this.requestOptions[attrname] = this.options.requestOptions[attrname];
        }
        if (!this.requestOptions.header["Connection"]) {
          this.requestOptions.header["Connection"] = "keep-alive";
        }
        this.seqId2Service = {};
        function decodeCallback(transport_with_data) {
          var proto = new self2.protocol(transport_with_data);
          try {
            while (true) {
              var header = proto.readMessageBegin();
              var dummy_seqid = header.rseqid * -1;
              var client = self2.client;
              var service_name = self2.seqId2Service[header.rseqid];
              if (service_name) {
                client = self2.client[service_name];
                delete self2.seqId2Service[header.rseqid];
              }
              client._reqs[dummy_seqid] = function(err, success) {
                transport_with_data.commitPosition();
                var clientCallback = client._reqs[header.rseqid];
                delete client._reqs[header.rseqid];
                if (clientCallback) {
                  process.nextTick(function() {
                    clientCallback(err, success);
                  });
                }
              };
              if (client["recv_" + header.fname]) {
                client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
              } else {
                delete client._reqs[dummy_seqid];
                self2.emit(
                  "error",
                  new thrift2.TApplicationException(
                    thrift2.TApplicationExceptionType.WRONG_METHOD_NAME,
                    "Received a response to an unknown RPC function"
                  )
                );
              }
            }
          } catch (e2) {
            if (e2 instanceof InputBufferUnderrunError) {
              transport_with_data.rollbackPosition();
            } else {
              self2.emit("error", e2);
            }
          }
        }
        this.responseCallback = function(error, response) {
          var data = [];
          var dataLen = 0;
          if (error) {
            self2.emit("error", error);
            return;
          }
          if (!response || response.responseCode !== 200) {
            self2.emit("error", new THTTPException(response));
          }
          if (typeof response.result == "string" || Object.prototype.toString.call(response.result) == "[object Uint8Array]") {
            data.push(Buffer2.from(response.result));
          }
          dataLen += response.result.length;
          var buf = Buffer2.alloc(dataLen);
          for (var i = 0, len = data.length, pos = 0; i < len; i++) {
            data[i].copy(buf, pos);
            pos += data[i].length;
          }
          self2.transport.receiver(decodeCallback)(buf);
        };
        this.write = function(data) {
          var http = self2.createHttp();
          var opts = self2.requestOptions;
          opts.header["Content-length"] = data.length;
          if (!opts.header["Content-Type"])
            opts.header["Content-Type"] = "application/x-thrift";
          opts.extraData = data.toString();
          http.request(self2.url, opts, self2.responseCallback);
        };
      };
      util.inherits(OhosConnection, EventEmitter);
      exports.createOhosConnection = function(createHttp, host, port, options) {
        options.createHttp = createHttp;
        options.host = host;
        options.port = port || 80;
        return new OhosConnection(options);
      };
      exports.createOhosClient = createClient;
      function THTTPException(response) {
        thrift2.TApplicationException.call(this);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = this.constructor.name;
        this.responseCode = response.responseCode;
        this.response = response;
        this.type = thrift2.TApplicationExceptionType.PROTOCOL_ERROR;
        this.message = "Received a response with a bad HTTP status code: " + response.responseCode;
      }
      util.inherits(THTTPException, thrift2.TApplicationException);
    }
  });

  // node_modules/q/q.js
  var require_q = __commonJS({
    "node_modules/q/q.js"(exports, module) {
      init_esbuild_shims();
      (function(definition) {
        "use strict";
        if (typeof bootstrap === "function") {
          bootstrap("promise", definition);
        } else if (typeof exports === "object" && typeof module === "object") {
          module.exports = definition();
        } else if (typeof define === "function" && define.amd) {
          define(definition);
        } else if (typeof ses !== "undefined") {
          if (!ses.ok()) {
            return;
          } else {
            ses.makeQ = definition;
          }
        } else if (typeof window !== "undefined" || typeof self !== "undefined") {
          var global2 = typeof window !== "undefined" ? window : self;
          var previousQ = global2.Q;
          global2.Q = definition();
          global2.Q.noConflict = function() {
            global2.Q = previousQ;
            return this;
          };
        } else {
          throw new Error("This environment was not anticipated by Q. Please file a bug.");
        }
      })(function() {
        "use strict";
        var hasStacks = false;
        try {
          throw new Error();
        } catch (e2) {
          hasStacks = !!e2.stack;
        }
        var qStartingLine = captureLine();
        var qFileName;
        var noop = function() {
        };
        var nextTick = function() {
          var head = { task: void 0, next: null };
          var tail = head;
          var flushing = false;
          var requestTick = void 0;
          var isNodeJS = false;
          var laterQueue = [];
          function flush() {
            var task, domain;
            while (head.next) {
              head = head.next;
              task = head.task;
              head.task = void 0;
              domain = head.domain;
              if (domain) {
                head.domain = void 0;
                domain.enter();
              }
              runSingle(task, domain);
            }
            while (laterQueue.length) {
              task = laterQueue.pop();
              runSingle(task);
            }
            flushing = false;
          }
          function runSingle(task, domain) {
            try {
              task();
            } catch (e2) {
              if (isNodeJS) {
                if (domain) {
                  domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                  domain.enter();
                }
                throw e2;
              } else {
                setTimeout(function() {
                  throw e2;
                }, 0);
              }
            }
            if (domain) {
              domain.exit();
            }
          }
          nextTick = function(task) {
            tail = tail.next = {
              task,
              domain: isNodeJS && process.domain,
              next: null
            };
            if (!flushing) {
              flushing = true;
              requestTick();
            }
          };
          if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
            isNodeJS = true;
            requestTick = function() {
              process.nextTick(flush);
            };
          } else if (typeof setImmediate === "function") {
            if (typeof window !== "undefined") {
              requestTick = setImmediate.bind(window, flush);
            } else {
              requestTick = function() {
                setImmediate(flush);
              };
            }
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            channel.port1.onmessage = function() {
              requestTick = requestPortTick;
              channel.port1.onmessage = flush;
              flush();
            };
            var requestPortTick = function() {
              channel.port2.postMessage(0);
            };
            requestTick = function() {
              setTimeout(flush, 0);
              requestPortTick();
            };
          } else {
            requestTick = function() {
              setTimeout(flush, 0);
            };
          }
          nextTick.runAfter = function(task) {
            laterQueue.push(task);
            if (!flushing) {
              flushing = true;
              requestTick();
            }
          };
          return nextTick;
        }();
        var call = Function.call;
        function uncurryThis(f) {
          return function() {
            return call.apply(f, arguments);
          };
        }
        var array_slice = uncurryThis(Array.prototype.slice);
        var array_reduce = uncurryThis(
          Array.prototype.reduce || function(callback, basis) {
            var index = 0, length = this.length;
            if (arguments.length === 1) {
              do {
                if (index in this) {
                  basis = this[index++];
                  break;
                }
                if (++index >= length) {
                  throw new TypeError();
                }
              } while (1);
            }
            for (; index < length; index++) {
              if (index in this) {
                basis = callback(basis, this[index], index);
              }
            }
            return basis;
          }
        );
        var array_indexOf = uncurryThis(
          Array.prototype.indexOf || function(value) {
            for (var i = 0; i < this.length; i++) {
              if (this[i] === value) {
                return i;
              }
            }
            return -1;
          }
        );
        var array_map = uncurryThis(
          Array.prototype.map || function(callback, thisp) {
            var self2 = this;
            var collect = [];
            array_reduce(self2, function(undefined2, value, index) {
              collect.push(callback.call(thisp, value, index, self2));
            }, void 0);
            return collect;
          }
        );
        var object_create = Object.create || function(prototype) {
          function Type() {
          }
          Type.prototype = prototype;
          return new Type();
        };
        var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
          obj[prop] = descriptor.value;
          return obj;
        };
        var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
        var object_keys = Object.keys || function(object) {
          var keys = [];
          for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        var object_toString = uncurryThis(Object.prototype.toString);
        function isObject(value) {
          return value === Object(value);
        }
        function isStopIteration(exception) {
          return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
        }
        var QReturnValue;
        if (typeof ReturnValue !== "undefined") {
          QReturnValue = ReturnValue;
        } else {
          QReturnValue = function(value) {
            this.value = value;
          };
        }
        var STACK_JUMP_SEPARATOR = "From previous event:";
        function makeStackTraceLong(error, promise2) {
          if (hasStacks && promise2.stack && typeof error === "object" && error !== null && error.stack) {
            var stacks = [];
            for (var p = promise2; !!p; p = p.source) {
              if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
                stacks.unshift(p.stack);
              }
            }
            stacks.unshift(error.stack);
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            var stack = filterStackString(concatedStacks);
            object_defineProperty(error, "stack", { value: stack, configurable: true });
          }
        }
        function filterStackString(stackString) {
          var lines = stackString.split("\n");
          var desiredLines = [];
          for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
              desiredLines.push(line);
            }
          }
          return desiredLines.join("\n");
        }
        function isNodeFrame(stackLine) {
          return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
        }
        function getFileNameAndLineNumber(stackLine) {
          var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
          if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
          }
          var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
          if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
          }
          var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
          if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
          }
        }
        function isInternalFrame(stackLine) {
          var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
          if (!fileNameAndLineNumber) {
            return false;
          }
          var fileName = fileNameAndLineNumber[0];
          var lineNumber = fileNameAndLineNumber[1];
          return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
        }
        function captureLine() {
          if (!hasStacks) {
            return;
          }
          try {
            throw new Error();
          } catch (e2) {
            var lines = e2.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
              return;
            }
            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
          }
        }
        function deprecate(callback, name, alternative) {
          return function() {
            if (typeof console !== "undefined" && typeof console.warn === "function") {
              console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
          };
        }
        function Q(value) {
          if (value instanceof Promise2) {
            return value;
          }
          if (isPromiseAlike(value)) {
            return coerce(value);
          } else {
            return fulfill(value);
          }
        }
        Q.resolve = Q;
        Q.nextTick = nextTick;
        Q.longStackSupport = false;
        var longStackCounter = 1;
        if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
          Q.longStackSupport = true;
        }
        Q.defer = defer;
        function defer() {
          var messages = [], progressListeners = [], resolvedPromise;
          var deferred = object_create(defer.prototype);
          var promise2 = object_create(Promise2.prototype);
          promise2.promiseDispatch = function(resolve2, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
              messages.push(args);
              if (op === "when" && operands[1]) {
                progressListeners.push(operands[1]);
              }
            } else {
              Q.nextTick(function() {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
              });
            }
          };
          promise2.valueOf = function() {
            if (messages) {
              return promise2;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
              resolvedPromise = nearerValue;
            }
            return nearerValue;
          };
          promise2.inspect = function() {
            if (!resolvedPromise) {
              return { state: "pending" };
            }
            return resolvedPromise.inspect();
          };
          if (Q.longStackSupport && hasStacks) {
            try {
              throw new Error();
            } catch (e2) {
              promise2.stack = e2.stack.substring(e2.stack.indexOf("\n") + 1);
              promise2.stackCounter = longStackCounter++;
            }
          }
          function become(newPromise) {
            resolvedPromise = newPromise;
            if (Q.longStackSupport && hasStacks) {
              promise2.source = newPromise;
            }
            array_reduce(messages, function(undefined2, message) {
              Q.nextTick(function() {
                newPromise.promiseDispatch.apply(newPromise, message);
              });
            }, void 0);
            messages = void 0;
            progressListeners = void 0;
          }
          deferred.promise = promise2;
          deferred.resolve = function(value) {
            if (resolvedPromise) {
              return;
            }
            become(Q(value));
          };
          deferred.fulfill = function(value) {
            if (resolvedPromise) {
              return;
            }
            become(fulfill(value));
          };
          deferred.reject = function(reason) {
            if (resolvedPromise) {
              return;
            }
            become(reject(reason));
          };
          deferred.notify = function(progress2) {
            if (resolvedPromise) {
              return;
            }
            array_reduce(progressListeners, function(undefined2, progressListener) {
              Q.nextTick(function() {
                progressListener(progress2);
              });
            }, void 0);
          };
          return deferred;
        }
        defer.prototype.makeNodeResolver = function() {
          var self2 = this;
          return function(error, value) {
            if (error) {
              self2.reject(error);
            } else if (arguments.length > 2) {
              self2.resolve(array_slice(arguments, 1));
            } else {
              self2.resolve(value);
            }
          };
        };
        Q.Promise = promise;
        Q.promise = promise;
        function promise(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
          }
          var deferred = defer();
          try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
          } catch (reason) {
            deferred.reject(reason);
          }
          return deferred.promise;
        }
        promise.race = race;
        promise.all = all;
        promise.reject = reject;
        promise.resolve = Q;
        Q.passByCopy = function(object) {
          return object;
        };
        Promise2.prototype.passByCopy = function() {
          return this;
        };
        Q.join = function(x, y) {
          return Q(x).join(y);
        };
        Promise2.prototype.join = function(that) {
          return Q([this, that]).spread(function(x, y) {
            if (x === y) {
              return x;
            } else {
              throw new Error("Q can't join: not the same: " + x + " " + y);
            }
          });
        };
        Q.race = race;
        function race(answerPs) {
          return promise(function(resolve2, reject2) {
            for (var i = 0, len = answerPs.length; i < len; i++) {
              Q(answerPs[i]).then(resolve2, reject2);
            }
          });
        }
        Promise2.prototype.race = function() {
          return this.then(Q.race);
        };
        Q.makePromise = Promise2;
        function Promise2(descriptor, fallback, inspect) {
          if (fallback === void 0) {
            fallback = function(op) {
              return reject(new Error(
                "Promise does not support operation: " + op
              ));
            };
          }
          if (inspect === void 0) {
            inspect = function() {
              return { state: "unknown" };
            };
          }
          var promise2 = object_create(Promise2.prototype);
          promise2.promiseDispatch = function(resolve2, op, args) {
            var result;
            try {
              if (descriptor[op]) {
                result = descriptor[op].apply(promise2, args);
              } else {
                result = fallback.call(promise2, op, args);
              }
            } catch (exception) {
              result = reject(exception);
            }
            if (resolve2) {
              resolve2(result);
            }
          };
          promise2.inspect = inspect;
          if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
              promise2.exception = inspected.reason;
            }
            promise2.valueOf = function() {
              var inspected2 = inspect();
              if (inspected2.state === "pending" || inspected2.state === "rejected") {
                return promise2;
              }
              return inspected2.value;
            };
          }
          return promise2;
        }
        Promise2.prototype.toString = function() {
          return "[object Promise]";
        };
        Promise2.prototype.then = function(fulfilled, rejected, progressed) {
          var self2 = this;
          var deferred = defer();
          var done = false;
          function _fulfilled(value) {
            try {
              return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
              return reject(exception);
            }
          }
          function _rejected(exception) {
            if (typeof rejected === "function") {
              makeStackTraceLong(exception, self2);
              try {
                return rejected(exception);
              } catch (newException) {
                return reject(newException);
              }
            }
            return reject(exception);
          }
          function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
          }
          Q.nextTick(function() {
            self2.promiseDispatch(function(value) {
              if (done) {
                return;
              }
              done = true;
              deferred.resolve(_fulfilled(value));
            }, "when", [function(exception) {
              if (done) {
                return;
              }
              done = true;
              deferred.resolve(_rejected(exception));
            }]);
          });
          self2.promiseDispatch(void 0, "when", [void 0, function(value) {
            var newValue;
            var threw = false;
            try {
              newValue = _progressed(value);
            } catch (e2) {
              threw = true;
              if (Q.onerror) {
                Q.onerror(e2);
              } else {
                throw e2;
              }
            }
            if (!threw) {
              deferred.notify(newValue);
            }
          }]);
          return deferred.promise;
        };
        Q.tap = function(promise2, callback) {
          return Q(promise2).tap(callback);
        };
        Promise2.prototype.tap = function(callback) {
          callback = Q(callback);
          return this.then(function(value) {
            return callback.fcall(value).thenResolve(value);
          });
        };
        Q.when = when;
        function when(value, fulfilled, rejected, progressed) {
          return Q(value).then(fulfilled, rejected, progressed);
        }
        Promise2.prototype.thenResolve = function(value) {
          return this.then(function() {
            return value;
          });
        };
        Q.thenResolve = function(promise2, value) {
          return Q(promise2).thenResolve(value);
        };
        Promise2.prototype.thenReject = function(reason) {
          return this.then(function() {
            throw reason;
          });
        };
        Q.thenReject = function(promise2, reason) {
          return Q(promise2).thenReject(reason);
        };
        Q.nearer = nearer;
        function nearer(value) {
          if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
              return inspected.value;
            }
          }
          return value;
        }
        Q.isPromise = isPromise;
        function isPromise(object) {
          return object instanceof Promise2;
        }
        Q.isPromiseAlike = isPromiseAlike;
        function isPromiseAlike(object) {
          return isObject(object) && typeof object.then === "function";
        }
        Q.isPending = isPending;
        function isPending(object) {
          return isPromise(object) && object.inspect().state === "pending";
        }
        Promise2.prototype.isPending = function() {
          return this.inspect().state === "pending";
        };
        Q.isFulfilled = isFulfilled;
        function isFulfilled(object) {
          return !isPromise(object) || object.inspect().state === "fulfilled";
        }
        Promise2.prototype.isFulfilled = function() {
          return this.inspect().state === "fulfilled";
        };
        Q.isRejected = isRejected;
        function isRejected(object) {
          return isPromise(object) && object.inspect().state === "rejected";
        }
        Promise2.prototype.isRejected = function() {
          return this.inspect().state === "rejected";
        };
        var unhandledReasons = [];
        var unhandledRejections = [];
        var reportedUnhandledRejections = [];
        var trackUnhandledRejections = true;
        function resetUnhandledRejections() {
          unhandledReasons.length = 0;
          unhandledRejections.length = 0;
          if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
          }
        }
        function trackRejection(promise2, reason) {
          if (!trackUnhandledRejections) {
            return;
          }
          if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function() {
              if (array_indexOf(unhandledRejections, promise2) !== -1) {
                process.emit("unhandledRejection", reason, promise2);
                reportedUnhandledRejections.push(promise2);
              }
            });
          }
          unhandledRejections.push(promise2);
          if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
          } else {
            unhandledReasons.push("(no stack) " + reason);
          }
        }
        function untrackRejection(promise2) {
          if (!trackUnhandledRejections) {
            return;
          }
          var at = array_indexOf(unhandledRejections, promise2);
          if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
              Q.nextTick.runAfter(function() {
                var atReport = array_indexOf(reportedUnhandledRejections, promise2);
                if (atReport !== -1) {
                  process.emit("rejectionHandled", unhandledReasons[at], promise2);
                  reportedUnhandledRejections.splice(atReport, 1);
                }
              });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
          }
        }
        Q.resetUnhandledRejections = resetUnhandledRejections;
        Q.getUnhandledReasons = function() {
          return unhandledReasons.slice();
        };
        Q.stopUnhandledRejectionTracking = function() {
          resetUnhandledRejections();
          trackUnhandledRejections = false;
        };
        resetUnhandledRejections();
        Q.reject = reject;
        function reject(reason) {
          var rejection = Promise2({
            "when": function(rejected) {
              if (rejected) {
                untrackRejection(this);
              }
              return rejected ? rejected(reason) : this;
            }
          }, function fallback() {
            return this;
          }, function inspect() {
            return { state: "rejected", reason };
          });
          trackRejection(rejection, reason);
          return rejection;
        }
        Q.fulfill = fulfill;
        function fulfill(value) {
          return Promise2({
            "when": function() {
              return value;
            },
            "get": function(name) {
              return value[name];
            },
            "set": function(name, rhs) {
              value[name] = rhs;
            },
            "delete": function(name) {
              delete value[name];
            },
            "post": function(name, args) {
              if (name === null || name === void 0) {
                return value.apply(void 0, args);
              } else {
                return value[name].apply(value, args);
              }
            },
            "apply": function(thisp, args) {
              return value.apply(thisp, args);
            },
            "keys": function() {
              return object_keys(value);
            }
          }, void 0, function inspect() {
            return { state: "fulfilled", value };
          });
        }
        function coerce(promise2) {
          var deferred = defer();
          Q.nextTick(function() {
            try {
              promise2.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
              deferred.reject(exception);
            }
          });
          return deferred.promise;
        }
        Q.master = master;
        function master(object) {
          return Promise2({
            "isDef": function() {
            }
          }, function fallback(op, args) {
            return dispatch(object, op, args);
          }, function() {
            return Q(object).inspect();
          });
        }
        Q.spread = spread;
        function spread(value, fulfilled, rejected) {
          return Q(value).spread(fulfilled, rejected);
        }
        Promise2.prototype.spread = function(fulfilled, rejected) {
          return this.all().then(function(array) {
            return fulfilled.apply(void 0, array);
          }, rejected);
        };
        Q.async = async;
        function async(makeGenerator) {
          return function() {
            function continuer(verb, arg) {
              var result;
              if (typeof StopIteration === "undefined") {
                try {
                  result = generator[verb](arg);
                } catch (exception) {
                  return reject(exception);
                }
                if (result.done) {
                  return Q(result.value);
                } else {
                  return when(result.value, callback, errback);
                }
              } else {
                try {
                  result = generator[verb](arg);
                } catch (exception) {
                  if (isStopIteration(exception)) {
                    return Q(exception.value);
                  } else {
                    return reject(exception);
                  }
                }
                return when(result, callback, errback);
              }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
          };
        }
        Q.spawn = spawn;
        function spawn(makeGenerator) {
          Q.done(Q.async(makeGenerator)());
        }
        Q["return"] = _return;
        function _return(value) {
          throw new QReturnValue(value);
        }
        Q.promised = promised;
        function promised(callback) {
          return function() {
            return spread([this, all(arguments)], function(self2, args) {
              return callback.apply(self2, args);
            });
          };
        }
        Q.dispatch = dispatch;
        function dispatch(object, op, args) {
          return Q(object).dispatch(op, args);
        }
        Promise2.prototype.dispatch = function(op, args) {
          var self2 = this;
          var deferred = defer();
          Q.nextTick(function() {
            self2.promiseDispatch(deferred.resolve, op, args);
          });
          return deferred.promise;
        };
        Q.get = function(object, key) {
          return Q(object).dispatch("get", [key]);
        };
        Promise2.prototype.get = function(key) {
          return this.dispatch("get", [key]);
        };
        Q.set = function(object, key, value) {
          return Q(object).dispatch("set", [key, value]);
        };
        Promise2.prototype.set = function(key, value) {
          return this.dispatch("set", [key, value]);
        };
        Q.del = // XXX legacy
        Q["delete"] = function(object, key) {
          return Q(object).dispatch("delete", [key]);
        };
        Promise2.prototype.del = // XXX legacy
        Promise2.prototype["delete"] = function(key) {
          return this.dispatch("delete", [key]);
        };
        Q.mapply = // XXX As proposed by "Redsandro"
        Q.post = function(object, name, args) {
          return Q(object).dispatch("post", [name, args]);
        };
        Promise2.prototype.mapply = // XXX As proposed by "Redsandro"
        Promise2.prototype.post = function(name, args) {
          return this.dispatch("post", [name, args]);
        };
        Q.send = // XXX Mark Miller's proposed parlance
        Q.mcall = // XXX As proposed by "Redsandro"
        Q.invoke = function(object, name) {
          return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
        };
        Promise2.prototype.send = // XXX Mark Miller's proposed parlance
        Promise2.prototype.mcall = // XXX As proposed by "Redsandro"
        Promise2.prototype.invoke = function(name) {
          return this.dispatch("post", [name, array_slice(arguments, 1)]);
        };
        Q.fapply = function(object, args) {
          return Q(object).dispatch("apply", [void 0, args]);
        };
        Promise2.prototype.fapply = function(args) {
          return this.dispatch("apply", [void 0, args]);
        };
        Q["try"] = Q.fcall = function(object) {
          return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
        };
        Promise2.prototype.fcall = function() {
          return this.dispatch("apply", [void 0, array_slice(arguments)]);
        };
        Q.fbind = function(object) {
          var promise2 = Q(object);
          var args = array_slice(arguments, 1);
          return function fbound() {
            return promise2.dispatch("apply", [
              this,
              args.concat(array_slice(arguments))
            ]);
          };
        };
        Promise2.prototype.fbind = function() {
          var promise2 = this;
          var args = array_slice(arguments);
          return function fbound() {
            return promise2.dispatch("apply", [
              this,
              args.concat(array_slice(arguments))
            ]);
          };
        };
        Q.keys = function(object) {
          return Q(object).dispatch("keys", []);
        };
        Promise2.prototype.keys = function() {
          return this.dispatch("keys", []);
        };
        Q.all = all;
        function all(promises) {
          return when(promises, function(promises2) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises2, function(undefined2, promise2, index) {
              var snapshot;
              if (isPromise(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
                promises2[index] = snapshot.value;
              } else {
                ++pendingCount;
                when(
                  promise2,
                  function(value) {
                    promises2[index] = value;
                    if (--pendingCount === 0) {
                      deferred.resolve(promises2);
                    }
                  },
                  deferred.reject,
                  function(progress2) {
                    deferred.notify({ index, value: progress2 });
                  }
                );
              }
            }, void 0);
            if (pendingCount === 0) {
              deferred.resolve(promises2);
            }
            return deferred.promise;
          });
        }
        Promise2.prototype.all = function() {
          return all(this);
        };
        Q.any = any;
        function any(promises) {
          if (promises.length === 0) {
            return Q.resolve();
          }
          var deferred = Q.defer();
          var pendingCount = 0;
          array_reduce(promises, function(prev, current, index) {
            var promise2 = promises[index];
            pendingCount++;
            when(promise2, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
              deferred.resolve(result);
            }
            function onRejected(err) {
              pendingCount--;
              if (pendingCount === 0) {
                var rejection = err || new Error("" + err);
                rejection.message = "Q can't get fulfillment value from any promise, all promises were rejected. Last error message: " + rejection.message;
                deferred.reject(rejection);
              }
            }
            function onProgress(progress2) {
              deferred.notify({
                index,
                value: progress2
              });
            }
          }, void 0);
          return deferred.promise;
        }
        Promise2.prototype.any = function() {
          return any(this);
        };
        Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
        function allResolved(promises) {
          return when(promises, function(promises2) {
            promises2 = array_map(promises2, Q);
            return when(all(array_map(promises2, function(promise2) {
              return when(promise2, noop, noop);
            })), function() {
              return promises2;
            });
          });
        }
        Promise2.prototype.allResolved = function() {
          return allResolved(this);
        };
        Q.allSettled = allSettled;
        function allSettled(promises) {
          return Q(promises).allSettled();
        }
        Promise2.prototype.allSettled = function() {
          return this.then(function(promises) {
            return all(array_map(promises, function(promise2) {
              promise2 = Q(promise2);
              function regardless() {
                return promise2.inspect();
              }
              return promise2.then(regardless, regardless);
            }));
          });
        };
        Q.fail = // XXX legacy
        Q["catch"] = function(object, rejected) {
          return Q(object).then(void 0, rejected);
        };
        Promise2.prototype.fail = // XXX legacy
        Promise2.prototype["catch"] = function(rejected) {
          return this.then(void 0, rejected);
        };
        Q.progress = progress;
        function progress(object, progressed) {
          return Q(object).then(void 0, void 0, progressed);
        }
        Promise2.prototype.progress = function(progressed) {
          return this.then(void 0, void 0, progressed);
        };
        Q.fin = // XXX legacy
        Q["finally"] = function(object, callback) {
          return Q(object)["finally"](callback);
        };
        Promise2.prototype.fin = // XXX legacy
        Promise2.prototype["finally"] = function(callback) {
          if (!callback || typeof callback.apply !== "function") {
            throw new Error("Q can't apply finally callback");
          }
          callback = Q(callback);
          return this.then(function(value) {
            return callback.fcall().then(function() {
              return value;
            });
          }, function(reason) {
            return callback.fcall().then(function() {
              throw reason;
            });
          });
        };
        Q.done = function(object, fulfilled, rejected, progress2) {
          return Q(object).done(fulfilled, rejected, progress2);
        };
        Promise2.prototype.done = function(fulfilled, rejected, progress2) {
          var onUnhandledError = function(error) {
            Q.nextTick(function() {
              makeStackTraceLong(error, promise2);
              if (Q.onerror) {
                Q.onerror(error);
              } else {
                throw error;
              }
            });
          };
          var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
          if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
          }
          promise2.then(void 0, onUnhandledError);
        };
        Q.timeout = function(object, ms, error) {
          return Q(object).timeout(ms, error);
        };
        Promise2.prototype.timeout = function(ms, error) {
          var deferred = defer();
          var timeoutId = setTimeout(function() {
            if (!error || "string" === typeof error) {
              error = new Error(error || "Timed out after " + ms + " ms");
              error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
          }, ms);
          this.then(function(value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
          }, function(exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
          }, deferred.notify);
          return deferred.promise;
        };
        Q.delay = function(object, timeout) {
          if (timeout === void 0) {
            timeout = object;
            object = void 0;
          }
          return Q(object).delay(timeout);
        };
        Promise2.prototype.delay = function(timeout) {
          return this.then(function(value) {
            var deferred = defer();
            setTimeout(function() {
              deferred.resolve(value);
            }, timeout);
            return deferred.promise;
          });
        };
        Q.nfapply = function(callback, args) {
          return Q(callback).nfapply(args);
        };
        Promise2.prototype.nfapply = function(args) {
          var deferred = defer();
          var nodeArgs = array_slice(args);
          nodeArgs.push(deferred.makeNodeResolver());
          this.fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
        Q.nfcall = function(callback) {
          var args = array_slice(arguments, 1);
          return Q(callback).nfapply(args);
        };
        Promise2.prototype.nfcall = function() {
          var nodeArgs = array_slice(arguments);
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          this.fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
        Q.nfbind = Q.denodeify = function(callback) {
          if (callback === void 0) {
            throw new Error("Q can't wrap an undefined function");
          }
          var baseArgs = array_slice(arguments, 1);
          return function() {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
          };
        };
        Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
          var args = array_slice(arguments);
          args.unshift(this);
          return Q.denodeify.apply(void 0, args);
        };
        Q.nbind = function(callback, thisp) {
          var baseArgs = array_slice(arguments, 2);
          return function() {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
              return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
          };
        };
        Promise2.prototype.nbind = function() {
          var args = array_slice(arguments, 0);
          args.unshift(this);
          return Q.nbind.apply(void 0, args);
        };
        Q.nmapply = // XXX As proposed by "Redsandro"
        Q.npost = function(object, name, args) {
          return Q(object).npost(name, args);
        };
        Promise2.prototype.nmapply = // XXX As proposed by "Redsandro"
        Promise2.prototype.npost = function(name, args) {
          var nodeArgs = array_slice(args || []);
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
          return deferred.promise;
        };
        Q.nsend = // XXX Based on Mark Miller's proposed "send"
        Q.nmcall = // XXX Based on "Redsandro's" proposal
        Q.ninvoke = function(object, name) {
          var nodeArgs = array_slice(arguments, 2);
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
          return deferred.promise;
        };
        Promise2.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
        Promise2.prototype.nmcall = // XXX Based on "Redsandro's" proposal
        Promise2.prototype.ninvoke = function(name) {
          var nodeArgs = array_slice(arguments, 1);
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
          return deferred.promise;
        };
        Q.nodeify = nodeify;
        function nodeify(object, nodeback) {
          return Q(object).nodeify(nodeback);
        }
        Promise2.prototype.nodeify = function(nodeback) {
          if (nodeback) {
            this.then(function(value) {
              Q.nextTick(function() {
                nodeback(null, value);
              });
            }, function(error) {
              Q.nextTick(function() {
                nodeback(error);
              });
            });
          } else {
            return this;
          }
        };
        Q.noConflict = function() {
          throw new Error("Q.noConflict only works when Q is used as a global");
        };
        var qEndingLine = captureLine();
        return Q;
      });
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_protocol.js
  var require_multiplexed_protocol = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_protocol.js"(exports) {
      init_esbuild_shims();
      var util = require_util();
      var Thrift = require_thrift();
      exports.Multiplexer = Multiplexer;
      function Wrapper(serviceName, protocol, connection) {
        function MultiplexProtocol(trans, strictRead, strictWrite) {
          protocol.call(this, trans, strictRead, strictWrite);
        }
        ;
        util.inherits(MultiplexProtocol, protocol);
        MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
          if (type == Thrift.MessageType.CALL || type == Thrift.MessageType.ONEWAY) {
            connection.seqId2Service[seqid] = serviceName;
            MultiplexProtocol.super_.prototype.writeMessageBegin.call(
              this,
              serviceName + ":" + name,
              type,
              seqid
            );
          } else {
            MultiplexProtocol.super_.prototype.writeMessageBegin.call(this, name, type, seqid);
          }
        };
        return MultiplexProtocol;
      }
      function Multiplexer() {
        this.seqid = 0;
      }
      Multiplexer.prototype.createClient = function(serviceName, ServiceClient, connection) {
        if (ServiceClient.Client) {
          ServiceClient = ServiceClient.Client;
        }
        var writeCb = function(buf, seqid) {
          connection.write(buf, seqid);
        };
        var transport = new connection.transport(void 0, writeCb);
        var protocolWrapper = new Wrapper(serviceName, connection.protocol, connection);
        var client = new ServiceClient(transport, protocolWrapper);
        var self2 = this;
        client.new_seqid = function() {
          self2.seqid += 1;
          return self2.seqid;
        };
        if (typeof connection.client !== "object") {
          connection.client = {};
        }
        connection.client[serviceName] = client;
        return client;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/framed_transport.js
  var require_framed_transport = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/framed_transport.js"(exports, module) {
      init_esbuild_shims();
      var binary = require_binary();
      var InputBufferUnderrunError = require_input_buffer_underrun_error();
      var THeaderTransport = require_header_transport();
      module.exports = TFramedTransport;
      function TFramedTransport(buffer2, callback) {
        THeaderTransport.call(this);
        this.inBuf = buffer2 || new Buffer2(0);
        this.outBuffers = [];
        this.outCount = 0;
        this.readPos = 0;
        this.onFlush = callback;
      }
      Object.setPrototypeOf(TFramedTransport.prototype, THeaderTransport.prototype);
      TFramedTransport.receiver = function(callback, seqid) {
        var residual = [];
        return function(data) {
          for (var i = 0; i < data.length; ++i) {
            residual.push(data[i]);
          }
          while (residual.length > 0) {
            if (residual.length < 4) {
              return;
            }
            var frameSize = binary.readI32(Buffer2.from(residual.slice(0, 4)), 0);
            if (residual.length < 4 + frameSize) {
              return;
            }
            residual.splice(0, 4);
            var frame = Buffer2.from(residual.splice(0, frameSize));
            callback(new TFramedTransport(frame), seqid);
          }
        };
      };
      TFramedTransport.prototype.commitPosition = function() {
      }, TFramedTransport.prototype.rollbackPosition = function() {
      }, // TODO: Implement open/close support
      TFramedTransport.prototype.isOpen = function() {
        return true;
      };
      TFramedTransport.prototype.open = function() {
      };
      TFramedTransport.prototype.close = function() {
      };
      TFramedTransport.prototype.setCurrSeqId = function(seqid) {
        this._seqid = seqid;
      };
      TFramedTransport.prototype.ensureAvailable = function(len) {
        if (this.readPos + len > this.inBuf.length) {
          throw new InputBufferUnderrunError();
        }
      };
      TFramedTransport.prototype.read = function(len) {
        this.ensureAvailable(len);
        var end = this.readPos + len;
        if (this.inBuf.length < end) {
          throw new Error("read(" + len + ") failed - not enough data");
        }
        var buf = this.inBuf.slice(this.readPos, end);
        this.readPos = end;
        return buf;
      };
      TFramedTransport.prototype.readByte = function() {
        this.ensureAvailable(1);
        return binary.readByte(this.inBuf[this.readPos++]);
      };
      TFramedTransport.prototype.readI16 = function() {
        this.ensureAvailable(2);
        var i16 = binary.readI16(this.inBuf, this.readPos);
        this.readPos += 2;
        return i16;
      };
      TFramedTransport.prototype.readI32 = function() {
        this.ensureAvailable(4);
        var i32 = binary.readI32(this.inBuf, this.readPos);
        this.readPos += 4;
        return i32;
      };
      TFramedTransport.prototype.readDouble = function() {
        this.ensureAvailable(8);
        var d = binary.readDouble(this.inBuf, this.readPos);
        this.readPos += 8;
        return d;
      };
      TFramedTransport.prototype.readString = function(len) {
        this.ensureAvailable(len);
        var str = this.inBuf.toString("utf8", this.readPos, this.readPos + len);
        this.readPos += len;
        return str;
      };
      TFramedTransport.prototype.borrow = function() {
        return {
          buf: this.inBuf,
          readIndex: this.readPos,
          writeIndex: this.inBuf.length
        };
      };
      TFramedTransport.prototype.consume = function(bytesConsumed) {
        this.readPos += bytesConsumed;
      };
      TFramedTransport.prototype.write = function(buf, encoding) {
        if (typeof buf === "string") {
          buf = new Buffer2(buf, encoding || "utf8");
        }
        this.outBuffers.push(buf);
        this.outCount += buf.length;
      };
      TFramedTransport.prototype.flush = function() {
        var seqid = this._seqid;
        this._seqid = null;
        var out = new Buffer2(this.outCount), pos = 0;
        this.outBuffers.forEach(function(buf) {
          buf.copy(out, pos, 0);
          pos += buf.length;
        });
        if (this.onFlush) {
          var msg = new Buffer2(out.length + 4);
          binary.writeI32(msg, out.length);
          out.copy(msg, 4, 0, out.length);
          if (this.onFlush) {
            this.onFlush(msg, seqid);
          }
        }
        this.outBuffers = [];
        this.outCount = 0;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/ws_transport.js
  var require_ws_transport = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/ws_transport.js"(exports, module) {
      init_esbuild_shims();
      var log = require_log();
      module.exports = TWebSocketTransport;
      function TWebSocketTransport(url) {
        this.__reset(url);
      }
      TWebSocketTransport.prototype.__reset = function(url) {
        this.url = url;
        this.socket = null;
        this.callbacks = [];
        this.send_pending = [];
        this.send_buf = "";
        this.recv_buf = "";
        this.rb_wpos = 0;
        this.rb_rpos = 0;
      };
      TWebSocketTransport.prototype.flush = function(async, callback) {
        var self2 = this;
        if (this.isOpen()) {
          this.socket.send(this.send_buf);
          this.callbacks.push(/* @__PURE__ */ function() {
            var clientCallback = callback;
            return function(msg) {
              self2.setRecvBuffer(msg);
              clientCallback();
            };
          }());
        } else {
          this.send_pending.push({
            buf: this.send_buf,
            cb: callback
          });
        }
      };
      TWebSocketTransport.prototype.__onOpen = function() {
        var self2 = this;
        if (this.send_pending.length > 0) {
          this.send_pending.forEach(function(elem) {
            self2.socket.send(elem.buf);
            self2.callbacks.push(function() {
              var clientCallback = elem.cb;
              return function(msg) {
                self2.setRecvBuffer(msg);
                clientCallback();
              };
            }());
          });
          this.send_pending = [];
        }
      };
      TWebSocketTransport.prototype.__onClose = function(evt) {
        this.__reset(this.url);
      };
      TWebSocketTransport.prototype.__onMessage = function(evt) {
        if (this.callbacks.length) {
          this.callbacks.shift()(evt.data);
        }
      };
      TWebSocketTransport.prototype.__onError = function(evt) {
        log.error("websocket: " + evt.toString());
        this.socket.close();
      };
      TWebSocketTransport.prototype.setRecvBuffer = function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
      };
      TWebSocketTransport.prototype.isOpen = function() {
        return this.socket && this.socket.readyState == this.socket.OPEN;
      };
      TWebSocketTransport.prototype.open = function() {
        if (this.socket && this.socket.readyState != this.socket.CLOSED) {
          return;
        }
        this.socket = new WebSocket(this.url);
        this.socket.onopen = this.__onOpen.bind(this);
        this.socket.onmessage = this.__onMessage.bind(this);
        this.socket.onerror = this.__onError.bind(this);
        this.socket.onclose = this.__onClose.bind(this);
      };
      TWebSocketTransport.prototype.close = function() {
        this.socket.close();
      };
      TWebSocketTransport.prototype.read = function(len) {
        var avail = this.wpos - this.rpos;
        if (avail === 0) {
          return "";
        }
        var give = len;
        if (avail < len) {
          give = avail;
        }
        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;
        return ret;
      };
      TWebSocketTransport.prototype.readAll = function() {
        return this.recv_buf;
      };
      TWebSocketTransport.prototype.write = function(buf) {
        this.send_buf = buf;
      };
      TWebSocketTransport.prototype.getSendBuffer = function() {
        return this.send_buf;
      };
    }
  });

  // node_modules/thrift/lib/nodejs/lib/thrift/browser.js
  var require_browser2 = __commonJS({
    "node_modules/thrift/lib/nodejs/lib/thrift/browser.js"(exports) {
      init_esbuild_shims();
      exports.Thrift = require_thrift();
      var wsConnection = require_ws_connection();
      exports.WSConnection = wsConnection.WSConnection;
      exports.createWSConnection = wsConnection.createWSConnection;
      exports.createWSClient = wsConnection.createWSClient;
      var xhrConnection = require_xhr_connection();
      exports.XHRConnection = xhrConnection.XHRConnection;
      exports.createXHRConnection = xhrConnection.createXHRConnection;
      exports.createXHRClient = xhrConnection.createXHRClient;
      var ohosConnection = require_ohos_connection();
      exports.OhosConnection = ohosConnection.OhosConnection;
      exports.createOhosConnection = ohosConnection.createOhosConnection;
      exports.createOhosClient = ohosConnection.createOhosClient;
      exports.Int64 = require_Int64();
      exports.Q = require_q();
      var mpxProtocol = require_multiplexed_protocol();
      exports.Multiplexer = mpxProtocol.Multiplexer;
      exports.TBufferedTransport = require_buffered_transport();
      exports.TFramedTransport = require_framed_transport();
      exports.TWebSocketTransport = require_ws_transport();
      exports.Protocol = require_json_protocol();
      exports.TJSONProtocol = require_json_protocol();
      exports.TBinaryProtocol = require_binary_protocol();
      exports.TCompactProtocol = require_compact_protocol();
    }
  });

  // gen-nodejs/parquet_types.js
  var require_parquet_types = __commonJS({
    "gen-nodejs/parquet_types.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var thrift2 = require_browser2();
      var Thrift = thrift2.Thrift;
      var Q = thrift2.Q;
      var Int644 = require_Int64();
      var ttypes = module.exports = {};
      ttypes.Type = {
        "BOOLEAN": 0,
        "INT32": 1,
        "INT64": 2,
        "INT96": 3,
        "FLOAT": 4,
        "DOUBLE": 5,
        "BYTE_ARRAY": 6,
        "FIXED_LEN_BYTE_ARRAY": 7
      };
      ttypes.ConvertedType = {
        "UTF8": 0,
        "MAP": 1,
        "MAP_KEY_VALUE": 2,
        "LIST": 3,
        "ENUM": 4,
        "DECIMAL": 5,
        "DATE": 6,
        "TIME_MILLIS": 7,
        "TIME_MICROS": 8,
        "TIMESTAMP_MILLIS": 9,
        "TIMESTAMP_MICROS": 10,
        "UINT_8": 11,
        "UINT_16": 12,
        "UINT_32": 13,
        "UINT_64": 14,
        "INT_8": 15,
        "INT_16": 16,
        "INT_32": 17,
        "INT_64": 18,
        "JSON": 19,
        "BSON": 20,
        "INTERVAL": 21
      };
      ttypes.FieldRepetitionType = {
        "REQUIRED": 0,
        "OPTIONAL": 1,
        "REPEATED": 2
      };
      ttypes.Encoding = {
        "PLAIN": 0,
        "PLAIN_DICTIONARY": 2,
        "RLE": 3,
        "BIT_PACKED": 4,
        "DELTA_BINARY_PACKED": 5,
        "DELTA_LENGTH_BYTE_ARRAY": 6,
        "DELTA_BYTE_ARRAY": 7,
        "RLE_DICTIONARY": 8,
        "BYTE_STREAM_SPLIT": 9
      };
      ttypes.CompressionCodec = {
        "UNCOMPRESSED": 0,
        "SNAPPY": 1,
        "GZIP": 2,
        "LZO": 3,
        "BROTLI": 4,
        "LZ4": 5,
        "ZSTD": 6,
        "LZ4_RAW": 7
      };
      ttypes.PageType = {
        "DATA_PAGE": 0,
        "INDEX_PAGE": 1,
        "DICTIONARY_PAGE": 2,
        "DATA_PAGE_V2": 3
      };
      ttypes.BoundaryOrder = {
        "UNORDERED": 0,
        "ASCENDING": 1,
        "DESCENDING": 2
      };
      var Statistics = module.exports.Statistics = function(args) {
        this.max = null;
        this.min = null;
        this.null_count = null;
        this.distinct_count = null;
        this.max_value = null;
        this.min_value = null;
        if (args) {
          if (args.max !== void 0 && args.max !== null) {
            this.max = args.max;
          }
          if (args.min !== void 0 && args.min !== null) {
            this.min = args.min;
          }
          if (args.null_count !== void 0 && args.null_count !== null) {
            this.null_count = args.null_count;
          }
          if (args.distinct_count !== void 0 && args.distinct_count !== null) {
            this.distinct_count = args.distinct_count;
          }
          if (args.max_value !== void 0 && args.max_value !== null) {
            this.max_value = args.max_value;
          }
          if (args.min_value !== void 0 && args.min_value !== null) {
            this.min_value = args.min_value;
          }
        }
      };
      Statistics.prototype = {};
      Statistics.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRING) {
                this.max = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.min = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I64) {
                this.null_count = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I64) {
                this.distinct_count = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.STRING) {
                this.max_value = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.STRING) {
                this.min_value = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      Statistics.prototype.write = function(output) {
        output.writeStructBegin("Statistics");
        if (this.max !== null && this.max !== void 0) {
          output.writeFieldBegin("max", Thrift.Type.STRING, 1);
          output.writeBinary(this.max);
          output.writeFieldEnd();
        }
        if (this.min !== null && this.min !== void 0) {
          output.writeFieldBegin("min", Thrift.Type.STRING, 2);
          output.writeBinary(this.min);
          output.writeFieldEnd();
        }
        if (this.null_count !== null && this.null_count !== void 0) {
          output.writeFieldBegin("null_count", Thrift.Type.I64, 3);
          output.writeI64(this.null_count);
          output.writeFieldEnd();
        }
        if (this.distinct_count !== null && this.distinct_count !== void 0) {
          output.writeFieldBegin("distinct_count", Thrift.Type.I64, 4);
          output.writeI64(this.distinct_count);
          output.writeFieldEnd();
        }
        if (this.max_value !== null && this.max_value !== void 0) {
          output.writeFieldBegin("max_value", Thrift.Type.STRING, 5);
          output.writeBinary(this.max_value);
          output.writeFieldEnd();
        }
        if (this.min_value !== null && this.min_value !== void 0) {
          output.writeFieldBegin("min_value", Thrift.Type.STRING, 6);
          output.writeBinary(this.min_value);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var StringType = module.exports.StringType = function(args) {
      };
      StringType.prototype = {};
      StringType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      StringType.prototype.write = function(output) {
        output.writeStructBegin("StringType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var UUIDType = module.exports.UUIDType = function(args) {
      };
      UUIDType.prototype = {};
      UUIDType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      UUIDType.prototype.write = function(output) {
        output.writeStructBegin("UUIDType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var MapType = module.exports.MapType = function(args) {
      };
      MapType.prototype = {};
      MapType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      MapType.prototype.write = function(output) {
        output.writeStructBegin("MapType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ListType = module.exports.ListType = function(args) {
      };
      ListType.prototype = {};
      ListType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ListType.prototype.write = function(output) {
        output.writeStructBegin("ListType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var EnumType = module.exports.EnumType = function(args) {
      };
      EnumType.prototype = {};
      EnumType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      EnumType.prototype.write = function(output) {
        output.writeStructBegin("EnumType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var DateType = module.exports.DateType = function(args) {
      };
      DateType.prototype = {};
      DateType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      DateType.prototype.write = function(output) {
        output.writeStructBegin("DateType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var NullType = module.exports.NullType = function(args) {
      };
      NullType.prototype = {};
      NullType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      NullType.prototype.write = function(output) {
        output.writeStructBegin("NullType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var DecimalType = module.exports.DecimalType = function(args) {
        this.scale = null;
        this.precision = null;
        if (args) {
          if (args.scale !== void 0 && args.scale !== null) {
            this.scale = args.scale;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field scale is unset!");
          }
          if (args.precision !== void 0 && args.precision !== null) {
            this.precision = args.precision;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field precision is unset!");
          }
        }
      };
      DecimalType.prototype = {};
      DecimalType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.scale = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.precision = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      DecimalType.prototype.write = function(output) {
        output.writeStructBegin("DecimalType");
        if (this.scale !== null && this.scale !== void 0) {
          output.writeFieldBegin("scale", Thrift.Type.I32, 1);
          output.writeI32(this.scale);
          output.writeFieldEnd();
        }
        if (this.precision !== null && this.precision !== void 0) {
          output.writeFieldBegin("precision", Thrift.Type.I32, 2);
          output.writeI32(this.precision);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var MilliSeconds = module.exports.MilliSeconds = function(args) {
      };
      MilliSeconds.prototype = {};
      MilliSeconds.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      MilliSeconds.prototype.write = function(output) {
        output.writeStructBegin("MilliSeconds");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var MicroSeconds = module.exports.MicroSeconds = function(args) {
      };
      MicroSeconds.prototype = {};
      MicroSeconds.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      MicroSeconds.prototype.write = function(output) {
        output.writeStructBegin("MicroSeconds");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var NanoSeconds = module.exports.NanoSeconds = function(args) {
      };
      NanoSeconds.prototype = {};
      NanoSeconds.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      NanoSeconds.prototype.write = function(output) {
        output.writeStructBegin("NanoSeconds");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var TimeUnit = module.exports.TimeUnit = function(args) {
        this.MILLIS = null;
        this.MICROS = null;
        this.NANOS = null;
        if (args) {
          if (args.MILLIS !== void 0 && args.MILLIS !== null) {
            this.MILLIS = new ttypes.MilliSeconds(args.MILLIS);
          }
          if (args.MICROS !== void 0 && args.MICROS !== null) {
            this.MICROS = new ttypes.MicroSeconds(args.MICROS);
          }
          if (args.NANOS !== void 0 && args.NANOS !== null) {
            this.NANOS = new ttypes.NanoSeconds(args.NANOS);
          }
        }
      };
      TimeUnit.prototype = {};
      TimeUnit.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.MILLIS = new ttypes.MilliSeconds();
                this.MILLIS.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.MICROS = new ttypes.MicroSeconds();
                this.MICROS.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.STRUCT) {
                this.NANOS = new ttypes.NanoSeconds();
                this.NANOS.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      TimeUnit.prototype.write = function(output) {
        output.writeStructBegin("TimeUnit");
        if (this.MILLIS !== null && this.MILLIS !== void 0) {
          output.writeFieldBegin("MILLIS", Thrift.Type.STRUCT, 1);
          this.MILLIS.write(output);
          output.writeFieldEnd();
        }
        if (this.MICROS !== null && this.MICROS !== void 0) {
          output.writeFieldBegin("MICROS", Thrift.Type.STRUCT, 2);
          this.MICROS.write(output);
          output.writeFieldEnd();
        }
        if (this.NANOS !== null && this.NANOS !== void 0) {
          output.writeFieldBegin("NANOS", Thrift.Type.STRUCT, 3);
          this.NANOS.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var TimestampType = module.exports.TimestampType = function(args) {
        this.isAdjustedToUTC = null;
        this.unit = null;
        if (args) {
          if (args.isAdjustedToUTC !== void 0 && args.isAdjustedToUTC !== null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field isAdjustedToUTC is unset!");
          }
          if (args.unit !== void 0 && args.unit !== null) {
            this.unit = new ttypes.TimeUnit(args.unit);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field unit is unset!");
          }
        }
      };
      TimestampType.prototype = {};
      TimestampType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.BOOL) {
                this.isAdjustedToUTC = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.unit = new ttypes.TimeUnit();
                this.unit.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      TimestampType.prototype.write = function(output) {
        output.writeStructBegin("TimestampType");
        if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== void 0) {
          output.writeFieldBegin("isAdjustedToUTC", Thrift.Type.BOOL, 1);
          output.writeBool(this.isAdjustedToUTC);
          output.writeFieldEnd();
        }
        if (this.unit !== null && this.unit !== void 0) {
          output.writeFieldBegin("unit", Thrift.Type.STRUCT, 2);
          this.unit.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var TimeType = module.exports.TimeType = function(args) {
        this.isAdjustedToUTC = null;
        this.unit = null;
        if (args) {
          if (args.isAdjustedToUTC !== void 0 && args.isAdjustedToUTC !== null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field isAdjustedToUTC is unset!");
          }
          if (args.unit !== void 0 && args.unit !== null) {
            this.unit = new ttypes.TimeUnit(args.unit);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field unit is unset!");
          }
        }
      };
      TimeType.prototype = {};
      TimeType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.BOOL) {
                this.isAdjustedToUTC = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.unit = new ttypes.TimeUnit();
                this.unit.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      TimeType.prototype.write = function(output) {
        output.writeStructBegin("TimeType");
        if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== void 0) {
          output.writeFieldBegin("isAdjustedToUTC", Thrift.Type.BOOL, 1);
          output.writeBool(this.isAdjustedToUTC);
          output.writeFieldEnd();
        }
        if (this.unit !== null && this.unit !== void 0) {
          output.writeFieldBegin("unit", Thrift.Type.STRUCT, 2);
          this.unit.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var IntType = module.exports.IntType = function(args) {
        this.bitWidth = null;
        this.isSigned = null;
        if (args) {
          if (args.bitWidth !== void 0 && args.bitWidth !== null) {
            this.bitWidth = args.bitWidth;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field bitWidth is unset!");
          }
          if (args.isSigned !== void 0 && args.isSigned !== null) {
            this.isSigned = args.isSigned;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field isSigned is unset!");
          }
        }
      };
      IntType.prototype = {};
      IntType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.BYTE) {
                this.bitWidth = input.readByte();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.BOOL) {
                this.isSigned = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      IntType.prototype.write = function(output) {
        output.writeStructBegin("IntType");
        if (this.bitWidth !== null && this.bitWidth !== void 0) {
          output.writeFieldBegin("bitWidth", Thrift.Type.BYTE, 1);
          output.writeByte(this.bitWidth);
          output.writeFieldEnd();
        }
        if (this.isSigned !== null && this.isSigned !== void 0) {
          output.writeFieldBegin("isSigned", Thrift.Type.BOOL, 2);
          output.writeBool(this.isSigned);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var JsonType = module.exports.JsonType = function(args) {
      };
      JsonType.prototype = {};
      JsonType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      JsonType.prototype.write = function(output) {
        output.writeStructBegin("JsonType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var BsonType = module.exports.BsonType = function(args) {
      };
      BsonType.prototype = {};
      BsonType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      BsonType.prototype.write = function(output) {
        output.writeStructBegin("BsonType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var LogicalType = module.exports.LogicalType = function(args) {
        this.STRING = null;
        this.MAP = null;
        this.LIST = null;
        this.ENUM = null;
        this.DECIMAL = null;
        this.DATE = null;
        this.TIME = null;
        this.TIMESTAMP = null;
        this.INTEGER = null;
        this.UNKNOWN = null;
        this.JSON = null;
        this.BSON = null;
        this.UUID = null;
        if (args) {
          if (args.STRING !== void 0 && args.STRING !== null) {
            this.STRING = new ttypes.StringType(args.STRING);
          }
          if (args.MAP !== void 0 && args.MAP !== null) {
            this.MAP = new ttypes.MapType(args.MAP);
          }
          if (args.LIST !== void 0 && args.LIST !== null) {
            this.LIST = new ttypes.ListType(args.LIST);
          }
          if (args.ENUM !== void 0 && args.ENUM !== null) {
            this.ENUM = new ttypes.EnumType(args.ENUM);
          }
          if (args.DECIMAL !== void 0 && args.DECIMAL !== null) {
            this.DECIMAL = new ttypes.DecimalType(args.DECIMAL);
          }
          if (args.DATE !== void 0 && args.DATE !== null) {
            this.DATE = new ttypes.DateType(args.DATE);
          }
          if (args.TIME !== void 0 && args.TIME !== null) {
            this.TIME = new ttypes.TimeType(args.TIME);
          }
          if (args.TIMESTAMP !== void 0 && args.TIMESTAMP !== null) {
            this.TIMESTAMP = new ttypes.TimestampType(args.TIMESTAMP);
          }
          if (args.INTEGER !== void 0 && args.INTEGER !== null) {
            this.INTEGER = new ttypes.IntType(args.INTEGER);
          }
          if (args.UNKNOWN !== void 0 && args.UNKNOWN !== null) {
            this.UNKNOWN = new ttypes.NullType(args.UNKNOWN);
          }
          if (args.JSON !== void 0 && args.JSON !== null) {
            this.JSON = new ttypes.JsonType(args.JSON);
          }
          if (args.BSON !== void 0 && args.BSON !== null) {
            this.BSON = new ttypes.BsonType(args.BSON);
          }
          if (args.UUID !== void 0 && args.UUID !== null) {
            this.UUID = new ttypes.UUIDType(args.UUID);
          }
        }
      };
      LogicalType.prototype = {};
      LogicalType.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.STRING = new ttypes.StringType();
                this.STRING.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.MAP = new ttypes.MapType();
                this.MAP.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.STRUCT) {
                this.LIST = new ttypes.ListType();
                this.LIST.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.STRUCT) {
                this.ENUM = new ttypes.EnumType();
                this.ENUM.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.STRUCT) {
                this.DECIMAL = new ttypes.DecimalType();
                this.DECIMAL.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.STRUCT) {
                this.DATE = new ttypes.DateType();
                this.DATE.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.STRUCT) {
                this.TIME = new ttypes.TimeType();
                this.TIME.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.STRUCT) {
                this.TIMESTAMP = new ttypes.TimestampType();
                this.TIMESTAMP.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 10:
              if (ftype == Thrift.Type.STRUCT) {
                this.INTEGER = new ttypes.IntType();
                this.INTEGER.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 11:
              if (ftype == Thrift.Type.STRUCT) {
                this.UNKNOWN = new ttypes.NullType();
                this.UNKNOWN.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 12:
              if (ftype == Thrift.Type.STRUCT) {
                this.JSON = new ttypes.JsonType();
                this.JSON.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 13:
              if (ftype == Thrift.Type.STRUCT) {
                this.BSON = new ttypes.BsonType();
                this.BSON.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 14:
              if (ftype == Thrift.Type.STRUCT) {
                this.UUID = new ttypes.UUIDType();
                this.UUID.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      LogicalType.prototype.write = function(output) {
        output.writeStructBegin("LogicalType");
        if (this.STRING !== null && this.STRING !== void 0) {
          output.writeFieldBegin("STRING", Thrift.Type.STRUCT, 1);
          this.STRING.write(output);
          output.writeFieldEnd();
        }
        if (this.MAP !== null && this.MAP !== void 0) {
          output.writeFieldBegin("MAP", Thrift.Type.STRUCT, 2);
          this.MAP.write(output);
          output.writeFieldEnd();
        }
        if (this.LIST !== null && this.LIST !== void 0) {
          output.writeFieldBegin("LIST", Thrift.Type.STRUCT, 3);
          this.LIST.write(output);
          output.writeFieldEnd();
        }
        if (this.ENUM !== null && this.ENUM !== void 0) {
          output.writeFieldBegin("ENUM", Thrift.Type.STRUCT, 4);
          this.ENUM.write(output);
          output.writeFieldEnd();
        }
        if (this.DECIMAL !== null && this.DECIMAL !== void 0) {
          output.writeFieldBegin("DECIMAL", Thrift.Type.STRUCT, 5);
          this.DECIMAL.write(output);
          output.writeFieldEnd();
        }
        if (this.DATE !== null && this.DATE !== void 0) {
          output.writeFieldBegin("DATE", Thrift.Type.STRUCT, 6);
          this.DATE.write(output);
          output.writeFieldEnd();
        }
        if (this.TIME !== null && this.TIME !== void 0) {
          output.writeFieldBegin("TIME", Thrift.Type.STRUCT, 7);
          this.TIME.write(output);
          output.writeFieldEnd();
        }
        if (this.TIMESTAMP !== null && this.TIMESTAMP !== void 0) {
          output.writeFieldBegin("TIMESTAMP", Thrift.Type.STRUCT, 8);
          this.TIMESTAMP.write(output);
          output.writeFieldEnd();
        }
        if (this.INTEGER !== null && this.INTEGER !== void 0) {
          output.writeFieldBegin("INTEGER", Thrift.Type.STRUCT, 10);
          this.INTEGER.write(output);
          output.writeFieldEnd();
        }
        if (this.UNKNOWN !== null && this.UNKNOWN !== void 0) {
          output.writeFieldBegin("UNKNOWN", Thrift.Type.STRUCT, 11);
          this.UNKNOWN.write(output);
          output.writeFieldEnd();
        }
        if (this.JSON !== null && this.JSON !== void 0) {
          output.writeFieldBegin("JSON", Thrift.Type.STRUCT, 12);
          this.JSON.write(output);
          output.writeFieldEnd();
        }
        if (this.BSON !== null && this.BSON !== void 0) {
          output.writeFieldBegin("BSON", Thrift.Type.STRUCT, 13);
          this.BSON.write(output);
          output.writeFieldEnd();
        }
        if (this.UUID !== null && this.UUID !== void 0) {
          output.writeFieldBegin("UUID", Thrift.Type.STRUCT, 14);
          this.UUID.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var SchemaElement = module.exports.SchemaElement = function(args) {
        this.type = null;
        this.type_length = null;
        this.repetition_type = null;
        this.name = null;
        this.num_children = null;
        this.converted_type = null;
        this.scale = null;
        this.precision = null;
        this.field_id = null;
        this.logicalType = null;
        if (args) {
          if (args.type !== void 0 && args.type !== null) {
            this.type = args.type;
          }
          if (args.type_length !== void 0 && args.type_length !== null) {
            this.type_length = args.type_length;
          }
          if (args.repetition_type !== void 0 && args.repetition_type !== null) {
            this.repetition_type = args.repetition_type;
          }
          if (args.name !== void 0 && args.name !== null) {
            this.name = args.name;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field name is unset!");
          }
          if (args.num_children !== void 0 && args.num_children !== null) {
            this.num_children = args.num_children;
          }
          if (args.converted_type !== void 0 && args.converted_type !== null) {
            this.converted_type = args.converted_type;
          }
          if (args.scale !== void 0 && args.scale !== null) {
            this.scale = args.scale;
          }
          if (args.precision !== void 0 && args.precision !== null) {
            this.precision = args.precision;
          }
          if (args.field_id !== void 0 && args.field_id !== null) {
            this.field_id = args.field_id;
          }
          if (args.logicalType !== void 0 && args.logicalType !== null) {
            this.logicalType = new ttypes.LogicalType(args.logicalType);
          }
        }
      };
      SchemaElement.prototype = {};
      SchemaElement.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.type_length = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I32) {
                this.repetition_type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.STRING) {
                this.name = input.readString();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.I32) {
                this.num_children = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.I32) {
                this.converted_type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.I32) {
                this.scale = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.I32) {
                this.precision = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 9:
              if (ftype == Thrift.Type.I32) {
                this.field_id = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 10:
              if (ftype == Thrift.Type.STRUCT) {
                this.logicalType = new ttypes.LogicalType();
                this.logicalType.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      SchemaElement.prototype.write = function(output) {
        output.writeStructBegin("SchemaElement");
        if (this.type !== null && this.type !== void 0) {
          output.writeFieldBegin("type", Thrift.Type.I32, 1);
          output.writeI32(this.type);
          output.writeFieldEnd();
        }
        if (this.type_length !== null && this.type_length !== void 0) {
          output.writeFieldBegin("type_length", Thrift.Type.I32, 2);
          output.writeI32(this.type_length);
          output.writeFieldEnd();
        }
        if (this.repetition_type !== null && this.repetition_type !== void 0) {
          output.writeFieldBegin("repetition_type", Thrift.Type.I32, 3);
          output.writeI32(this.repetition_type);
          output.writeFieldEnd();
        }
        if (this.name !== null && this.name !== void 0) {
          output.writeFieldBegin("name", Thrift.Type.STRING, 4);
          output.writeString(this.name);
          output.writeFieldEnd();
        }
        if (this.num_children !== null && this.num_children !== void 0) {
          output.writeFieldBegin("num_children", Thrift.Type.I32, 5);
          output.writeI32(this.num_children);
          output.writeFieldEnd();
        }
        if (this.converted_type !== null && this.converted_type !== void 0) {
          output.writeFieldBegin("converted_type", Thrift.Type.I32, 6);
          output.writeI32(this.converted_type);
          output.writeFieldEnd();
        }
        if (this.scale !== null && this.scale !== void 0) {
          output.writeFieldBegin("scale", Thrift.Type.I32, 7);
          output.writeI32(this.scale);
          output.writeFieldEnd();
        }
        if (this.precision !== null && this.precision !== void 0) {
          output.writeFieldBegin("precision", Thrift.Type.I32, 8);
          output.writeI32(this.precision);
          output.writeFieldEnd();
        }
        if (this.field_id !== null && this.field_id !== void 0) {
          output.writeFieldBegin("field_id", Thrift.Type.I32, 9);
          output.writeI32(this.field_id);
          output.writeFieldEnd();
        }
        if (this.logicalType !== null && this.logicalType !== void 0) {
          output.writeFieldBegin("logicalType", Thrift.Type.STRUCT, 10);
          this.logicalType.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var DataPageHeader = module.exports.DataPageHeader = function(args) {
        this.num_values = null;
        this.encoding = null;
        this.definition_level_encoding = null;
        this.repetition_level_encoding = null;
        this.statistics = null;
        if (args) {
          if (args.num_values !== void 0 && args.num_values !== null) {
            this.num_values = args.num_values;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_values is unset!");
          }
          if (args.encoding !== void 0 && args.encoding !== null) {
            this.encoding = args.encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encoding is unset!");
          }
          if (args.definition_level_encoding !== void 0 && args.definition_level_encoding !== null) {
            this.definition_level_encoding = args.definition_level_encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field definition_level_encoding is unset!");
          }
          if (args.repetition_level_encoding !== void 0 && args.repetition_level_encoding !== null) {
            this.repetition_level_encoding = args.repetition_level_encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field repetition_level_encoding is unset!");
          }
          if (args.statistics !== void 0 && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
          }
        }
      };
      DataPageHeader.prototype = {};
      DataPageHeader.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.num_values = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I32) {
                this.definition_level_encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I32) {
                this.repetition_level_encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.STRUCT) {
                this.statistics = new ttypes.Statistics();
                this.statistics.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      DataPageHeader.prototype.write = function(output) {
        output.writeStructBegin("DataPageHeader");
        if (this.num_values !== null && this.num_values !== void 0) {
          output.writeFieldBegin("num_values", Thrift.Type.I32, 1);
          output.writeI32(this.num_values);
          output.writeFieldEnd();
        }
        if (this.encoding !== null && this.encoding !== void 0) {
          output.writeFieldBegin("encoding", Thrift.Type.I32, 2);
          output.writeI32(this.encoding);
          output.writeFieldEnd();
        }
        if (this.definition_level_encoding !== null && this.definition_level_encoding !== void 0) {
          output.writeFieldBegin("definition_level_encoding", Thrift.Type.I32, 3);
          output.writeI32(this.definition_level_encoding);
          output.writeFieldEnd();
        }
        if (this.repetition_level_encoding !== null && this.repetition_level_encoding !== void 0) {
          output.writeFieldBegin("repetition_level_encoding", Thrift.Type.I32, 4);
          output.writeI32(this.repetition_level_encoding);
          output.writeFieldEnd();
        }
        if (this.statistics !== null && this.statistics !== void 0) {
          output.writeFieldBegin("statistics", Thrift.Type.STRUCT, 5);
          this.statistics.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var IndexPageHeader = module.exports.IndexPageHeader = function(args) {
      };
      IndexPageHeader.prototype = {};
      IndexPageHeader.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      IndexPageHeader.prototype.write = function(output) {
        output.writeStructBegin("IndexPageHeader");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var DictionaryPageHeader = module.exports.DictionaryPageHeader = function(args) {
        this.num_values = null;
        this.encoding = null;
        this.is_sorted = null;
        if (args) {
          if (args.num_values !== void 0 && args.num_values !== null) {
            this.num_values = args.num_values;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_values is unset!");
          }
          if (args.encoding !== void 0 && args.encoding !== null) {
            this.encoding = args.encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encoding is unset!");
          }
          if (args.is_sorted !== void 0 && args.is_sorted !== null) {
            this.is_sorted = args.is_sorted;
          }
        }
      };
      DictionaryPageHeader.prototype = {};
      DictionaryPageHeader.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.num_values = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.BOOL) {
                this.is_sorted = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      DictionaryPageHeader.prototype.write = function(output) {
        output.writeStructBegin("DictionaryPageHeader");
        if (this.num_values !== null && this.num_values !== void 0) {
          output.writeFieldBegin("num_values", Thrift.Type.I32, 1);
          output.writeI32(this.num_values);
          output.writeFieldEnd();
        }
        if (this.encoding !== null && this.encoding !== void 0) {
          output.writeFieldBegin("encoding", Thrift.Type.I32, 2);
          output.writeI32(this.encoding);
          output.writeFieldEnd();
        }
        if (this.is_sorted !== null && this.is_sorted !== void 0) {
          output.writeFieldBegin("is_sorted", Thrift.Type.BOOL, 3);
          output.writeBool(this.is_sorted);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var DataPageHeaderV2 = module.exports.DataPageHeaderV2 = function(args) {
        this.num_values = null;
        this.num_nulls = null;
        this.num_rows = null;
        this.encoding = null;
        this.definition_levels_byte_length = null;
        this.repetition_levels_byte_length = null;
        this.is_compressed = true;
        this.statistics = null;
        if (args) {
          if (args.num_values !== void 0 && args.num_values !== null) {
            this.num_values = args.num_values;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_values is unset!");
          }
          if (args.num_nulls !== void 0 && args.num_nulls !== null) {
            this.num_nulls = args.num_nulls;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_nulls is unset!");
          }
          if (args.num_rows !== void 0 && args.num_rows !== null) {
            this.num_rows = args.num_rows;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_rows is unset!");
          }
          if (args.encoding !== void 0 && args.encoding !== null) {
            this.encoding = args.encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encoding is unset!");
          }
          if (args.definition_levels_byte_length !== void 0 && args.definition_levels_byte_length !== null) {
            this.definition_levels_byte_length = args.definition_levels_byte_length;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field definition_levels_byte_length is unset!");
          }
          if (args.repetition_levels_byte_length !== void 0 && args.repetition_levels_byte_length !== null) {
            this.repetition_levels_byte_length = args.repetition_levels_byte_length;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field repetition_levels_byte_length is unset!");
          }
          if (args.is_compressed !== void 0 && args.is_compressed !== null) {
            this.is_compressed = args.is_compressed;
          }
          if (args.statistics !== void 0 && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
          }
        }
      };
      DataPageHeaderV2.prototype = {};
      DataPageHeaderV2.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.num_values = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.num_nulls = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I32) {
                this.num_rows = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I32) {
                this.encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.I32) {
                this.definition_levels_byte_length = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.I32) {
                this.repetition_levels_byte_length = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.BOOL) {
                this.is_compressed = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.STRUCT) {
                this.statistics = new ttypes.Statistics();
                this.statistics.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      DataPageHeaderV2.prototype.write = function(output) {
        output.writeStructBegin("DataPageHeaderV2");
        if (this.num_values !== null && this.num_values !== void 0) {
          output.writeFieldBegin("num_values", Thrift.Type.I32, 1);
          output.writeI32(this.num_values);
          output.writeFieldEnd();
        }
        if (this.num_nulls !== null && this.num_nulls !== void 0) {
          output.writeFieldBegin("num_nulls", Thrift.Type.I32, 2);
          output.writeI32(this.num_nulls);
          output.writeFieldEnd();
        }
        if (this.num_rows !== null && this.num_rows !== void 0) {
          output.writeFieldBegin("num_rows", Thrift.Type.I32, 3);
          output.writeI32(this.num_rows);
          output.writeFieldEnd();
        }
        if (this.encoding !== null && this.encoding !== void 0) {
          output.writeFieldBegin("encoding", Thrift.Type.I32, 4);
          output.writeI32(this.encoding);
          output.writeFieldEnd();
        }
        if (this.definition_levels_byte_length !== null && this.definition_levels_byte_length !== void 0) {
          output.writeFieldBegin("definition_levels_byte_length", Thrift.Type.I32, 5);
          output.writeI32(this.definition_levels_byte_length);
          output.writeFieldEnd();
        }
        if (this.repetition_levels_byte_length !== null && this.repetition_levels_byte_length !== void 0) {
          output.writeFieldBegin("repetition_levels_byte_length", Thrift.Type.I32, 6);
          output.writeI32(this.repetition_levels_byte_length);
          output.writeFieldEnd();
        }
        if (this.is_compressed !== null && this.is_compressed !== void 0) {
          output.writeFieldBegin("is_compressed", Thrift.Type.BOOL, 7);
          output.writeBool(this.is_compressed);
          output.writeFieldEnd();
        }
        if (this.statistics !== null && this.statistics !== void 0) {
          output.writeFieldBegin("statistics", Thrift.Type.STRUCT, 8);
          this.statistics.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var SplitBlockAlgorithm = module.exports.SplitBlockAlgorithm = function(args) {
      };
      SplitBlockAlgorithm.prototype = {};
      SplitBlockAlgorithm.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      SplitBlockAlgorithm.prototype.write = function(output) {
        output.writeStructBegin("SplitBlockAlgorithm");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var BloomFilterAlgorithm = module.exports.BloomFilterAlgorithm = function(args) {
        this.BLOCK = null;
        if (args) {
          if (args.BLOCK !== void 0 && args.BLOCK !== null) {
            this.BLOCK = new ttypes.SplitBlockAlgorithm(args.BLOCK);
          }
        }
      };
      BloomFilterAlgorithm.prototype = {};
      BloomFilterAlgorithm.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.BLOCK = new ttypes.SplitBlockAlgorithm();
                this.BLOCK.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 0:
              input.skip(ftype);
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      BloomFilterAlgorithm.prototype.write = function(output) {
        output.writeStructBegin("BloomFilterAlgorithm");
        if (this.BLOCK !== null && this.BLOCK !== void 0) {
          output.writeFieldBegin("BLOCK", Thrift.Type.STRUCT, 1);
          this.BLOCK.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var XxHash = module.exports.XxHash = function(args) {
      };
      XxHash.prototype = {};
      XxHash.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      XxHash.prototype.write = function(output) {
        output.writeStructBegin("XxHash");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var BloomFilterHash = module.exports.BloomFilterHash = function(args) {
        this.XXHASH = null;
        if (args) {
          if (args.XXHASH !== void 0 && args.XXHASH !== null) {
            this.XXHASH = new ttypes.XxHash(args.XXHASH);
          }
        }
      };
      BloomFilterHash.prototype = {};
      BloomFilterHash.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.XXHASH = new ttypes.XxHash();
                this.XXHASH.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 0:
              input.skip(ftype);
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      BloomFilterHash.prototype.write = function(output) {
        output.writeStructBegin("BloomFilterHash");
        if (this.XXHASH !== null && this.XXHASH !== void 0) {
          output.writeFieldBegin("XXHASH", Thrift.Type.STRUCT, 1);
          this.XXHASH.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var Uncompressed = module.exports.Uncompressed = function(args) {
      };
      Uncompressed.prototype = {};
      Uncompressed.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      Uncompressed.prototype.write = function(output) {
        output.writeStructBegin("Uncompressed");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var BloomFilterCompression = module.exports.BloomFilterCompression = function(args) {
        this.UNCOMPRESSED = null;
        if (args) {
          if (args.UNCOMPRESSED !== void 0 && args.UNCOMPRESSED !== null) {
            this.UNCOMPRESSED = new ttypes.Uncompressed(args.UNCOMPRESSED);
          }
        }
      };
      BloomFilterCompression.prototype = {};
      BloomFilterCompression.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.UNCOMPRESSED = new ttypes.Uncompressed();
                this.UNCOMPRESSED.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 0:
              input.skip(ftype);
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      BloomFilterCompression.prototype.write = function(output) {
        output.writeStructBegin("BloomFilterCompression");
        if (this.UNCOMPRESSED !== null && this.UNCOMPRESSED !== void 0) {
          output.writeFieldBegin("UNCOMPRESSED", Thrift.Type.STRUCT, 1);
          this.UNCOMPRESSED.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var BloomFilterHeader = module.exports.BloomFilterHeader = function(args) {
        this.numBytes = null;
        this.algorithm = null;
        this.hash = null;
        this.compression = null;
        if (args) {
          if (args.numBytes !== void 0 && args.numBytes !== null) {
            this.numBytes = args.numBytes;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field numBytes is unset!");
          }
          if (args.algorithm !== void 0 && args.algorithm !== null) {
            this.algorithm = new ttypes.BloomFilterAlgorithm(args.algorithm);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field algorithm is unset!");
          }
          if (args.hash !== void 0 && args.hash !== null) {
            this.hash = new ttypes.BloomFilterHash(args.hash);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field hash is unset!");
          }
          if (args.compression !== void 0 && args.compression !== null) {
            this.compression = new ttypes.BloomFilterCompression(args.compression);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field compression is unset!");
          }
        }
      };
      BloomFilterHeader.prototype = {};
      BloomFilterHeader.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.numBytes = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.algorithm = new ttypes.BloomFilterAlgorithm();
                this.algorithm.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.STRUCT) {
                this.hash = new ttypes.BloomFilterHash();
                this.hash.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.STRUCT) {
                this.compression = new ttypes.BloomFilterCompression();
                this.compression.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      BloomFilterHeader.prototype.write = function(output) {
        output.writeStructBegin("BloomFilterHeader");
        if (this.numBytes !== null && this.numBytes !== void 0) {
          output.writeFieldBegin("numBytes", Thrift.Type.I32, 1);
          output.writeI32(this.numBytes);
          output.writeFieldEnd();
        }
        if (this.algorithm !== null && this.algorithm !== void 0) {
          output.writeFieldBegin("algorithm", Thrift.Type.STRUCT, 2);
          this.algorithm.write(output);
          output.writeFieldEnd();
        }
        if (this.hash !== null && this.hash !== void 0) {
          output.writeFieldBegin("hash", Thrift.Type.STRUCT, 3);
          this.hash.write(output);
          output.writeFieldEnd();
        }
        if (this.compression !== null && this.compression !== void 0) {
          output.writeFieldBegin("compression", Thrift.Type.STRUCT, 4);
          this.compression.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var PageHeader = module.exports.PageHeader = function(args) {
        this.type = null;
        this.uncompressed_page_size = null;
        this.compressed_page_size = null;
        this.crc = null;
        this.data_page_header = null;
        this.index_page_header = null;
        this.dictionary_page_header = null;
        this.data_page_header_v2 = null;
        if (args) {
          if (args.type !== void 0 && args.type !== null) {
            this.type = args.type;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field type is unset!");
          }
          if (args.uncompressed_page_size !== void 0 && args.uncompressed_page_size !== null) {
            this.uncompressed_page_size = args.uncompressed_page_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field uncompressed_page_size is unset!");
          }
          if (args.compressed_page_size !== void 0 && args.compressed_page_size !== null) {
            this.compressed_page_size = args.compressed_page_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field compressed_page_size is unset!");
          }
          if (args.crc !== void 0 && args.crc !== null) {
            this.crc = args.crc;
          }
          if (args.data_page_header !== void 0 && args.data_page_header !== null) {
            this.data_page_header = new ttypes.DataPageHeader(args.data_page_header);
          }
          if (args.index_page_header !== void 0 && args.index_page_header !== null) {
            this.index_page_header = new ttypes.IndexPageHeader(args.index_page_header);
          }
          if (args.dictionary_page_header !== void 0 && args.dictionary_page_header !== null) {
            this.dictionary_page_header = new ttypes.DictionaryPageHeader(args.dictionary_page_header);
          }
          if (args.data_page_header_v2 !== void 0 && args.data_page_header_v2 !== null) {
            this.data_page_header_v2 = new ttypes.DataPageHeaderV2(args.data_page_header_v2);
          }
        }
      };
      PageHeader.prototype = {};
      PageHeader.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.uncompressed_page_size = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I32) {
                this.compressed_page_size = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I32) {
                this.crc = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.STRUCT) {
                this.data_page_header = new ttypes.DataPageHeader();
                this.data_page_header.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.STRUCT) {
                this.index_page_header = new ttypes.IndexPageHeader();
                this.index_page_header.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.STRUCT) {
                this.dictionary_page_header = new ttypes.DictionaryPageHeader();
                this.dictionary_page_header.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.STRUCT) {
                this.data_page_header_v2 = new ttypes.DataPageHeaderV2();
                this.data_page_header_v2.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      PageHeader.prototype.write = function(output) {
        output.writeStructBegin("PageHeader");
        if (this.type !== null && this.type !== void 0) {
          output.writeFieldBegin("type", Thrift.Type.I32, 1);
          output.writeI32(this.type);
          output.writeFieldEnd();
        }
        if (this.uncompressed_page_size !== null && this.uncompressed_page_size !== void 0) {
          output.writeFieldBegin("uncompressed_page_size", Thrift.Type.I32, 2);
          output.writeI32(this.uncompressed_page_size);
          output.writeFieldEnd();
        }
        if (this.compressed_page_size !== null && this.compressed_page_size !== void 0) {
          output.writeFieldBegin("compressed_page_size", Thrift.Type.I32, 3);
          output.writeI32(this.compressed_page_size);
          output.writeFieldEnd();
        }
        if (this.crc !== null && this.crc !== void 0) {
          output.writeFieldBegin("crc", Thrift.Type.I32, 4);
          output.writeI32(this.crc);
          output.writeFieldEnd();
        }
        if (this.data_page_header !== null && this.data_page_header !== void 0) {
          output.writeFieldBegin("data_page_header", Thrift.Type.STRUCT, 5);
          this.data_page_header.write(output);
          output.writeFieldEnd();
        }
        if (this.index_page_header !== null && this.index_page_header !== void 0) {
          output.writeFieldBegin("index_page_header", Thrift.Type.STRUCT, 6);
          this.index_page_header.write(output);
          output.writeFieldEnd();
        }
        if (this.dictionary_page_header !== null && this.dictionary_page_header !== void 0) {
          output.writeFieldBegin("dictionary_page_header", Thrift.Type.STRUCT, 7);
          this.dictionary_page_header.write(output);
          output.writeFieldEnd();
        }
        if (this.data_page_header_v2 !== null && this.data_page_header_v2 !== void 0) {
          output.writeFieldBegin("data_page_header_v2", Thrift.Type.STRUCT, 8);
          this.data_page_header_v2.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var KeyValue = module.exports.KeyValue = function(args) {
        this.key = null;
        this.value = null;
        if (args) {
          if (args.key !== void 0 && args.key !== null) {
            this.key = args.key;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field key is unset!");
          }
          if (args.value !== void 0 && args.value !== null) {
            this.value = args.value;
          }
        }
      };
      KeyValue.prototype = {};
      KeyValue.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRING) {
                this.key = input.readString();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.value = input.readString();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      KeyValue.prototype.write = function(output) {
        output.writeStructBegin("KeyValue");
        if (this.key !== null && this.key !== void 0) {
          output.writeFieldBegin("key", Thrift.Type.STRING, 1);
          output.writeString(this.key);
          output.writeFieldEnd();
        }
        if (this.value !== null && this.value !== void 0) {
          output.writeFieldBegin("value", Thrift.Type.STRING, 2);
          output.writeString(this.value);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var SortingColumn = module.exports.SortingColumn = function(args) {
        this.column_idx = null;
        this.descending = null;
        this.nulls_first = null;
        if (args) {
          if (args.column_idx !== void 0 && args.column_idx !== null) {
            this.column_idx = args.column_idx;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field column_idx is unset!");
          }
          if (args.descending !== void 0 && args.descending !== null) {
            this.descending = args.descending;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field descending is unset!");
          }
          if (args.nulls_first !== void 0 && args.nulls_first !== null) {
            this.nulls_first = args.nulls_first;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls_first is unset!");
          }
        }
      };
      SortingColumn.prototype = {};
      SortingColumn.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.column_idx = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.BOOL) {
                this.descending = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.BOOL) {
                this.nulls_first = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      SortingColumn.prototype.write = function(output) {
        output.writeStructBegin("SortingColumn");
        if (this.column_idx !== null && this.column_idx !== void 0) {
          output.writeFieldBegin("column_idx", Thrift.Type.I32, 1);
          output.writeI32(this.column_idx);
          output.writeFieldEnd();
        }
        if (this.descending !== null && this.descending !== void 0) {
          output.writeFieldBegin("descending", Thrift.Type.BOOL, 2);
          output.writeBool(this.descending);
          output.writeFieldEnd();
        }
        if (this.nulls_first !== null && this.nulls_first !== void 0) {
          output.writeFieldBegin("nulls_first", Thrift.Type.BOOL, 3);
          output.writeBool(this.nulls_first);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var PageEncodingStats = module.exports.PageEncodingStats = function(args) {
        this.page_type = null;
        this.encoding = null;
        this.count = null;
        if (args) {
          if (args.page_type !== void 0 && args.page_type !== null) {
            this.page_type = args.page_type;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field page_type is unset!");
          }
          if (args.encoding !== void 0 && args.encoding !== null) {
            this.encoding = args.encoding;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encoding is unset!");
          }
          if (args.count !== void 0 && args.count !== null) {
            this.count = args.count;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field count is unset!");
          }
        }
      };
      PageEncodingStats.prototype = {};
      PageEncodingStats.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.page_type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.encoding = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I32) {
                this.count = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      PageEncodingStats.prototype.write = function(output) {
        output.writeStructBegin("PageEncodingStats");
        if (this.page_type !== null && this.page_type !== void 0) {
          output.writeFieldBegin("page_type", Thrift.Type.I32, 1);
          output.writeI32(this.page_type);
          output.writeFieldEnd();
        }
        if (this.encoding !== null && this.encoding !== void 0) {
          output.writeFieldBegin("encoding", Thrift.Type.I32, 2);
          output.writeI32(this.encoding);
          output.writeFieldEnd();
        }
        if (this.count !== null && this.count !== void 0) {
          output.writeFieldBegin("count", Thrift.Type.I32, 3);
          output.writeI32(this.count);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ColumnMetaData = module.exports.ColumnMetaData = function(args) {
        this.type = null;
        this.encodings = null;
        this.path_in_schema = null;
        this.codec = null;
        this.num_values = null;
        this.total_uncompressed_size = null;
        this.total_compressed_size = null;
        this.key_value_metadata = null;
        this.data_page_offset = null;
        this.index_page_offset = null;
        this.dictionary_page_offset = null;
        this.statistics = null;
        this.encoding_stats = null;
        this.bloom_filter_offset = null;
        if (args) {
          if (args.type !== void 0 && args.type !== null) {
            this.type = args.type;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field type is unset!");
          }
          if (args.encodings !== void 0 && args.encodings !== null) {
            this.encodings = Thrift.copyList(args.encodings, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encodings is unset!");
          }
          if (args.path_in_schema !== void 0 && args.path_in_schema !== null) {
            this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field path_in_schema is unset!");
          }
          if (args.codec !== void 0 && args.codec !== null) {
            this.codec = args.codec;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field codec is unset!");
          }
          if (args.num_values !== void 0 && args.num_values !== null) {
            this.num_values = args.num_values;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_values is unset!");
          }
          if (args.total_uncompressed_size !== void 0 && args.total_uncompressed_size !== null) {
            this.total_uncompressed_size = args.total_uncompressed_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field total_uncompressed_size is unset!");
          }
          if (args.total_compressed_size !== void 0 && args.total_compressed_size !== null) {
            this.total_compressed_size = args.total_compressed_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field total_compressed_size is unset!");
          }
          if (args.key_value_metadata !== void 0 && args.key_value_metadata !== null) {
            this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
          }
          if (args.data_page_offset !== void 0 && args.data_page_offset !== null) {
            this.data_page_offset = args.data_page_offset;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field data_page_offset is unset!");
          }
          if (args.index_page_offset !== void 0 && args.index_page_offset !== null) {
            this.index_page_offset = args.index_page_offset;
          }
          if (args.dictionary_page_offset !== void 0 && args.dictionary_page_offset !== null) {
            this.dictionary_page_offset = args.dictionary_page_offset;
          }
          if (args.statistics !== void 0 && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
          }
          if (args.encoding_stats !== void 0 && args.encoding_stats !== null) {
            this.encoding_stats = Thrift.copyList(args.encoding_stats, [ttypes.PageEncodingStats]);
          }
          if (args.bloom_filter_offset !== void 0 && args.bloom_filter_offset !== null) {
            this.bloom_filter_offset = args.bloom_filter_offset;
          }
        }
      };
      ColumnMetaData.prototype = {};
      ColumnMetaData.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.type = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.LIST) {
                this.encodings = [];
                var _rtmp31 = input.readListBegin();
                var _size0 = _rtmp31.size || 0;
                for (var _i2 = 0; _i2 < _size0; ++_i2) {
                  var elem3 = null;
                  elem3 = input.readI32();
                  this.encodings.push(elem3);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.LIST) {
                this.path_in_schema = [];
                var _rtmp35 = input.readListBegin();
                var _size4 = _rtmp35.size || 0;
                for (var _i6 = 0; _i6 < _size4; ++_i6) {
                  var elem7 = null;
                  elem7 = input.readString();
                  this.path_in_schema.push(elem7);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I32) {
                this.codec = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.I64) {
                this.num_values = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.I64) {
                this.total_uncompressed_size = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.I64) {
                this.total_compressed_size = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.LIST) {
                this.key_value_metadata = [];
                var _rtmp39 = input.readListBegin();
                var _size8 = _rtmp39.size || 0;
                for (var _i10 = 0; _i10 < _size8; ++_i10) {
                  var elem11 = null;
                  elem11 = new ttypes.KeyValue();
                  elem11.read(input);
                  this.key_value_metadata.push(elem11);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 9:
              if (ftype == Thrift.Type.I64) {
                this.data_page_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 10:
              if (ftype == Thrift.Type.I64) {
                this.index_page_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 11:
              if (ftype == Thrift.Type.I64) {
                this.dictionary_page_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 12:
              if (ftype == Thrift.Type.STRUCT) {
                this.statistics = new ttypes.Statistics();
                this.statistics.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 13:
              if (ftype == Thrift.Type.LIST) {
                this.encoding_stats = [];
                var _rtmp313 = input.readListBegin();
                var _size12 = _rtmp313.size || 0;
                for (var _i14 = 0; _i14 < _size12; ++_i14) {
                  var elem15 = null;
                  elem15 = new ttypes.PageEncodingStats();
                  elem15.read(input);
                  this.encoding_stats.push(elem15);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 14:
              if (ftype == Thrift.Type.I64) {
                this.bloom_filter_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ColumnMetaData.prototype.write = function(output) {
        output.writeStructBegin("ColumnMetaData");
        if (this.type !== null && this.type !== void 0) {
          output.writeFieldBegin("type", Thrift.Type.I32, 1);
          output.writeI32(this.type);
          output.writeFieldEnd();
        }
        if (this.encodings !== null && this.encodings !== void 0) {
          output.writeFieldBegin("encodings", Thrift.Type.LIST, 2);
          output.writeListBegin(Thrift.Type.I32, this.encodings.length);
          for (var iter16 in this.encodings) {
            if (this.encodings.hasOwnProperty(iter16)) {
              iter16 = this.encodings[iter16];
              output.writeI32(iter16);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.path_in_schema !== null && this.path_in_schema !== void 0) {
          output.writeFieldBegin("path_in_schema", Thrift.Type.LIST, 3);
          output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
          for (var iter17 in this.path_in_schema) {
            if (this.path_in_schema.hasOwnProperty(iter17)) {
              iter17 = this.path_in_schema[iter17];
              output.writeString(iter17);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.codec !== null && this.codec !== void 0) {
          output.writeFieldBegin("codec", Thrift.Type.I32, 4);
          output.writeI32(this.codec);
          output.writeFieldEnd();
        }
        if (this.num_values !== null && this.num_values !== void 0) {
          output.writeFieldBegin("num_values", Thrift.Type.I64, 5);
          output.writeI64(this.num_values);
          output.writeFieldEnd();
        }
        if (this.total_uncompressed_size !== null && this.total_uncompressed_size !== void 0) {
          output.writeFieldBegin("total_uncompressed_size", Thrift.Type.I64, 6);
          output.writeI64(this.total_uncompressed_size);
          output.writeFieldEnd();
        }
        if (this.total_compressed_size !== null && this.total_compressed_size !== void 0) {
          output.writeFieldBegin("total_compressed_size", Thrift.Type.I64, 7);
          output.writeI64(this.total_compressed_size);
          output.writeFieldEnd();
        }
        if (this.key_value_metadata !== null && this.key_value_metadata !== void 0) {
          output.writeFieldBegin("key_value_metadata", Thrift.Type.LIST, 8);
          output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
          for (var iter18 in this.key_value_metadata) {
            if (this.key_value_metadata.hasOwnProperty(iter18)) {
              iter18 = this.key_value_metadata[iter18];
              iter18.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.data_page_offset !== null && this.data_page_offset !== void 0) {
          output.writeFieldBegin("data_page_offset", Thrift.Type.I64, 9);
          output.writeI64(this.data_page_offset);
          output.writeFieldEnd();
        }
        if (this.index_page_offset !== null && this.index_page_offset !== void 0) {
          output.writeFieldBegin("index_page_offset", Thrift.Type.I64, 10);
          output.writeI64(this.index_page_offset);
          output.writeFieldEnd();
        }
        if (this.dictionary_page_offset !== null && this.dictionary_page_offset !== void 0) {
          output.writeFieldBegin("dictionary_page_offset", Thrift.Type.I64, 11);
          output.writeI64(this.dictionary_page_offset);
          output.writeFieldEnd();
        }
        if (this.statistics !== null && this.statistics !== void 0) {
          output.writeFieldBegin("statistics", Thrift.Type.STRUCT, 12);
          this.statistics.write(output);
          output.writeFieldEnd();
        }
        if (this.encoding_stats !== null && this.encoding_stats !== void 0) {
          output.writeFieldBegin("encoding_stats", Thrift.Type.LIST, 13);
          output.writeListBegin(Thrift.Type.STRUCT, this.encoding_stats.length);
          for (var iter19 in this.encoding_stats) {
            if (this.encoding_stats.hasOwnProperty(iter19)) {
              iter19 = this.encoding_stats[iter19];
              iter19.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.bloom_filter_offset !== null && this.bloom_filter_offset !== void 0) {
          output.writeFieldBegin("bloom_filter_offset", Thrift.Type.I64, 14);
          output.writeI64(this.bloom_filter_offset);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var EncryptionWithFooterKey = module.exports.EncryptionWithFooterKey = function(args) {
      };
      EncryptionWithFooterKey.prototype = {};
      EncryptionWithFooterKey.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      EncryptionWithFooterKey.prototype.write = function(output) {
        output.writeStructBegin("EncryptionWithFooterKey");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var EncryptionWithColumnKey = module.exports.EncryptionWithColumnKey = function(args) {
        this.path_in_schema = null;
        this.key_metadata = null;
        if (args) {
          if (args.path_in_schema !== void 0 && args.path_in_schema !== null) {
            this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field path_in_schema is unset!");
          }
          if (args.key_metadata !== void 0 && args.key_metadata !== null) {
            this.key_metadata = args.key_metadata;
          }
        }
      };
      EncryptionWithColumnKey.prototype = {};
      EncryptionWithColumnKey.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.LIST) {
                this.path_in_schema = [];
                var _rtmp321 = input.readListBegin();
                var _size20 = _rtmp321.size || 0;
                for (var _i22 = 0; _i22 < _size20; ++_i22) {
                  var elem23 = null;
                  elem23 = input.readString();
                  this.path_in_schema.push(elem23);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.key_metadata = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      EncryptionWithColumnKey.prototype.write = function(output) {
        output.writeStructBegin("EncryptionWithColumnKey");
        if (this.path_in_schema !== null && this.path_in_schema !== void 0) {
          output.writeFieldBegin("path_in_schema", Thrift.Type.LIST, 1);
          output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
          for (var iter24 in this.path_in_schema) {
            if (this.path_in_schema.hasOwnProperty(iter24)) {
              iter24 = this.path_in_schema[iter24];
              output.writeString(iter24);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.key_metadata !== null && this.key_metadata !== void 0) {
          output.writeFieldBegin("key_metadata", Thrift.Type.STRING, 2);
          output.writeBinary(this.key_metadata);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ColumnCryptoMetaData = module.exports.ColumnCryptoMetaData = function(args) {
        this.ENCRYPTION_WITH_FOOTER_KEY = null;
        this.ENCRYPTION_WITH_COLUMN_KEY = null;
        if (args) {
          if (args.ENCRYPTION_WITH_FOOTER_KEY !== void 0 && args.ENCRYPTION_WITH_FOOTER_KEY !== null) {
            this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey(args.ENCRYPTION_WITH_FOOTER_KEY);
          }
          if (args.ENCRYPTION_WITH_COLUMN_KEY !== void 0 && args.ENCRYPTION_WITH_COLUMN_KEY !== null) {
            this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey(args.ENCRYPTION_WITH_COLUMN_KEY);
          }
        }
      };
      ColumnCryptoMetaData.prototype = {};
      ColumnCryptoMetaData.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey();
                this.ENCRYPTION_WITH_FOOTER_KEY.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey();
                this.ENCRYPTION_WITH_COLUMN_KEY.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ColumnCryptoMetaData.prototype.write = function(output) {
        output.writeStructBegin("ColumnCryptoMetaData");
        if (this.ENCRYPTION_WITH_FOOTER_KEY !== null && this.ENCRYPTION_WITH_FOOTER_KEY !== void 0) {
          output.writeFieldBegin("ENCRYPTION_WITH_FOOTER_KEY", Thrift.Type.STRUCT, 1);
          this.ENCRYPTION_WITH_FOOTER_KEY.write(output);
          output.writeFieldEnd();
        }
        if (this.ENCRYPTION_WITH_COLUMN_KEY !== null && this.ENCRYPTION_WITH_COLUMN_KEY !== void 0) {
          output.writeFieldBegin("ENCRYPTION_WITH_COLUMN_KEY", Thrift.Type.STRUCT, 2);
          this.ENCRYPTION_WITH_COLUMN_KEY.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ColumnChunk = module.exports.ColumnChunk = function(args) {
        this.file_path = null;
        this.file_offset = null;
        this.meta_data = null;
        this.offset_index_offset = null;
        this.offset_index_length = null;
        this.column_index_offset = null;
        this.column_index_length = null;
        this.crypto_metadata = null;
        this.encrypted_column_metadata = null;
        if (args) {
          if (args.file_path !== void 0 && args.file_path !== null) {
            this.file_path = args.file_path;
          }
          if (args.file_offset !== void 0 && args.file_offset !== null) {
            this.file_offset = args.file_offset;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field file_offset is unset!");
          }
          if (args.meta_data !== void 0 && args.meta_data !== null) {
            this.meta_data = new ttypes.ColumnMetaData(args.meta_data);
          }
          if (args.offset_index_offset !== void 0 && args.offset_index_offset !== null) {
            this.offset_index_offset = args.offset_index_offset;
          }
          if (args.offset_index_length !== void 0 && args.offset_index_length !== null) {
            this.offset_index_length = args.offset_index_length;
          }
          if (args.column_index_offset !== void 0 && args.column_index_offset !== null) {
            this.column_index_offset = args.column_index_offset;
          }
          if (args.column_index_length !== void 0 && args.column_index_length !== null) {
            this.column_index_length = args.column_index_length;
          }
          if (args.crypto_metadata !== void 0 && args.crypto_metadata !== null) {
            this.crypto_metadata = new ttypes.ColumnCryptoMetaData(args.crypto_metadata);
          }
          if (args.encrypted_column_metadata !== void 0 && args.encrypted_column_metadata !== null) {
            this.encrypted_column_metadata = args.encrypted_column_metadata;
          }
        }
      };
      ColumnChunk.prototype = {};
      ColumnChunk.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRING) {
                this.file_path = input.readString();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I64) {
                this.file_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.STRUCT) {
                this.meta_data = new ttypes.ColumnMetaData();
                this.meta_data.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I64) {
                this.offset_index_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.I32) {
                this.offset_index_length = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.I64) {
                this.column_index_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.I32) {
                this.column_index_length = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.STRUCT) {
                this.crypto_metadata = new ttypes.ColumnCryptoMetaData();
                this.crypto_metadata.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 9:
              if (ftype == Thrift.Type.STRING) {
                this.encrypted_column_metadata = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ColumnChunk.prototype.write = function(output) {
        output.writeStructBegin("ColumnChunk");
        if (this.file_path !== null && this.file_path !== void 0) {
          output.writeFieldBegin("file_path", Thrift.Type.STRING, 1);
          output.writeString(this.file_path);
          output.writeFieldEnd();
        }
        if (this.file_offset !== null && this.file_offset !== void 0) {
          output.writeFieldBegin("file_offset", Thrift.Type.I64, 2);
          output.writeI64(this.file_offset);
          output.writeFieldEnd();
        }
        if (this.meta_data !== null && this.meta_data !== void 0) {
          output.writeFieldBegin("meta_data", Thrift.Type.STRUCT, 3);
          this.meta_data.write(output);
          output.writeFieldEnd();
        }
        if (this.offset_index_offset !== null && this.offset_index_offset !== void 0) {
          output.writeFieldBegin("offset_index_offset", Thrift.Type.I64, 4);
          output.writeI64(this.offset_index_offset);
          output.writeFieldEnd();
        }
        if (this.offset_index_length !== null && this.offset_index_length !== void 0) {
          output.writeFieldBegin("offset_index_length", Thrift.Type.I32, 5);
          output.writeI32(this.offset_index_length);
          output.writeFieldEnd();
        }
        if (this.column_index_offset !== null && this.column_index_offset !== void 0) {
          output.writeFieldBegin("column_index_offset", Thrift.Type.I64, 6);
          output.writeI64(this.column_index_offset);
          output.writeFieldEnd();
        }
        if (this.column_index_length !== null && this.column_index_length !== void 0) {
          output.writeFieldBegin("column_index_length", Thrift.Type.I32, 7);
          output.writeI32(this.column_index_length);
          output.writeFieldEnd();
        }
        if (this.crypto_metadata !== null && this.crypto_metadata !== void 0) {
          output.writeFieldBegin("crypto_metadata", Thrift.Type.STRUCT, 8);
          this.crypto_metadata.write(output);
          output.writeFieldEnd();
        }
        if (this.encrypted_column_metadata !== null && this.encrypted_column_metadata !== void 0) {
          output.writeFieldBegin("encrypted_column_metadata", Thrift.Type.STRING, 9);
          output.writeBinary(this.encrypted_column_metadata);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var RowGroup = module.exports.RowGroup = function(args) {
        this.columns = null;
        this.total_byte_size = null;
        this.num_rows = null;
        this.sorting_columns = null;
        this.file_offset = null;
        this.total_compressed_size = null;
        this.ordinal = null;
        if (args) {
          if (args.columns !== void 0 && args.columns !== null) {
            this.columns = Thrift.copyList(args.columns, [ttypes.ColumnChunk]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field columns is unset!");
          }
          if (args.total_byte_size !== void 0 && args.total_byte_size !== null) {
            this.total_byte_size = args.total_byte_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field total_byte_size is unset!");
          }
          if (args.num_rows !== void 0 && args.num_rows !== null) {
            this.num_rows = args.num_rows;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_rows is unset!");
          }
          if (args.sorting_columns !== void 0 && args.sorting_columns !== null) {
            this.sorting_columns = Thrift.copyList(args.sorting_columns, [ttypes.SortingColumn]);
          }
          if (args.file_offset !== void 0 && args.file_offset !== null) {
            this.file_offset = args.file_offset;
          }
          if (args.total_compressed_size !== void 0 && args.total_compressed_size !== null) {
            this.total_compressed_size = args.total_compressed_size;
          }
          if (args.ordinal !== void 0 && args.ordinal !== null) {
            this.ordinal = args.ordinal;
          }
        }
      };
      RowGroup.prototype = {};
      RowGroup.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.LIST) {
                this.columns = [];
                var _rtmp326 = input.readListBegin();
                var _size25 = _rtmp326.size || 0;
                for (var _i27 = 0; _i27 < _size25; ++_i27) {
                  var elem28 = null;
                  elem28 = new ttypes.ColumnChunk();
                  elem28.read(input);
                  this.columns.push(elem28);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I64) {
                this.total_byte_size = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I64) {
                this.num_rows = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.LIST) {
                this.sorting_columns = [];
                var _rtmp330 = input.readListBegin();
                var _size29 = _rtmp330.size || 0;
                for (var _i31 = 0; _i31 < _size29; ++_i31) {
                  var elem32 = null;
                  elem32 = new ttypes.SortingColumn();
                  elem32.read(input);
                  this.sorting_columns.push(elem32);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.I64) {
                this.file_offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.I64) {
                this.total_compressed_size = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.I16) {
                this.ordinal = input.readI16();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      RowGroup.prototype.write = function(output) {
        output.writeStructBegin("RowGroup");
        if (this.columns !== null && this.columns !== void 0) {
          output.writeFieldBegin("columns", Thrift.Type.LIST, 1);
          output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
          for (var iter33 in this.columns) {
            if (this.columns.hasOwnProperty(iter33)) {
              iter33 = this.columns[iter33];
              iter33.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.total_byte_size !== null && this.total_byte_size !== void 0) {
          output.writeFieldBegin("total_byte_size", Thrift.Type.I64, 2);
          output.writeI64(this.total_byte_size);
          output.writeFieldEnd();
        }
        if (this.num_rows !== null && this.num_rows !== void 0) {
          output.writeFieldBegin("num_rows", Thrift.Type.I64, 3);
          output.writeI64(this.num_rows);
          output.writeFieldEnd();
        }
        if (this.sorting_columns !== null && this.sorting_columns !== void 0) {
          output.writeFieldBegin("sorting_columns", Thrift.Type.LIST, 4);
          output.writeListBegin(Thrift.Type.STRUCT, this.sorting_columns.length);
          for (var iter34 in this.sorting_columns) {
            if (this.sorting_columns.hasOwnProperty(iter34)) {
              iter34 = this.sorting_columns[iter34];
              iter34.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.file_offset !== null && this.file_offset !== void 0) {
          output.writeFieldBegin("file_offset", Thrift.Type.I64, 5);
          output.writeI64(this.file_offset);
          output.writeFieldEnd();
        }
        if (this.total_compressed_size !== null && this.total_compressed_size !== void 0) {
          output.writeFieldBegin("total_compressed_size", Thrift.Type.I64, 6);
          output.writeI64(this.total_compressed_size);
          output.writeFieldEnd();
        }
        if (this.ordinal !== null && this.ordinal !== void 0) {
          output.writeFieldBegin("ordinal", Thrift.Type.I16, 7);
          output.writeI16(this.ordinal);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var TypeDefinedOrder = module.exports.TypeDefinedOrder = function(args) {
      };
      TypeDefinedOrder.prototype = {};
      TypeDefinedOrder.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          input.skip(ftype);
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      TypeDefinedOrder.prototype.write = function(output) {
        output.writeStructBegin("TypeDefinedOrder");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ColumnOrder = module.exports.ColumnOrder = function(args) {
        this.TYPE_ORDER = null;
        if (args) {
          if (args.TYPE_ORDER !== void 0 && args.TYPE_ORDER !== null) {
            this.TYPE_ORDER = new ttypes.TypeDefinedOrder(args.TYPE_ORDER);
          }
        }
      };
      ColumnOrder.prototype = {};
      ColumnOrder.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.TYPE_ORDER = new ttypes.TypeDefinedOrder();
                this.TYPE_ORDER.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 0:
              input.skip(ftype);
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ColumnOrder.prototype.write = function(output) {
        output.writeStructBegin("ColumnOrder");
        if (this.TYPE_ORDER !== null && this.TYPE_ORDER !== void 0) {
          output.writeFieldBegin("TYPE_ORDER", Thrift.Type.STRUCT, 1);
          this.TYPE_ORDER.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var PageLocation2 = module.exports.PageLocation = function(args) {
        this.offset = null;
        this.compressed_page_size = null;
        this.first_row_index = null;
        if (args) {
          if (args.offset !== void 0 && args.offset !== null) {
            this.offset = args.offset;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field offset is unset!");
          }
          if (args.compressed_page_size !== void 0 && args.compressed_page_size !== null) {
            this.compressed_page_size = args.compressed_page_size;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field compressed_page_size is unset!");
          }
          if (args.first_row_index !== void 0 && args.first_row_index !== null) {
            this.first_row_index = args.first_row_index;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field first_row_index is unset!");
          }
        }
      };
      PageLocation2.prototype = {};
      PageLocation2.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I64) {
                this.offset = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.I32) {
                this.compressed_page_size = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I64) {
                this.first_row_index = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      PageLocation2.prototype.write = function(output) {
        output.writeStructBegin("PageLocation");
        if (this.offset !== null && this.offset !== void 0) {
          output.writeFieldBegin("offset", Thrift.Type.I64, 1);
          output.writeI64(this.offset);
          output.writeFieldEnd();
        }
        if (this.compressed_page_size !== null && this.compressed_page_size !== void 0) {
          output.writeFieldBegin("compressed_page_size", Thrift.Type.I32, 2);
          output.writeI32(this.compressed_page_size);
          output.writeFieldEnd();
        }
        if (this.first_row_index !== null && this.first_row_index !== void 0) {
          output.writeFieldBegin("first_row_index", Thrift.Type.I64, 3);
          output.writeI64(this.first_row_index);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var OffsetIndex = module.exports.OffsetIndex = function(args) {
        this.page_locations = null;
        if (args) {
          if (args.page_locations !== void 0 && args.page_locations !== null) {
            this.page_locations = Thrift.copyList(args.page_locations, [ttypes.PageLocation]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field page_locations is unset!");
          }
        }
      };
      OffsetIndex.prototype = {};
      OffsetIndex.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.LIST) {
                this.page_locations = [];
                var _rtmp336 = input.readListBegin();
                var _size35 = _rtmp336.size || 0;
                for (var _i37 = 0; _i37 < _size35; ++_i37) {
                  var elem38 = null;
                  elem38 = new ttypes.PageLocation();
                  elem38.read(input);
                  this.page_locations.push(elem38);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 0:
              input.skip(ftype);
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      OffsetIndex.prototype.write = function(output) {
        output.writeStructBegin("OffsetIndex");
        if (this.page_locations !== null && this.page_locations !== void 0) {
          output.writeFieldBegin("page_locations", Thrift.Type.LIST, 1);
          output.writeListBegin(Thrift.Type.STRUCT, this.page_locations.length);
          for (var iter39 in this.page_locations) {
            if (this.page_locations.hasOwnProperty(iter39)) {
              iter39 = this.page_locations[iter39];
              iter39.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var ColumnIndex = module.exports.ColumnIndex = function(args) {
        this.null_pages = null;
        this.min_values = null;
        this.max_values = null;
        this.boundary_order = null;
        this.null_counts = null;
        if (args) {
          if (args.null_pages !== void 0 && args.null_pages !== null) {
            this.null_pages = Thrift.copyList(args.null_pages, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field null_pages is unset!");
          }
          if (args.min_values !== void 0 && args.min_values !== null) {
            this.min_values = Thrift.copyList(args.min_values, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field min_values is unset!");
          }
          if (args.max_values !== void 0 && args.max_values !== null) {
            this.max_values = Thrift.copyList(args.max_values, [null]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field max_values is unset!");
          }
          if (args.boundary_order !== void 0 && args.boundary_order !== null) {
            this.boundary_order = args.boundary_order;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field boundary_order is unset!");
          }
          if (args.null_counts !== void 0 && args.null_counts !== null) {
            this.null_counts = Thrift.copyList(args.null_counts, [null]);
          }
        }
      };
      ColumnIndex.prototype = {};
      ColumnIndex.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.LIST) {
                this.null_pages = [];
                var _rtmp341 = input.readListBegin();
                var _size40 = _rtmp341.size || 0;
                for (var _i42 = 0; _i42 < _size40; ++_i42) {
                  var elem43 = null;
                  elem43 = input.readBool();
                  this.null_pages.push(elem43);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.LIST) {
                this.min_values = [];
                var _rtmp345 = input.readListBegin();
                var _size44 = _rtmp345.size || 0;
                for (var _i46 = 0; _i46 < _size44; ++_i46) {
                  var elem47 = null;
                  elem47 = input.readBinary();
                  this.min_values.push(elem47);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.LIST) {
                this.max_values = [];
                var _rtmp349 = input.readListBegin();
                var _size48 = _rtmp349.size || 0;
                for (var _i50 = 0; _i50 < _size48; ++_i50) {
                  var elem51 = null;
                  elem51 = input.readBinary();
                  this.max_values.push(elem51);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.I32) {
                this.boundary_order = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.LIST) {
                this.null_counts = [];
                var _rtmp353 = input.readListBegin();
                var _size52 = _rtmp353.size || 0;
                for (var _i54 = 0; _i54 < _size52; ++_i54) {
                  var elem55 = null;
                  elem55 = input.readI64();
                  this.null_counts.push(elem55);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      ColumnIndex.prototype.write = function(output) {
        output.writeStructBegin("ColumnIndex");
        if (this.null_pages !== null && this.null_pages !== void 0) {
          output.writeFieldBegin("null_pages", Thrift.Type.LIST, 1);
          output.writeListBegin(Thrift.Type.BOOL, this.null_pages.length);
          for (var iter56 in this.null_pages) {
            if (this.null_pages.hasOwnProperty(iter56)) {
              iter56 = this.null_pages[iter56];
              output.writeBool(iter56);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.min_values !== null && this.min_values !== void 0) {
          output.writeFieldBegin("min_values", Thrift.Type.LIST, 2);
          output.writeListBegin(Thrift.Type.STRING, this.min_values.length);
          for (var iter57 in this.min_values) {
            if (this.min_values.hasOwnProperty(iter57)) {
              iter57 = this.min_values[iter57];
              output.writeBinary(iter57);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.max_values !== null && this.max_values !== void 0) {
          output.writeFieldBegin("max_values", Thrift.Type.LIST, 3);
          output.writeListBegin(Thrift.Type.STRING, this.max_values.length);
          for (var iter58 in this.max_values) {
            if (this.max_values.hasOwnProperty(iter58)) {
              iter58 = this.max_values[iter58];
              output.writeBinary(iter58);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.boundary_order !== null && this.boundary_order !== void 0) {
          output.writeFieldBegin("boundary_order", Thrift.Type.I32, 4);
          output.writeI32(this.boundary_order);
          output.writeFieldEnd();
        }
        if (this.null_counts !== null && this.null_counts !== void 0) {
          output.writeFieldBegin("null_counts", Thrift.Type.LIST, 5);
          output.writeListBegin(Thrift.Type.I64, this.null_counts.length);
          for (var iter59 in this.null_counts) {
            if (this.null_counts.hasOwnProperty(iter59)) {
              iter59 = this.null_counts[iter59];
              output.writeI64(iter59);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var AesGcmV1 = module.exports.AesGcmV1 = function(args) {
        this.aad_prefix = null;
        this.aad_file_unique = null;
        this.supply_aad_prefix = null;
        if (args) {
          if (args.aad_prefix !== void 0 && args.aad_prefix !== null) {
            this.aad_prefix = args.aad_prefix;
          }
          if (args.aad_file_unique !== void 0 && args.aad_file_unique !== null) {
            this.aad_file_unique = args.aad_file_unique;
          }
          if (args.supply_aad_prefix !== void 0 && args.supply_aad_prefix !== null) {
            this.supply_aad_prefix = args.supply_aad_prefix;
          }
        }
      };
      AesGcmV1.prototype = {};
      AesGcmV1.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRING) {
                this.aad_prefix = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.aad_file_unique = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.BOOL) {
                this.supply_aad_prefix = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      AesGcmV1.prototype.write = function(output) {
        output.writeStructBegin("AesGcmV1");
        if (this.aad_prefix !== null && this.aad_prefix !== void 0) {
          output.writeFieldBegin("aad_prefix", Thrift.Type.STRING, 1);
          output.writeBinary(this.aad_prefix);
          output.writeFieldEnd();
        }
        if (this.aad_file_unique !== null && this.aad_file_unique !== void 0) {
          output.writeFieldBegin("aad_file_unique", Thrift.Type.STRING, 2);
          output.writeBinary(this.aad_file_unique);
          output.writeFieldEnd();
        }
        if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== void 0) {
          output.writeFieldBegin("supply_aad_prefix", Thrift.Type.BOOL, 3);
          output.writeBool(this.supply_aad_prefix);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var AesGcmCtrV1 = module.exports.AesGcmCtrV1 = function(args) {
        this.aad_prefix = null;
        this.aad_file_unique = null;
        this.supply_aad_prefix = null;
        if (args) {
          if (args.aad_prefix !== void 0 && args.aad_prefix !== null) {
            this.aad_prefix = args.aad_prefix;
          }
          if (args.aad_file_unique !== void 0 && args.aad_file_unique !== null) {
            this.aad_file_unique = args.aad_file_unique;
          }
          if (args.supply_aad_prefix !== void 0 && args.supply_aad_prefix !== null) {
            this.supply_aad_prefix = args.supply_aad_prefix;
          }
        }
      };
      AesGcmCtrV1.prototype = {};
      AesGcmCtrV1.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRING) {
                this.aad_prefix = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.aad_file_unique = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.BOOL) {
                this.supply_aad_prefix = input.readBool();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      AesGcmCtrV1.prototype.write = function(output) {
        output.writeStructBegin("AesGcmCtrV1");
        if (this.aad_prefix !== null && this.aad_prefix !== void 0) {
          output.writeFieldBegin("aad_prefix", Thrift.Type.STRING, 1);
          output.writeBinary(this.aad_prefix);
          output.writeFieldEnd();
        }
        if (this.aad_file_unique !== null && this.aad_file_unique !== void 0) {
          output.writeFieldBegin("aad_file_unique", Thrift.Type.STRING, 2);
          output.writeBinary(this.aad_file_unique);
          output.writeFieldEnd();
        }
        if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== void 0) {
          output.writeFieldBegin("supply_aad_prefix", Thrift.Type.BOOL, 3);
          output.writeBool(this.supply_aad_prefix);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var EncryptionAlgorithm = module.exports.EncryptionAlgorithm = function(args) {
        this.AES_GCM_V1 = null;
        this.AES_GCM_CTR_V1 = null;
        if (args) {
          if (args.AES_GCM_V1 !== void 0 && args.AES_GCM_V1 !== null) {
            this.AES_GCM_V1 = new ttypes.AesGcmV1(args.AES_GCM_V1);
          }
          if (args.AES_GCM_CTR_V1 !== void 0 && args.AES_GCM_CTR_V1 !== null) {
            this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1(args.AES_GCM_CTR_V1);
          }
        }
      };
      EncryptionAlgorithm.prototype = {};
      EncryptionAlgorithm.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.AES_GCM_V1 = new ttypes.AesGcmV1();
                this.AES_GCM_V1.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRUCT) {
                this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1();
                this.AES_GCM_CTR_V1.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      EncryptionAlgorithm.prototype.write = function(output) {
        output.writeStructBegin("EncryptionAlgorithm");
        if (this.AES_GCM_V1 !== null && this.AES_GCM_V1 !== void 0) {
          output.writeFieldBegin("AES_GCM_V1", Thrift.Type.STRUCT, 1);
          this.AES_GCM_V1.write(output);
          output.writeFieldEnd();
        }
        if (this.AES_GCM_CTR_V1 !== null && this.AES_GCM_CTR_V1 !== void 0) {
          output.writeFieldBegin("AES_GCM_CTR_V1", Thrift.Type.STRUCT, 2);
          this.AES_GCM_CTR_V1.write(output);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var FileMetaData = module.exports.FileMetaData = function(args) {
        this.version = null;
        this.schema = null;
        this.num_rows = null;
        this.row_groups = null;
        this.key_value_metadata = null;
        this.created_by = null;
        this.column_orders = null;
        this.encryption_algorithm = null;
        this.footer_signing_key_metadata = null;
        if (args) {
          if (args.version !== void 0 && args.version !== null) {
            this.version = args.version;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field version is unset!");
          }
          if (args.schema !== void 0 && args.schema !== null) {
            this.schema = Thrift.copyList(args.schema, [ttypes.SchemaElement]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field schema is unset!");
          }
          if (args.num_rows !== void 0 && args.num_rows !== null) {
            this.num_rows = args.num_rows;
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field num_rows is unset!");
          }
          if (args.row_groups !== void 0 && args.row_groups !== null) {
            this.row_groups = Thrift.copyList(args.row_groups, [ttypes.RowGroup]);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field row_groups is unset!");
          }
          if (args.key_value_metadata !== void 0 && args.key_value_metadata !== null) {
            this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
          }
          if (args.created_by !== void 0 && args.created_by !== null) {
            this.created_by = args.created_by;
          }
          if (args.column_orders !== void 0 && args.column_orders !== null) {
            this.column_orders = Thrift.copyList(args.column_orders, [ttypes.ColumnOrder]);
          }
          if (args.encryption_algorithm !== void 0 && args.encryption_algorithm !== null) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
          }
          if (args.footer_signing_key_metadata !== void 0 && args.footer_signing_key_metadata !== null) {
            this.footer_signing_key_metadata = args.footer_signing_key_metadata;
          }
        }
      };
      FileMetaData.prototype = {};
      FileMetaData.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.I32) {
                this.version = input.readI32();
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.LIST) {
                this.schema = [];
                var _rtmp361 = input.readListBegin();
                var _size60 = _rtmp361.size || 0;
                for (var _i62 = 0; _i62 < _size60; ++_i62) {
                  var elem63 = null;
                  elem63 = new ttypes.SchemaElement();
                  elem63.read(input);
                  this.schema.push(elem63);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 3:
              if (ftype == Thrift.Type.I64) {
                this.num_rows = input.readI64();
              } else {
                input.skip(ftype);
              }
              break;
            case 4:
              if (ftype == Thrift.Type.LIST) {
                this.row_groups = [];
                var _rtmp365 = input.readListBegin();
                var _size64 = _rtmp365.size || 0;
                for (var _i66 = 0; _i66 < _size64; ++_i66) {
                  var elem67 = null;
                  elem67 = new ttypes.RowGroup();
                  elem67.read(input);
                  this.row_groups.push(elem67);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 5:
              if (ftype == Thrift.Type.LIST) {
                this.key_value_metadata = [];
                var _rtmp369 = input.readListBegin();
                var _size68 = _rtmp369.size || 0;
                for (var _i70 = 0; _i70 < _size68; ++_i70) {
                  var elem71 = null;
                  elem71 = new ttypes.KeyValue();
                  elem71.read(input);
                  this.key_value_metadata.push(elem71);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 6:
              if (ftype == Thrift.Type.STRING) {
                this.created_by = input.readString();
              } else {
                input.skip(ftype);
              }
              break;
            case 7:
              if (ftype == Thrift.Type.LIST) {
                this.column_orders = [];
                var _rtmp373 = input.readListBegin();
                var _size72 = _rtmp373.size || 0;
                for (var _i74 = 0; _i74 < _size72; ++_i74) {
                  var elem75 = null;
                  elem75 = new ttypes.ColumnOrder();
                  elem75.read(input);
                  this.column_orders.push(elem75);
                }
                input.readListEnd();
              } else {
                input.skip(ftype);
              }
              break;
            case 8:
              if (ftype == Thrift.Type.STRUCT) {
                this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
                this.encryption_algorithm.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 9:
              if (ftype == Thrift.Type.STRING) {
                this.footer_signing_key_metadata = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      FileMetaData.prototype.write = function(output) {
        output.writeStructBegin("FileMetaData");
        if (this.version !== null && this.version !== void 0) {
          output.writeFieldBegin("version", Thrift.Type.I32, 1);
          output.writeI32(this.version);
          output.writeFieldEnd();
        }
        if (this.schema !== null && this.schema !== void 0) {
          output.writeFieldBegin("schema", Thrift.Type.LIST, 2);
          output.writeListBegin(Thrift.Type.STRUCT, this.schema.length);
          for (var iter76 in this.schema) {
            if (this.schema.hasOwnProperty(iter76)) {
              iter76 = this.schema[iter76];
              iter76.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.num_rows !== null && this.num_rows !== void 0) {
          output.writeFieldBegin("num_rows", Thrift.Type.I64, 3);
          output.writeI64(this.num_rows);
          output.writeFieldEnd();
        }
        if (this.row_groups !== null && this.row_groups !== void 0) {
          output.writeFieldBegin("row_groups", Thrift.Type.LIST, 4);
          output.writeListBegin(Thrift.Type.STRUCT, this.row_groups.length);
          for (var iter77 in this.row_groups) {
            if (this.row_groups.hasOwnProperty(iter77)) {
              iter77 = this.row_groups[iter77];
              iter77.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.key_value_metadata !== null && this.key_value_metadata !== void 0) {
          output.writeFieldBegin("key_value_metadata", Thrift.Type.LIST, 5);
          output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
          for (var iter78 in this.key_value_metadata) {
            if (this.key_value_metadata.hasOwnProperty(iter78)) {
              iter78 = this.key_value_metadata[iter78];
              iter78.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.created_by !== null && this.created_by !== void 0) {
          output.writeFieldBegin("created_by", Thrift.Type.STRING, 6);
          output.writeString(this.created_by);
          output.writeFieldEnd();
        }
        if (this.column_orders !== null && this.column_orders !== void 0) {
          output.writeFieldBegin("column_orders", Thrift.Type.LIST, 7);
          output.writeListBegin(Thrift.Type.STRUCT, this.column_orders.length);
          for (var iter79 in this.column_orders) {
            if (this.column_orders.hasOwnProperty(iter79)) {
              iter79 = this.column_orders[iter79];
              iter79.write(output);
            }
          }
          output.writeListEnd();
          output.writeFieldEnd();
        }
        if (this.encryption_algorithm !== null && this.encryption_algorithm !== void 0) {
          output.writeFieldBegin("encryption_algorithm", Thrift.Type.STRUCT, 8);
          this.encryption_algorithm.write(output);
          output.writeFieldEnd();
        }
        if (this.footer_signing_key_metadata !== null && this.footer_signing_key_metadata !== void 0) {
          output.writeFieldBegin("footer_signing_key_metadata", Thrift.Type.STRING, 9);
          output.writeBinary(this.footer_signing_key_metadata);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
      var FileCryptoMetaData = module.exports.FileCryptoMetaData = function(args) {
        this.encryption_algorithm = null;
        this.key_metadata = null;
        if (args) {
          if (args.encryption_algorithm !== void 0 && args.encryption_algorithm !== null) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
          } else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field encryption_algorithm is unset!");
          }
          if (args.key_metadata !== void 0 && args.key_metadata !== null) {
            this.key_metadata = args.key_metadata;
          }
        }
      };
      FileCryptoMetaData.prototype = {};
      FileCryptoMetaData.prototype.read = function(input) {
        input.readStructBegin();
        while (true) {
          var ret = input.readFieldBegin();
          var ftype = ret.ftype;
          var fid = ret.fid;
          if (ftype == Thrift.Type.STOP) {
            break;
          }
          switch (fid) {
            case 1:
              if (ftype == Thrift.Type.STRUCT) {
                this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
                this.encryption_algorithm.read(input);
              } else {
                input.skip(ftype);
              }
              break;
            case 2:
              if (ftype == Thrift.Type.STRING) {
                this.key_metadata = input.readBinary();
              } else {
                input.skip(ftype);
              }
              break;
            default:
              input.skip(ftype);
          }
          input.readFieldEnd();
        }
        input.readStructEnd();
        return;
      };
      FileCryptoMetaData.prototype.write = function(output) {
        output.writeStructBegin("FileCryptoMetaData");
        if (this.encryption_algorithm !== null && this.encryption_algorithm !== void 0) {
          output.writeFieldBegin("encryption_algorithm", Thrift.Type.STRUCT, 1);
          this.encryption_algorithm.write(output);
          output.writeFieldEnd();
        }
        if (this.key_metadata !== null && this.key_metadata !== void 0) {
          output.writeFieldBegin("key_metadata", Thrift.Type.STRING, 2);
          output.writeBinary(this.key_metadata);
          output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
      };
    }
  });

  // node_modules/bson/lib/bson.cjs
  var require_bson = __commonJS({
    "node_modules/bson/lib/bson.cjs"(exports) {
      "use strict";
      init_esbuild_shims();
      function isAnyArrayBuffer(value) {
        return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value));
      }
      function isUint8Array(value) {
        return Object.prototype.toString.call(value) === "[object Uint8Array]";
      }
      function isRegExp(d) {
        return Object.prototype.toString.call(d) === "[object RegExp]";
      }
      function isMap(d) {
        return Object.prototype.toString.call(d) === "[object Map]";
      }
      function isDate(d) {
        return Object.prototype.toString.call(d) === "[object Date]";
      }
      function defaultInspect(x, _options) {
        return JSON.stringify(x, (k, v) => {
          if (typeof v === "bigint") {
            return { $numberLong: `${v}` };
          } else if (isMap(v)) {
            return Object.fromEntries(v);
          }
          return v;
        });
      }
      function getStylizeFunction(options) {
        const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
        if (stylizeExists) {
          return options.stylize;
        }
      }
      var BSON_MAJOR_VERSION = 6;
      var BSON_INT32_MAX = 2147483647;
      var BSON_INT32_MIN = -2147483648;
      var BSON_INT64_MAX = Math.pow(2, 63) - 1;
      var BSON_INT64_MIN = -Math.pow(2, 63);
      var JS_INT_MAX = Math.pow(2, 53);
      var JS_INT_MIN = -Math.pow(2, 53);
      var BSON_DATA_NUMBER = 1;
      var BSON_DATA_STRING = 2;
      var BSON_DATA_OBJECT = 3;
      var BSON_DATA_ARRAY = 4;
      var BSON_DATA_BINARY = 5;
      var BSON_DATA_UNDEFINED = 6;
      var BSON_DATA_OID = 7;
      var BSON_DATA_BOOLEAN = 8;
      var BSON_DATA_DATE = 9;
      var BSON_DATA_NULL = 10;
      var BSON_DATA_REGEXP = 11;
      var BSON_DATA_DBPOINTER = 12;
      var BSON_DATA_CODE = 13;
      var BSON_DATA_SYMBOL = 14;
      var BSON_DATA_CODE_W_SCOPE = 15;
      var BSON_DATA_INT = 16;
      var BSON_DATA_TIMESTAMP = 17;
      var BSON_DATA_LONG = 18;
      var BSON_DATA_DECIMAL128 = 19;
      var BSON_DATA_MIN_KEY = 255;
      var BSON_DATA_MAX_KEY = 127;
      var BSON_BINARY_SUBTYPE_DEFAULT = 0;
      var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
      var BSONType = Object.freeze({
        double: 1,
        string: 2,
        object: 3,
        array: 4,
        binData: 5,
        undefined: 6,
        objectId: 7,
        bool: 8,
        date: 9,
        null: 10,
        regex: 11,
        dbPointer: 12,
        javascript: 13,
        symbol: 14,
        javascriptWithScope: 15,
        int: 16,
        timestamp: 17,
        long: 18,
        decimal: 19,
        minKey: -1,
        maxKey: 127
      });
      var BSONError = class extends Error {
        get bsonError() {
          return true;
        }
        get name() {
          return "BSONError";
        }
        constructor(message, options) {
          super(message, options);
        }
        static isBSONError(value) {
          return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
        }
      };
      var BSONVersionError = class extends BSONError {
        get name() {
          return "BSONVersionError";
        }
        constructor() {
          super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
        }
      };
      var BSONRuntimeError = class extends BSONError {
        get name() {
          return "BSONRuntimeError";
        }
        constructor(message) {
          super(message);
        }
      };
      var BSONOffsetError = class extends BSONError {
        get name() {
          return "BSONOffsetError";
        }
        constructor(message, offset, options) {
          super(`${message}. offset: ${offset}`, options);
          this.offset = offset;
        }
      };
      var TextDecoderFatal;
      var TextDecoderNonFatal;
      function parseUtf8(buffer3, start, end, fatal) {
        if (fatal) {
          TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
          try {
            return TextDecoderFatal.decode(buffer3.subarray(start, end));
          } catch (cause) {
            throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
          }
        }
        TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
        return TextDecoderNonFatal.decode(buffer3.subarray(start, end));
      }
      function tryReadBasicLatin(uint8array, start, end) {
        if (uint8array.length === 0) {
          return "";
        }
        const stringByteLength = end - start;
        if (stringByteLength === 0) {
          return "";
        }
        if (stringByteLength > 20) {
          return null;
        }
        if (stringByteLength === 1 && uint8array[start] < 128) {
          return String.fromCharCode(uint8array[start]);
        }
        if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
          return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
        }
        if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
          return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
        }
        const latinBytes = [];
        for (let i = start; i < end; i++) {
          const byte = uint8array[i];
          if (byte > 127) {
            return null;
          }
          latinBytes.push(byte);
        }
        return String.fromCharCode(...latinBytes);
      }
      function tryWriteBasicLatin(destination, source, offset) {
        if (source.length === 0)
          return 0;
        if (source.length > 25)
          return null;
        if (destination.length - offset < source.length)
          return null;
        for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
          const char = source.charCodeAt(charOffset);
          if (char > 127)
            return null;
          destination[destinationOffset] = char;
        }
        return source.length;
      }
      function nodejsMathRandomBytes(byteLength) {
        return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
      }
      var nodejsRandomBytes = (() => {
        try {
          return __require("crypto").randomBytes;
        } catch {
          return nodejsMathRandomBytes;
        }
      })();
      var nodeJsByteUtils = {
        toLocalBufferType(potentialBuffer) {
          if (Buffer2.isBuffer(potentialBuffer)) {
            return potentialBuffer;
          }
          if (ArrayBuffer.isView(potentialBuffer)) {
            return Buffer2.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
          }
          const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
          if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
            return Buffer2.from(potentialBuffer);
          }
          throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);
        },
        allocate(size) {
          return Buffer2.alloc(size);
        },
        allocateUnsafe(size) {
          return Buffer2.allocUnsafe(size);
        },
        equals(a, b) {
          return nodeJsByteUtils.toLocalBufferType(a).equals(b);
        },
        fromNumberArray(array) {
          return Buffer2.from(array);
        },
        fromBase64(base64) {
          return Buffer2.from(base64, "base64");
        },
        toBase64(buffer3) {
          return nodeJsByteUtils.toLocalBufferType(buffer3).toString("base64");
        },
        fromISO88591(codePoints) {
          return Buffer2.from(codePoints, "binary");
        },
        toISO88591(buffer3) {
          return nodeJsByteUtils.toLocalBufferType(buffer3).toString("binary");
        },
        fromHex(hex) {
          return Buffer2.from(hex, "hex");
        },
        toHex(buffer3) {
          return nodeJsByteUtils.toLocalBufferType(buffer3).toString("hex");
        },
        toUTF8(buffer3, start, end, fatal) {
          const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer3, start, end) : null;
          if (basicLatin != null) {
            return basicLatin;
          }
          const string = nodeJsByteUtils.toLocalBufferType(buffer3).toString("utf8", start, end);
          if (fatal) {
            for (let i = 0; i < string.length; i++) {
              if (string.charCodeAt(i) === 65533) {
                parseUtf8(buffer3, start, end, true);
                break;
              }
            }
          }
          return string;
        },
        utf8ByteLength(input) {
          return Buffer2.byteLength(input, "utf8");
        },
        encodeUTF8Into(buffer3, source, byteOffset) {
          const latinBytesWritten = tryWriteBasicLatin(buffer3, source, byteOffset);
          if (latinBytesWritten != null) {
            return latinBytesWritten;
          }
          return nodeJsByteUtils.toLocalBufferType(buffer3).write(source, byteOffset, void 0, "utf8");
        },
        randomBytes: nodejsRandomBytes
      };
      function isReactNative() {
        const { navigator: navigator2 } = globalThis;
        return typeof navigator2 === "object" && navigator2.product === "ReactNative";
      }
      function webMathRandomBytes(byteLength) {
        if (byteLength < 0) {
          throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
        }
        return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
      }
      var webRandomBytes = (() => {
        const { crypto } = globalThis;
        if (crypto != null && typeof crypto.getRandomValues === "function") {
          return (byteLength) => {
            return crypto.getRandomValues(webByteUtils.allocate(byteLength));
          };
        } else {
          if (isReactNative()) {
            const { console: console2 } = globalThis;
            console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
          }
          return webMathRandomBytes;
        }
      })();
      var HEX_DIGIT = /(\d|[a-f])/i;
      var webByteUtils = {
        toLocalBufferType(potentialUint8array) {
          const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
          if (stringTag === "Uint8Array") {
            return potentialUint8array;
          }
          if (ArrayBuffer.isView(potentialUint8array)) {
            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
          }
          if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
            return new Uint8Array(potentialUint8array);
          }
          throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);
        },
        allocate(size) {
          if (typeof size !== "number") {
            throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
          }
          return new Uint8Array(size);
        },
        allocateUnsafe(size) {
          return webByteUtils.allocate(size);
        },
        equals(a, b) {
          if (a.byteLength !== b.byteLength) {
            return false;
          }
          for (let i = 0; i < a.byteLength; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        },
        fromNumberArray(array) {
          return Uint8Array.from(array);
        },
        fromBase64(base64) {
          return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
        },
        toBase64(uint8array) {
          return btoa(webByteUtils.toISO88591(uint8array));
        },
        fromISO88591(codePoints) {
          return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
        },
        toISO88591(uint8array) {
          return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
        },
        fromHex(hex) {
          const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
          const buffer3 = [];
          for (let i = 0; i < evenLengthHex.length; i += 2) {
            const firstDigit = evenLengthHex[i];
            const secondDigit = evenLengthHex[i + 1];
            if (!HEX_DIGIT.test(firstDigit)) {
              break;
            }
            if (!HEX_DIGIT.test(secondDigit)) {
              break;
            }
            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
            buffer3.push(hexDigit);
          }
          return Uint8Array.from(buffer3);
        },
        toHex(uint8array) {
          return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
        },
        toUTF8(uint8array, start, end, fatal) {
          const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
          if (basicLatin != null) {
            return basicLatin;
          }
          return parseUtf8(uint8array, start, end, fatal);
        },
        utf8ByteLength(input) {
          return new TextEncoder().encode(input).byteLength;
        },
        encodeUTF8Into(uint8array, source, byteOffset) {
          const bytes = new TextEncoder().encode(source);
          uint8array.set(bytes, byteOffset);
          return bytes.byteLength;
        },
        randomBytes: webRandomBytes
      };
      var hasGlobalBuffer = typeof Buffer2 === "function" && Buffer2.prototype?._isBuffer !== true;
      var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
      var BSONValue = class {
        get [Symbol.for("@@mdb.bson.version")]() {
          return BSON_MAJOR_VERSION;
        }
        [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
          return this.inspect(depth, options, inspect);
        }
      };
      var Binary = class _Binary extends BSONValue {
        get _bsontype() {
          return "Binary";
        }
        constructor(buffer3, subType) {
          super();
          if (!(buffer3 == null) && typeof buffer3 === "string" && !ArrayBuffer.isView(buffer3) && !isAnyArrayBuffer(buffer3) && !Array.isArray(buffer3)) {
            throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
          }
          this.sub_type = subType ?? _Binary.BSON_BINARY_SUBTYPE_DEFAULT;
          if (buffer3 == null) {
            this.buffer = ByteUtils.allocate(_Binary.BUFFER_SIZE);
            this.position = 0;
          } else {
            this.buffer = Array.isArray(buffer3) ? ByteUtils.fromNumberArray(buffer3) : ByteUtils.toLocalBufferType(buffer3);
            this.position = this.buffer.byteLength;
          }
        }
        put(byteValue) {
          if (typeof byteValue === "string" && byteValue.length !== 1) {
            throw new BSONError("only accepts single character String");
          } else if (typeof byteValue !== "number" && byteValue.length !== 1)
            throw new BSONError("only accepts single character Uint8Array or Array");
          let decodedByte;
          if (typeof byteValue === "string") {
            decodedByte = byteValue.charCodeAt(0);
          } else if (typeof byteValue === "number") {
            decodedByte = byteValue;
          } else {
            decodedByte = byteValue[0];
          }
          if (decodedByte < 0 || decodedByte > 255) {
            throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
          }
          if (this.buffer.byteLength > this.position) {
            this.buffer[this.position++] = decodedByte;
          } else {
            const newSpace = ByteUtils.allocate(_Binary.BUFFER_SIZE + this.buffer.length);
            newSpace.set(this.buffer, 0);
            this.buffer = newSpace;
            this.buffer[this.position++] = decodedByte;
          }
        }
        write(sequence, offset) {
          offset = typeof offset === "number" ? offset : this.position;
          if (this.buffer.byteLength < offset + sequence.length) {
            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
            newSpace.set(this.buffer, 0);
            this.buffer = newSpace;
          }
          if (ArrayBuffer.isView(sequence)) {
            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
          } else if (typeof sequence === "string") {
            throw new BSONError("input cannot be string");
          }
        }
        read(position, length) {
          length = length && length > 0 ? length : this.position;
          return this.buffer.slice(position, position + length);
        }
        value() {
          return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
        }
        length() {
          return this.position;
        }
        toJSON() {
          return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        }
        toString(encoding) {
          if (encoding === "hex")
            return ByteUtils.toHex(this.buffer.subarray(0, this.position));
          if (encoding === "base64")
            return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
          if (encoding === "utf8" || encoding === "utf-8")
            return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
          return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
        }
        toExtendedJSON(options) {
          options = options || {};
          const base64String = ByteUtils.toBase64(this.buffer);
          const subType = Number(this.sub_type).toString(16);
          if (options.legacy) {
            return {
              $binary: base64String,
              $type: subType.length === 1 ? "0" + subType : subType
            };
          }
          return {
            $binary: {
              base64: base64String,
              subType: subType.length === 1 ? "0" + subType : subType
            }
          };
        }
        toUUID() {
          if (this.sub_type === _Binary.SUBTYPE_UUID) {
            return new UUID(this.buffer.slice(0, this.position));
          }
          throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`);
        }
        static createFromHexString(hex, subType) {
          return new _Binary(ByteUtils.fromHex(hex), subType);
        }
        static createFromBase64(base64, subType) {
          return new _Binary(ByteUtils.fromBase64(base64), subType);
        }
        static fromExtendedJSON(doc, options) {
          options = options || {};
          let data;
          let type;
          if ("$binary" in doc) {
            if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
              type = doc.$type ? parseInt(doc.$type, 16) : 0;
              data = ByteUtils.fromBase64(doc.$binary);
            } else {
              if (typeof doc.$binary !== "string") {
                type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
                data = ByteUtils.fromBase64(doc.$binary.base64);
              }
            }
          } else if ("$uuid" in doc) {
            type = 4;
            data = UUID.bytesFromString(doc.$uuid);
          }
          if (!data) {
            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
          }
          return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new _Binary(data, type);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
          const base64Arg = inspect(base64, options);
          const subTypeArg = inspect(this.sub_type, options);
          return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
        }
      };
      Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
      Binary.BUFFER_SIZE = 256;
      Binary.SUBTYPE_DEFAULT = 0;
      Binary.SUBTYPE_FUNCTION = 1;
      Binary.SUBTYPE_BYTE_ARRAY = 2;
      Binary.SUBTYPE_UUID_OLD = 3;
      Binary.SUBTYPE_UUID = 4;
      Binary.SUBTYPE_MD5 = 5;
      Binary.SUBTYPE_ENCRYPTED = 6;
      Binary.SUBTYPE_COLUMN = 7;
      Binary.SUBTYPE_SENSITIVE = 8;
      Binary.SUBTYPE_USER_DEFINED = 128;
      var UUID_BYTE_LENGTH = 16;
      var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
      var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
      var UUID = class _UUID extends Binary {
        constructor(input) {
          let bytes;
          if (input == null) {
            bytes = _UUID.generate();
          } else if (input instanceof _UUID) {
            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
          } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
            bytes = ByteUtils.toLocalBufferType(input);
          } else if (typeof input === "string") {
            bytes = _UUID.bytesFromString(input);
          } else {
            throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
          }
          super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
        }
        get id() {
          return this.buffer;
        }
        set id(value) {
          this.buffer = value;
        }
        toHexString(includeDashes = true) {
          if (includeDashes) {
            return [
              ByteUtils.toHex(this.buffer.subarray(0, 4)),
              ByteUtils.toHex(this.buffer.subarray(4, 6)),
              ByteUtils.toHex(this.buffer.subarray(6, 8)),
              ByteUtils.toHex(this.buffer.subarray(8, 10)),
              ByteUtils.toHex(this.buffer.subarray(10, 16))
            ].join("-");
          }
          return ByteUtils.toHex(this.buffer);
        }
        toString(encoding) {
          if (encoding === "hex")
            return ByteUtils.toHex(this.id);
          if (encoding === "base64")
            return ByteUtils.toBase64(this.id);
          return this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        equals(otherId) {
          if (!otherId) {
            return false;
          }
          if (otherId instanceof _UUID) {
            return ByteUtils.equals(otherId.id, this.id);
          }
          try {
            return ByteUtils.equals(new _UUID(otherId).id, this.id);
          } catch {
            return false;
          }
        }
        toBinary() {
          return new Binary(this.id, Binary.SUBTYPE_UUID);
        }
        static generate() {
          const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
          bytes[6] = bytes[6] & 15 | 64;
          bytes[8] = bytes[8] & 63 | 128;
          return bytes;
        }
        static isValid(input) {
          if (!input) {
            return false;
          }
          if (typeof input === "string") {
            return _UUID.isValidUUIDString(input);
          }
          if (isUint8Array(input)) {
            return input.byteLength === UUID_BYTE_LENGTH;
          }
          return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
        }
        static createFromHexString(hexString) {
          const buffer3 = _UUID.bytesFromString(hexString);
          return new _UUID(buffer3);
        }
        static createFromBase64(base64) {
          return new _UUID(ByteUtils.fromBase64(base64));
        }
        static bytesFromString(representation) {
          if (!_UUID.isValidUUIDString(representation)) {
            throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
          }
          return ByteUtils.fromHex(representation.replace(/-/g, ""));
        }
        static isValidUUIDString(representation) {
          return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          return `new UUID(${inspect(this.toHexString(), options)})`;
        }
      };
      var Code = class _Code extends BSONValue {
        get _bsontype() {
          return "Code";
        }
        constructor(code, scope) {
          super();
          this.code = code.toString();
          this.scope = scope ?? null;
        }
        toJSON() {
          if (this.scope != null) {
            return { code: this.code, scope: this.scope };
          }
          return { code: this.code };
        }
        toExtendedJSON() {
          if (this.scope) {
            return { $code: this.code, $scope: this.scope };
          }
          return { $code: this.code };
        }
        static fromExtendedJSON(doc) {
          return new _Code(doc.$code, doc.$scope);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          let parametersString = inspect(this.code, options);
          const multiLineFn = parametersString.includes("\n");
          if (this.scope != null) {
            parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options)}`;
          }
          const endingNewline = multiLineFn && this.scope === null;
          return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
        }
      };
      function isDBRefLike(value) {
        return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || "$db" in value && typeof value.$db === "string");
      }
      var DBRef = class _DBRef extends BSONValue {
        get _bsontype() {
          return "DBRef";
        }
        constructor(collection, oid, db, fields) {
          super();
          const parts = collection.split(".");
          if (parts.length === 2) {
            db = parts.shift();
            collection = parts.shift();
          }
          this.collection = collection;
          this.oid = oid;
          this.db = db;
          this.fields = fields || {};
        }
        get namespace() {
          return this.collection;
        }
        set namespace(value) {
          this.collection = value;
        }
        toJSON() {
          const o = Object.assign({
            $ref: this.collection,
            $id: this.oid
          }, this.fields);
          if (this.db != null)
            o.$db = this.db;
          return o;
        }
        toExtendedJSON(options) {
          options = options || {};
          let o = {
            $ref: this.collection,
            $id: this.oid
          };
          if (options.legacy) {
            return o;
          }
          if (this.db)
            o.$db = this.db;
          o = Object.assign(o, this.fields);
          return o;
        }
        static fromExtendedJSON(doc) {
          const copy = Object.assign({}, doc);
          delete copy.$ref;
          delete copy.$id;
          delete copy.$db;
          return new _DBRef(doc.$ref, doc.$id, doc.$db, copy);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          const args = [
            inspect(this.namespace, options),
            inspect(this.oid, options),
            ...this.db ? [inspect(this.db, options)] : [],
            ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
          ];
          args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
          return `new DBRef(${args.join(", ")})`;
        }
      };
      function removeLeadingZerosAndExplicitPlus(str) {
        if (str === "") {
          return str;
        }
        let startIndex = 0;
        const isNegative2 = str[startIndex] === "-";
        const isExplicitlyPositive = str[startIndex] === "+";
        if (isExplicitlyPositive || isNegative2) {
          startIndex += 1;
        }
        let foundInsignificantZero = false;
        for (; startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
          foundInsignificantZero = true;
        }
        if (!foundInsignificantZero) {
          return isExplicitlyPositive ? str.slice(1) : str;
        }
        return `${isNegative2 ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
      }
      function validateStringCharacters(str, radix) {
        radix = radix ?? 10;
        const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
        const regex2 = new RegExp(`[^-+${validCharacters}]`, "i");
        return regex2.test(str) ? false : str;
      }
      var wasm2 = void 0;
      try {
        wasm2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch {
      }
      var TWO_PWR_16_DBL2 = 1 << 16;
      var TWO_PWR_24_DBL2 = 1 << 24;
      var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
      var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
      var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
      var INT_CACHE2 = {};
      var UINT_CACHE2 = {};
      var MAX_INT64_STRING_LENGTH = 20;
      var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
      var Long2 = class _Long extends BSONValue {
        get _bsontype() {
          return "Long";
        }
        get __isLong__() {
          return true;
        }
        constructor(low = 0, high, unsigned) {
          super();
          if (typeof low === "bigint") {
            Object.assign(this, _Long.fromBigInt(low, !!high));
          } else if (typeof low === "string") {
            Object.assign(this, _Long.fromString(low, !!high));
          } else {
            this.low = low | 0;
            this.high = high | 0;
            this.unsigned = !!unsigned;
          }
        }
        static fromBits(lowBits, highBits, unsigned) {
          return new _Long(lowBits, highBits, unsigned);
        }
        static fromInt(value, unsigned) {
          let obj, cachedObj, cache;
          if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = _Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
              UINT_CACHE2[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = _Long.fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
              INT_CACHE2[value] = obj;
            return obj;
          }
        }
        static fromNumber(value, unsigned) {
          if (isNaN(value))
            return unsigned ? _Long.UZERO : _Long.ZERO;
          if (unsigned) {
            if (value < 0)
              return _Long.UZERO;
            if (value >= TWO_PWR_64_DBL2)
              return _Long.MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL2)
              return _Long.MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL2)
              return _Long.MAX_VALUE;
          }
          if (value < 0)
            return _Long.fromNumber(-value, unsigned).neg();
          return _Long.fromBits(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
        }
        static fromBigInt(value, unsigned) {
          return _Long.fromString(value.toString(), unsigned);
        }
        static _fromString(str, unsigned, radix) {
          if (str.length === 0)
            throw new BSONError("empty string");
          if (radix < 2 || 36 < radix)
            throw new BSONError("radix");
          let p;
          if ((p = str.indexOf("-")) > 0)
            throw new BSONError("interior hyphen");
          else if (p === 0) {
            return _Long._fromString(str.substring(1), unsigned, radix).neg();
          }
          const radixToPower = _Long.fromNumber(Math.pow(radix, 8));
          let result = _Long.ZERO;
          for (let i = 0; i < str.length; i += 8) {
            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
              const power = _Long.fromNumber(Math.pow(radix, size));
              result = result.mul(power).add(_Long.fromNumber(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(_Long.fromNumber(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        static fromStringStrict(str, unsignedOrRadix, radix) {
          let unsigned = false;
          if (typeof unsignedOrRadix === "number") {
            radix = unsignedOrRadix, unsignedOrRadix = false;
          } else {
            unsigned = !!unsignedOrRadix;
          }
          radix ??= 10;
          if (str.trim() !== str) {
            throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
          }
          if (!validateStringCharacters(str, radix)) {
            throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
          }
          const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
          const result = _Long._fromString(cleanedStr, unsigned, radix);
          if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
            throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
          }
          return result;
        }
        static fromString(str, unsignedOrRadix, radix) {
          let unsigned = false;
          if (typeof unsignedOrRadix === "number") {
            radix = unsignedOrRadix, unsignedOrRadix = false;
          } else {
            unsigned = !!unsignedOrRadix;
          }
          radix ??= 10;
          if (str === "NaN" && radix < 24) {
            return _Long.ZERO;
          } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
            return _Long.ZERO;
          }
          return _Long._fromString(str, unsigned, radix);
        }
        static fromBytes(bytes, unsigned, le) {
          return le ? _Long.fromBytesLE(bytes, unsigned) : _Long.fromBytesBE(bytes, unsigned);
        }
        static fromBytesLE(bytes, unsigned) {
          return new _Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
        }
        static fromBytesBE(bytes, unsigned) {
          return new _Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
        }
        static isLong(value) {
          return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
        }
        static fromValue(val2, unsigned) {
          if (typeof val2 === "number")
            return _Long.fromNumber(val2, unsigned);
          if (typeof val2 === "string")
            return _Long.fromString(val2, unsigned);
          return _Long.fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
        }
        add(addend) {
          if (!_Long.isLong(addend))
            addend = _Long.fromValue(addend);
          const a48 = this.high >>> 16;
          const a32 = this.high & 65535;
          const a16 = this.low >>> 16;
          const a00 = this.low & 65535;
          const b48 = addend.high >>> 16;
          const b32 = addend.high & 65535;
          const b16 = addend.low >>> 16;
          const b00 = addend.low & 65535;
          let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        }
        and(other) {
          if (!_Long.isLong(other))
            other = _Long.fromValue(other);
          return _Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        }
        compare(other) {
          if (!_Long.isLong(other))
            other = _Long.fromValue(other);
          if (this.eq(other))
            return 0;
          const thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        }
        comp(other) {
          return this.compare(other);
        }
        divide(divisor) {
          if (!_Long.isLong(divisor))
            divisor = _Long.fromValue(divisor);
          if (divisor.isZero())
            throw new BSONError("division by zero");
          if (wasm2) {
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
              return this;
            }
            const low = (this.unsigned ? wasm2.div_u : wasm2.div_s)(this.low, this.high, divisor.low, divisor.high);
            return _Long.fromBits(low, wasm2.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? _Long.UZERO : _Long.ZERO;
          let approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(_Long.MIN_VALUE)) {
              if (divisor.eq(_Long.ONE) || divisor.eq(_Long.NEG_ONE))
                return _Long.MIN_VALUE;
              else if (divisor.eq(_Long.MIN_VALUE))
                return _Long.ONE;
              else {
                const halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(_Long.ZERO)) {
                  return divisor.isNegative() ? _Long.ONE : _Long.NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(_Long.MIN_VALUE))
              return this.unsigned ? _Long.UZERO : _Long.ZERO;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = _Long.ZERO;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return _Long.UZERO;
            if (divisor.gt(this.shru(1)))
              return _Long.UONE;
            res = _Long.UZERO;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            const log2 = Math.ceil(Math.log(approx) / Math.LN2);
            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            let approxRes = _Long.fromNumber(approx);
            let approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = _Long.fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = _Long.ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        }
        div(divisor) {
          return this.divide(divisor);
        }
        equals(other) {
          if (!_Long.isLong(other))
            other = _Long.fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        }
        eq(other) {
          return this.equals(other);
        }
        getHighBits() {
          return this.high;
        }
        getHighBitsUnsigned() {
          return this.high >>> 0;
        }
        getLowBits() {
          return this.low;
        }
        getLowBitsUnsigned() {
          return this.low >>> 0;
        }
        getNumBitsAbs() {
          if (this.isNegative()) {
            return this.eq(_Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          }
          const val2 = this.high !== 0 ? this.high : this.low;
          let bit;
          for (bit = 31; bit > 0; bit--)
            if ((val2 & 1 << bit) !== 0)
              break;
          return this.high !== 0 ? bit + 33 : bit + 1;
        }
        greaterThan(other) {
          return this.comp(other) > 0;
        }
        gt(other) {
          return this.greaterThan(other);
        }
        greaterThanOrEqual(other) {
          return this.comp(other) >= 0;
        }
        gte(other) {
          return this.greaterThanOrEqual(other);
        }
        ge(other) {
          return this.greaterThanOrEqual(other);
        }
        isEven() {
          return (this.low & 1) === 0;
        }
        isNegative() {
          return !this.unsigned && this.high < 0;
        }
        isOdd() {
          return (this.low & 1) === 1;
        }
        isPositive() {
          return this.unsigned || this.high >= 0;
        }
        isZero() {
          return this.high === 0 && this.low === 0;
        }
        lessThan(other) {
          return this.comp(other) < 0;
        }
        lt(other) {
          return this.lessThan(other);
        }
        lessThanOrEqual(other) {
          return this.comp(other) <= 0;
        }
        lte(other) {
          return this.lessThanOrEqual(other);
        }
        modulo(divisor) {
          if (!_Long.isLong(divisor))
            divisor = _Long.fromValue(divisor);
          if (wasm2) {
            const low = (this.unsigned ? wasm2.rem_u : wasm2.rem_s)(this.low, this.high, divisor.low, divisor.high);
            return _Long.fromBits(low, wasm2.get_high(), this.unsigned);
          }
          return this.sub(this.div(divisor).mul(divisor));
        }
        mod(divisor) {
          return this.modulo(divisor);
        }
        rem(divisor) {
          return this.modulo(divisor);
        }
        multiply(multiplier) {
          if (this.isZero())
            return _Long.ZERO;
          if (!_Long.isLong(multiplier))
            multiplier = _Long.fromValue(multiplier);
          if (wasm2) {
            const low = wasm2.mul(this.low, this.high, multiplier.low, multiplier.high);
            return _Long.fromBits(low, wasm2.get_high(), this.unsigned);
          }
          if (multiplier.isZero())
            return _Long.ZERO;
          if (this.eq(_Long.MIN_VALUE))
            return multiplier.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
          if (multiplier.eq(_Long.MIN_VALUE))
            return this.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(_Long.TWO_PWR_24) && multiplier.lt(_Long.TWO_PWR_24))
            return _Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
          const a48 = this.high >>> 16;
          const a32 = this.high & 65535;
          const a16 = this.low >>> 16;
          const a00 = this.low & 65535;
          const b48 = multiplier.high >>> 16;
          const b32 = multiplier.high & 65535;
          const b16 = multiplier.low >>> 16;
          const b00 = multiplier.low & 65535;
          let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        }
        mul(multiplier) {
          return this.multiply(multiplier);
        }
        negate() {
          if (!this.unsigned && this.eq(_Long.MIN_VALUE))
            return _Long.MIN_VALUE;
          return this.not().add(_Long.ONE);
        }
        neg() {
          return this.negate();
        }
        not() {
          return _Long.fromBits(~this.low, ~this.high, this.unsigned);
        }
        notEquals(other) {
          return !this.equals(other);
        }
        neq(other) {
          return this.notEquals(other);
        }
        ne(other) {
          return this.notEquals(other);
        }
        or(other) {
          if (!_Long.isLong(other))
            other = _Long.fromValue(other);
          return _Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        }
        shiftLeft(numBits) {
          if (_Long.isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return _Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return _Long.fromBits(0, this.low << numBits - 32, this.unsigned);
        }
        shl(numBits) {
          return this.shiftLeft(numBits);
        }
        shiftRight(numBits) {
          if (_Long.isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return _Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return _Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        }
        shr(numBits) {
          return this.shiftRight(numBits);
        }
        shiftRightUnsigned(numBits) {
          if (_Long.isLong(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            const high = this.high;
            if (numBits < 32) {
              const low = this.low;
              return _Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return _Long.fromBits(high, 0, this.unsigned);
            else
              return _Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
          }
        }
        shr_u(numBits) {
          return this.shiftRightUnsigned(numBits);
        }
        shru(numBits) {
          return this.shiftRightUnsigned(numBits);
        }
        subtract(subtrahend) {
          if (!_Long.isLong(subtrahend))
            subtrahend = _Long.fromValue(subtrahend);
          return this.add(subtrahend.neg());
        }
        sub(subtrahend) {
          return this.subtract(subtrahend);
        }
        toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        }
        toNumber() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
        }
        toBigInt() {
          return BigInt(this.toString());
        }
        toBytes(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        }
        toBytesLE() {
          const hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
          ];
        }
        toBytesBE() {
          const hi = this.high, lo = this.low;
          return [
            hi >>> 24,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        }
        toSigned() {
          if (!this.unsigned)
            return this;
          return _Long.fromBits(this.low, this.high, false);
        }
        toString(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw new BSONError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(_Long.MIN_VALUE)) {
              const radixLong = _Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          const radixToPower = _Long.fromNumber(Math.pow(radix, 6), this.unsigned);
          let rem = this;
          let result = "";
          while (true) {
            const remDiv = rem.div(radixToPower);
            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
            let digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
              return digits + result;
            } else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        }
        toUnsigned() {
          if (this.unsigned)
            return this;
          return _Long.fromBits(this.low, this.high, true);
        }
        xor(other) {
          if (!_Long.isLong(other))
            other = _Long.fromValue(other);
          return _Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        }
        eqz() {
          return this.isZero();
        }
        le(other) {
          return this.lessThanOrEqual(other);
        }
        toExtendedJSON(options) {
          if (options && options.relaxed)
            return this.toNumber();
          return { $numberLong: this.toString() };
        }
        static fromExtendedJSON(doc, options) {
          const { useBigInt64 = false, relaxed = true } = { ...options };
          if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
            throw new BSONError("$numberLong string is too long");
          }
          if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
            throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
          }
          if (useBigInt64) {
            const bigIntResult = BigInt(doc.$numberLong);
            return BigInt.asIntN(64, bigIntResult);
          }
          const longResult = _Long.fromString(doc.$numberLong);
          if (relaxed) {
            return longResult.toNumber();
          }
          return longResult;
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          const longVal = inspect(this.toString(), options);
          const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
          return `new Long(${longVal}${unsignedVal})`;
        }
      };
      Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL2);
      Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.ZERO = Long2.fromInt(0);
      Long2.UZERO = Long2.fromInt(0, true);
      Long2.ONE = Long2.fromInt(1);
      Long2.UONE = Long2.fromInt(1, true);
      Long2.NEG_ONE = Long2.fromInt(-1);
      Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
      var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
      var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
      var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
      var EXPONENT_MAX = 6111;
      var EXPONENT_MIN = -6176;
      var EXPONENT_BIAS = 6176;
      var MAX_DIGITS = 34;
      var NAN_BUFFER = ByteUtils.fromNumberArray([
        124,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ].reverse());
      var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
        248,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ].reverse());
      var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
        120,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ].reverse());
      var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
      var COMBINATION_MASK = 31;
      var EXPONENT_MASK = 16383;
      var COMBINATION_INFINITY = 30;
      var COMBINATION_NAN = 31;
      function isDigit(value) {
        return !isNaN(parseInt(value, 10));
      }
      function divideu128(value) {
        const DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
        let _rem = Long2.fromNumber(0);
        if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
          return { quotient: value, rem: _rem };
        }
        for (let i = 0; i <= 3; i++) {
          _rem = _rem.shiftLeft(32);
          _rem = _rem.add(new Long2(value.parts[i], 0));
          value.parts[i] = _rem.div(DIVISOR).low;
          _rem = _rem.modulo(DIVISOR);
        }
        return { quotient: value, rem: _rem };
      }
      function multiply64x2(left, right) {
        if (!left && !right) {
          return { high: Long2.fromNumber(0), low: Long2.fromNumber(0) };
        }
        const leftHigh = left.shiftRightUnsigned(32);
        const leftLow = new Long2(left.getLowBits(), 0);
        const rightHigh = right.shiftRightUnsigned(32);
        const rightLow = new Long2(right.getLowBits(), 0);
        let productHigh = leftHigh.multiply(rightHigh);
        let productMid = leftHigh.multiply(rightLow);
        const productMid2 = leftLow.multiply(rightHigh);
        let productLow = leftLow.multiply(rightLow);
        productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
        productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
        productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
        productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
        return { high: productHigh, low: productLow };
      }
      function lessThan2(left, right) {
        const uhleft = left.high >>> 0;
        const uhright = right.high >>> 0;
        if (uhleft < uhright) {
          return true;
        } else if (uhleft === uhright) {
          const ulleft = left.low >>> 0;
          const ulright = right.low >>> 0;
          if (ulleft < ulright)
            return true;
        }
        return false;
      }
      function invalidErr(string, message) {
        throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
      }
      var Decimal128 = class _Decimal128 extends BSONValue {
        get _bsontype() {
          return "Decimal128";
        }
        constructor(bytes) {
          super();
          if (typeof bytes === "string") {
            this.bytes = _Decimal128.fromString(bytes).bytes;
          } else if (isUint8Array(bytes)) {
            if (bytes.byteLength !== 16) {
              throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
            }
            this.bytes = bytes;
          } else {
            throw new BSONError("Decimal128 must take a Buffer or string");
          }
        }
        static fromString(representation) {
          return _Decimal128._fromString(representation, { allowRounding: false });
        }
        static fromStringWithRounding(representation) {
          return _Decimal128._fromString(representation, { allowRounding: true });
        }
        static _fromString(representation, options) {
          let isNegative2 = false;
          let sawSign = false;
          let sawRadix = false;
          let foundNonZero = false;
          let significantDigits = 0;
          let nDigitsRead = 0;
          let nDigits = 0;
          let radixPosition = 0;
          let firstNonZero = 0;
          const digits = [0];
          let nDigitsStored = 0;
          let digitsInsert = 0;
          let lastDigit = 0;
          let exponent = 0;
          let significandHigh = new Long2(0, 0);
          let significandLow = new Long2(0, 0);
          let biasedExponent = 0;
          let index = 0;
          if (representation.length >= 7e3) {
            throw new BSONError("" + representation + " not a valid Decimal128 string");
          }
          const stringMatch = representation.match(PARSE_STRING_REGEXP);
          const infMatch = representation.match(PARSE_INF_REGEXP);
          const nanMatch = representation.match(PARSE_NAN_REGEXP);
          if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
            throw new BSONError("" + representation + " not a valid Decimal128 string");
          }
          if (stringMatch) {
            const unsignedNumber = stringMatch[2];
            const e2 = stringMatch[4];
            const expSign = stringMatch[5];
            const expNumber = stringMatch[6];
            if (e2 && expNumber === void 0)
              invalidErr(representation, "missing exponent power");
            if (e2 && unsignedNumber === void 0)
              invalidErr(representation, "missing exponent base");
            if (e2 === void 0 && (expSign || expNumber)) {
              invalidErr(representation, "missing e before exponent");
            }
          }
          if (representation[index] === "+" || representation[index] === "-") {
            sawSign = true;
            isNegative2 = representation[index++] === "-";
          }
          if (!isDigit(representation[index]) && representation[index] !== ".") {
            if (representation[index] === "i" || representation[index] === "I") {
              return new _Decimal128(isNegative2 ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
            } else if (representation[index] === "N") {
              return new _Decimal128(NAN_BUFFER);
            }
          }
          while (isDigit(representation[index]) || representation[index] === ".") {
            if (representation[index] === ".") {
              if (sawRadix)
                invalidErr(representation, "contains multiple periods");
              sawRadix = true;
              index = index + 1;
              continue;
            }
            if (nDigitsStored < MAX_DIGITS) {
              if (representation[index] !== "0" || foundNonZero) {
                if (!foundNonZero) {
                  firstNonZero = nDigitsRead;
                }
                foundNonZero = true;
                digits[digitsInsert++] = parseInt(representation[index], 10);
                nDigitsStored = nDigitsStored + 1;
              }
            }
            if (foundNonZero)
              nDigits = nDigits + 1;
            if (sawRadix)
              radixPosition = radixPosition + 1;
            nDigitsRead = nDigitsRead + 1;
            index = index + 1;
          }
          if (sawRadix && !nDigitsRead)
            throw new BSONError("" + representation + " not a valid Decimal128 string");
          if (representation[index] === "e" || representation[index] === "E") {
            const match = representation.substr(++index).match(EXPONENT_REGEX);
            if (!match || !match[2])
              return new _Decimal128(NAN_BUFFER);
            exponent = parseInt(match[0], 10);
            index = index + match[0].length;
          }
          if (representation[index])
            return new _Decimal128(NAN_BUFFER);
          if (!nDigitsStored) {
            digits[0] = 0;
            nDigits = 1;
            nDigitsStored = 1;
            significantDigits = 0;
          } else {
            lastDigit = nDigitsStored - 1;
            significantDigits = nDigits;
            if (significantDigits !== 1) {
              while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
                significantDigits = significantDigits - 1;
              }
            }
          }
          if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
            exponent = EXPONENT_MIN;
          } else {
            exponent = exponent - radixPosition;
          }
          while (exponent > EXPONENT_MAX) {
            lastDigit = lastDigit + 1;
            if (lastDigit >= MAX_DIGITS) {
              if (significantDigits === 0) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
            exponent = exponent - 1;
          }
          if (options.allowRounding) {
            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
              if (lastDigit === 0 && significantDigits < nDigitsStored) {
                exponent = EXPONENT_MIN;
                significantDigits = 0;
                break;
              }
              if (nDigitsStored < nDigits) {
                nDigits = nDigits - 1;
              } else {
                lastDigit = lastDigit - 1;
              }
              if (exponent < EXPONENT_MAX) {
                exponent = exponent + 1;
              } else {
                const digitsString = digits.join("");
                if (digitsString.match(/^0+$/)) {
                  exponent = EXPONENT_MAX;
                  break;
                }
                invalidErr(representation, "overflow");
              }
            }
            if (lastDigit + 1 < significantDigits) {
              let endOfString = nDigitsRead;
              if (sawRadix) {
                firstNonZero = firstNonZero + 1;
                endOfString = endOfString + 1;
              }
              if (sawSign) {
                firstNonZero = firstNonZero + 1;
                endOfString = endOfString + 1;
              }
              const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
              let roundBit = 0;
              if (roundDigit >= 5) {
                roundBit = 1;
                if (roundDigit === 5) {
                  roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
                  for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                    if (parseInt(representation[i], 10)) {
                      roundBit = 1;
                      break;
                    }
                  }
                }
              }
              if (roundBit) {
                let dIdx = lastDigit;
                for (; dIdx >= 0; dIdx--) {
                  if (++digits[dIdx] > 9) {
                    digits[dIdx] = 0;
                    if (dIdx === 0) {
                      if (exponent < EXPONENT_MAX) {
                        exponent = exponent + 1;
                        digits[dIdx] = 1;
                      } else {
                        return new _Decimal128(isNegative2 ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                      }
                    }
                  } else {
                    break;
                  }
                }
              }
            }
          } else {
            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
              if (lastDigit === 0) {
                if (significantDigits === 0) {
                  exponent = EXPONENT_MIN;
                  break;
                }
                invalidErr(representation, "exponent underflow");
              }
              if (nDigitsStored < nDigits) {
                if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
                  invalidErr(representation, "inexact rounding");
                }
                nDigits = nDigits - 1;
              } else {
                if (digits[lastDigit] !== 0) {
                  invalidErr(representation, "inexact rounding");
                }
                lastDigit = lastDigit - 1;
              }
              if (exponent < EXPONENT_MAX) {
                exponent = exponent + 1;
              } else {
                invalidErr(representation, "overflow");
              }
            }
            if (lastDigit + 1 < significantDigits) {
              if (sawRadix) {
                firstNonZero = firstNonZero + 1;
              }
              if (sawSign) {
                firstNonZero = firstNonZero + 1;
              }
              const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
              if (roundDigit !== 0) {
                invalidErr(representation, "inexact rounding");
              }
            }
          }
          significandHigh = Long2.fromNumber(0);
          significandLow = Long2.fromNumber(0);
          if (significantDigits === 0) {
            significandHigh = Long2.fromNumber(0);
            significandLow = Long2.fromNumber(0);
          } else if (lastDigit < 17) {
            let dIdx = 0;
            significandLow = Long2.fromNumber(digits[dIdx++]);
            significandHigh = new Long2(0, 0);
            for (; dIdx <= lastDigit; dIdx++) {
              significandLow = significandLow.multiply(Long2.fromNumber(10));
              significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
            }
          } else {
            let dIdx = 0;
            significandHigh = Long2.fromNumber(digits[dIdx++]);
            for (; dIdx <= lastDigit - 17; dIdx++) {
              significandHigh = significandHigh.multiply(Long2.fromNumber(10));
              significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
            }
            significandLow = Long2.fromNumber(digits[dIdx++]);
            for (; dIdx <= lastDigit; dIdx++) {
              significandLow = significandLow.multiply(Long2.fromNumber(10));
              significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
            }
          }
          const significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
          significand.low = significand.low.add(significandLow);
          if (lessThan2(significand.low, significandLow)) {
            significand.high = significand.high.add(Long2.fromNumber(1));
          }
          biasedExponent = exponent + EXPONENT_BIAS;
          const dec = { low: Long2.fromNumber(0), high: Long2.fromNumber(0) };
          if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber(1))) {
            dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
            dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
            dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
          } else {
            dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
            dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
          }
          dec.low = significand.low;
          if (isNegative2) {
            dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
          }
          const buffer3 = ByteUtils.allocateUnsafe(16);
          index = 0;
          buffer3[index++] = dec.low.low & 255;
          buffer3[index++] = dec.low.low >> 8 & 255;
          buffer3[index++] = dec.low.low >> 16 & 255;
          buffer3[index++] = dec.low.low >> 24 & 255;
          buffer3[index++] = dec.low.high & 255;
          buffer3[index++] = dec.low.high >> 8 & 255;
          buffer3[index++] = dec.low.high >> 16 & 255;
          buffer3[index++] = dec.low.high >> 24 & 255;
          buffer3[index++] = dec.high.low & 255;
          buffer3[index++] = dec.high.low >> 8 & 255;
          buffer3[index++] = dec.high.low >> 16 & 255;
          buffer3[index++] = dec.high.low >> 24 & 255;
          buffer3[index++] = dec.high.high & 255;
          buffer3[index++] = dec.high.high >> 8 & 255;
          buffer3[index++] = dec.high.high >> 16 & 255;
          buffer3[index++] = dec.high.high >> 24 & 255;
          return new _Decimal128(buffer3);
        }
        toString() {
          let biased_exponent;
          let significand_digits = 0;
          const significand = new Array(36);
          for (let i = 0; i < significand.length; i++)
            significand[i] = 0;
          let index = 0;
          let is_zero = false;
          let significand_msb;
          let significand128 = { parts: [0, 0, 0, 0] };
          let j, k;
          const string = [];
          index = 0;
          const buffer3 = this.bytes;
          const low = buffer3[index++] | buffer3[index++] << 8 | buffer3[index++] << 16 | buffer3[index++] << 24;
          const midl = buffer3[index++] | buffer3[index++] << 8 | buffer3[index++] << 16 | buffer3[index++] << 24;
          const midh = buffer3[index++] | buffer3[index++] << 8 | buffer3[index++] << 16 | buffer3[index++] << 24;
          const high = buffer3[index++] | buffer3[index++] << 8 | buffer3[index++] << 16 | buffer3[index++] << 24;
          index = 0;
          const dec = {
            low: new Long2(low, midl),
            high: new Long2(midh, high)
          };
          if (dec.high.lessThan(Long2.ZERO)) {
            string.push("-");
          }
          const combination = high >> 26 & COMBINATION_MASK;
          if (combination >> 3 === 3) {
            if (combination === COMBINATION_INFINITY) {
              return string.join("") + "Infinity";
            } else if (combination === COMBINATION_NAN) {
              return "NaN";
            } else {
              biased_exponent = high >> 15 & EXPONENT_MASK;
              significand_msb = 8 + (high >> 14 & 1);
            }
          } else {
            significand_msb = high >> 14 & 7;
            biased_exponent = high >> 17 & EXPONENT_MASK;
          }
          const exponent = biased_exponent - EXPONENT_BIAS;
          significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
          significand128.parts[1] = midh;
          significand128.parts[2] = midl;
          significand128.parts[3] = low;
          if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
            is_zero = true;
          } else {
            for (k = 3; k >= 0; k--) {
              let least_digits = 0;
              const result = divideu128(significand128);
              significand128 = result.quotient;
              least_digits = result.rem.low;
              if (!least_digits)
                continue;
              for (j = 8; j >= 0; j--) {
                significand[k * 9 + j] = least_digits % 10;
                least_digits = Math.floor(least_digits / 10);
              }
            }
          }
          if (is_zero) {
            significand_digits = 1;
            significand[index] = 0;
          } else {
            significand_digits = 36;
            while (!significand[index]) {
              significand_digits = significand_digits - 1;
              index = index + 1;
            }
          }
          const scientific_exponent = significand_digits - 1 + exponent;
          if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
            if (significand_digits > 34) {
              string.push(`${0}`);
              if (exponent > 0)
                string.push(`E+${exponent}`);
              else if (exponent < 0)
                string.push(`E${exponent}`);
              return string.join("");
            }
            string.push(`${significand[index++]}`);
            significand_digits = significand_digits - 1;
            if (significand_digits) {
              string.push(".");
            }
            for (let i = 0; i < significand_digits; i++) {
              string.push(`${significand[index++]}`);
            }
            string.push("E");
            if (scientific_exponent > 0) {
              string.push(`+${scientific_exponent}`);
            } else {
              string.push(`${scientific_exponent}`);
            }
          } else {
            if (exponent >= 0) {
              for (let i = 0; i < significand_digits; i++) {
                string.push(`${significand[index++]}`);
              }
            } else {
              let radix_position = significand_digits + exponent;
              if (radix_position > 0) {
                for (let i = 0; i < radix_position; i++) {
                  string.push(`${significand[index++]}`);
                }
              } else {
                string.push("0");
              }
              string.push(".");
              while (radix_position++ < 0) {
                string.push("0");
              }
              for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
                string.push(`${significand[index++]}`);
              }
            }
          }
          return string.join("");
        }
        toJSON() {
          return { $numberDecimal: this.toString() };
        }
        toExtendedJSON() {
          return { $numberDecimal: this.toString() };
        }
        static fromExtendedJSON(doc) {
          return _Decimal128.fromString(doc.$numberDecimal);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          const d128string = inspect(this.toString(), options);
          return `new Decimal128(${d128string})`;
        }
      };
      var Double = class _Double extends BSONValue {
        get _bsontype() {
          return "Double";
        }
        constructor(value) {
          super();
          if (value instanceof Number) {
            value = value.valueOf();
          }
          this.value = +value;
        }
        static fromString(value) {
          const coercedValue = Number(value);
          if (value === "NaN")
            return new _Double(NaN);
          if (value === "Infinity")
            return new _Double(Infinity);
          if (value === "-Infinity")
            return new _Double(-Infinity);
          if (!Number.isFinite(coercedValue)) {
            throw new BSONError(`Input: ${value} is not representable as a Double`);
          }
          if (value.trim() !== value) {
            throw new BSONError(`Input: '${value}' contains whitespace`);
          }
          if (value === "") {
            throw new BSONError(`Input is an empty string`);
          }
          if (/[^-0-9.+eE]/.test(value)) {
            throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
          }
          return new _Double(coercedValue);
        }
        valueOf() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toString(radix) {
          return this.value.toString(radix);
        }
        toExtendedJSON(options) {
          if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
            return this.value;
          }
          if (Object.is(Math.sign(this.value), -0)) {
            return { $numberDouble: "-0.0" };
          }
          return {
            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
          };
        }
        static fromExtendedJSON(doc, options) {
          const doubleValue = parseFloat(doc.$numberDouble);
          return options && options.relaxed ? doubleValue : new _Double(doubleValue);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          return `new Double(${inspect(this.value, options)})`;
        }
      };
      var Int32 = class _Int32 extends BSONValue {
        get _bsontype() {
          return "Int32";
        }
        constructor(value) {
          super();
          if (value instanceof Number) {
            value = value.valueOf();
          }
          this.value = +value | 0;
        }
        static fromString(value) {
          const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
          const coercedValue = Number(value);
          if (BSON_INT32_MAX < coercedValue) {
            throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
          } else if (BSON_INT32_MIN > coercedValue) {
            throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
          } else if (!Number.isSafeInteger(coercedValue)) {
            throw new BSONError(`Input: '${value}' is not a safe integer`);
          } else if (coercedValue.toString() !== cleanedValue) {
            throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
          }
          return new _Int32(coercedValue);
        }
        valueOf() {
          return this.value;
        }
        toString(radix) {
          return this.value.toString(radix);
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON(options) {
          if (options && (options.relaxed || options.legacy))
            return this.value;
          return { $numberInt: this.value.toString() };
        }
        static fromExtendedJSON(doc, options) {
          return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new _Int32(doc.$numberInt);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          return `new Int32(${inspect(this.value, options)})`;
        }
      };
      var MaxKey = class _MaxKey extends BSONValue {
        get _bsontype() {
          return "MaxKey";
        }
        toExtendedJSON() {
          return { $maxKey: 1 };
        }
        static fromExtendedJSON() {
          return new _MaxKey();
        }
        inspect() {
          return "new MaxKey()";
        }
      };
      var MinKey = class _MinKey extends BSONValue {
        get _bsontype() {
          return "MinKey";
        }
        toExtendedJSON() {
          return { $minKey: 1 };
        }
        static fromExtendedJSON() {
          return new _MinKey();
        }
        inspect() {
          return "new MinKey()";
        }
      };
      var FLOAT = new Float64Array(1);
      var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
      FLOAT[0] = -1;
      var isBigEndian = FLOAT_BYTES[7] === 0;
      var NumberUtils = {
        getNonnegativeInt32LE(source, offset) {
          if (source[offset + 3] > 127) {
            throw new RangeError(`Size cannot be negative at offset: ${offset}`);
          }
          return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
        },
        getInt32LE(source, offset) {
          return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
        },
        getUint32LE(source, offset) {
          return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
        },
        getUint32BE(source, offset) {
          return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
        },
        getBigInt64LE(source, offset) {
          const lo = NumberUtils.getUint32LE(source, offset);
          const hi = NumberUtils.getUint32LE(source, offset + 4);
          return (BigInt(hi) << BigInt(32)) + BigInt(lo);
        },
        getFloat64LE: isBigEndian ? (source, offset) => {
          FLOAT_BYTES[7] = source[offset];
          FLOAT_BYTES[6] = source[offset + 1];
          FLOAT_BYTES[5] = source[offset + 2];
          FLOAT_BYTES[4] = source[offset + 3];
          FLOAT_BYTES[3] = source[offset + 4];
          FLOAT_BYTES[2] = source[offset + 5];
          FLOAT_BYTES[1] = source[offset + 6];
          FLOAT_BYTES[0] = source[offset + 7];
          return FLOAT[0];
        } : (source, offset) => {
          FLOAT_BYTES[0] = source[offset];
          FLOAT_BYTES[1] = source[offset + 1];
          FLOAT_BYTES[2] = source[offset + 2];
          FLOAT_BYTES[3] = source[offset + 3];
          FLOAT_BYTES[4] = source[offset + 4];
          FLOAT_BYTES[5] = source[offset + 5];
          FLOAT_BYTES[6] = source[offset + 6];
          FLOAT_BYTES[7] = source[offset + 7];
          return FLOAT[0];
        },
        setInt32BE(destination, offset, value) {
          destination[offset + 3] = value;
          value >>>= 8;
          destination[offset + 2] = value;
          value >>>= 8;
          destination[offset + 1] = value;
          value >>>= 8;
          destination[offset] = value;
          return 4;
        },
        setInt32LE(destination, offset, value) {
          destination[offset] = value;
          value >>>= 8;
          destination[offset + 1] = value;
          value >>>= 8;
          destination[offset + 2] = value;
          value >>>= 8;
          destination[offset + 3] = value;
          return 4;
        },
        setBigInt64LE(destination, offset, value) {
          const mask32bits = BigInt(4294967295);
          let lo = Number(value & mask32bits);
          destination[offset] = lo;
          lo >>= 8;
          destination[offset + 1] = lo;
          lo >>= 8;
          destination[offset + 2] = lo;
          lo >>= 8;
          destination[offset + 3] = lo;
          let hi = Number(value >> BigInt(32) & mask32bits);
          destination[offset + 4] = hi;
          hi >>= 8;
          destination[offset + 5] = hi;
          hi >>= 8;
          destination[offset + 6] = hi;
          hi >>= 8;
          destination[offset + 7] = hi;
          return 8;
        },
        setFloat64LE: isBigEndian ? (destination, offset, value) => {
          FLOAT[0] = value;
          destination[offset] = FLOAT_BYTES[7];
          destination[offset + 1] = FLOAT_BYTES[6];
          destination[offset + 2] = FLOAT_BYTES[5];
          destination[offset + 3] = FLOAT_BYTES[4];
          destination[offset + 4] = FLOAT_BYTES[3];
          destination[offset + 5] = FLOAT_BYTES[2];
          destination[offset + 6] = FLOAT_BYTES[1];
          destination[offset + 7] = FLOAT_BYTES[0];
          return 8;
        } : (destination, offset, value) => {
          FLOAT[0] = value;
          destination[offset] = FLOAT_BYTES[0];
          destination[offset + 1] = FLOAT_BYTES[1];
          destination[offset + 2] = FLOAT_BYTES[2];
          destination[offset + 3] = FLOAT_BYTES[3];
          destination[offset + 4] = FLOAT_BYTES[4];
          destination[offset + 5] = FLOAT_BYTES[5];
          destination[offset + 6] = FLOAT_BYTES[6];
          destination[offset + 7] = FLOAT_BYTES[7];
          return 8;
        }
      };
      var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
      var PROCESS_UNIQUE = null;
      var ObjectId = class _ObjectId extends BSONValue {
        get _bsontype() {
          return "ObjectId";
        }
        constructor(inputId) {
          super();
          let workingId;
          if (typeof inputId === "object" && inputId && "id" in inputId) {
            if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
              throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
            }
            if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
              workingId = ByteUtils.fromHex(inputId.toHexString());
            } else {
              workingId = inputId.id;
            }
          } else {
            workingId = inputId;
          }
          if (workingId == null || typeof workingId === "number") {
            this.buffer = _ObjectId.generate(typeof workingId === "number" ? workingId : void 0);
          } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
            this.buffer = ByteUtils.toLocalBufferType(workingId);
          } else if (typeof workingId === "string") {
            if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
              this.buffer = ByteUtils.fromHex(workingId);
            } else {
              throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
            }
          } else {
            throw new BSONError("Argument passed in does not match the accepted types");
          }
          if (_ObjectId.cacheHexString) {
            this.__id = ByteUtils.toHex(this.id);
          }
        }
        get id() {
          return this.buffer;
        }
        set id(value) {
          this.buffer = value;
          if (_ObjectId.cacheHexString) {
            this.__id = ByteUtils.toHex(value);
          }
        }
        toHexString() {
          if (_ObjectId.cacheHexString && this.__id) {
            return this.__id;
          }
          const hexString = ByteUtils.toHex(this.id);
          if (_ObjectId.cacheHexString && !this.__id) {
            this.__id = hexString;
          }
          return hexString;
        }
        static getInc() {
          return _ObjectId.index = (_ObjectId.index + 1) % 16777215;
        }
        static generate(time) {
          if ("number" !== typeof time) {
            time = Math.floor(Date.now() / 1e3);
          }
          const inc = _ObjectId.getInc();
          const buffer3 = ByteUtils.allocateUnsafe(12);
          NumberUtils.setInt32BE(buffer3, 0, time);
          if (PROCESS_UNIQUE === null) {
            PROCESS_UNIQUE = ByteUtils.randomBytes(5);
          }
          buffer3[4] = PROCESS_UNIQUE[0];
          buffer3[5] = PROCESS_UNIQUE[1];
          buffer3[6] = PROCESS_UNIQUE[2];
          buffer3[7] = PROCESS_UNIQUE[3];
          buffer3[8] = PROCESS_UNIQUE[4];
          buffer3[11] = inc & 255;
          buffer3[10] = inc >> 8 & 255;
          buffer3[9] = inc >> 16 & 255;
          return buffer3;
        }
        toString(encoding) {
          if (encoding === "base64")
            return ByteUtils.toBase64(this.id);
          if (encoding === "hex")
            return this.toHexString();
          return this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        static is(variable) {
          return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
        }
        equals(otherId) {
          if (otherId === void 0 || otherId === null) {
            return false;
          }
          if (_ObjectId.is(otherId)) {
            return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
          }
          if (typeof otherId === "string") {
            return otherId.toLowerCase() === this.toHexString();
          }
          if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
            const otherIdString = otherId.toHexString();
            const thisIdString = this.toHexString();
            return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
          }
          return false;
        }
        getTimestamp() {
          const timestamp = /* @__PURE__ */ new Date();
          const time = NumberUtils.getUint32BE(this.buffer, 0);
          timestamp.setTime(Math.floor(time) * 1e3);
          return timestamp;
        }
        static createPk() {
          return new _ObjectId();
        }
        serializeInto(uint8array, index) {
          uint8array[index] = this.buffer[0];
          uint8array[index + 1] = this.buffer[1];
          uint8array[index + 2] = this.buffer[2];
          uint8array[index + 3] = this.buffer[3];
          uint8array[index + 4] = this.buffer[4];
          uint8array[index + 5] = this.buffer[5];
          uint8array[index + 6] = this.buffer[6];
          uint8array[index + 7] = this.buffer[7];
          uint8array[index + 8] = this.buffer[8];
          uint8array[index + 9] = this.buffer[9];
          uint8array[index + 10] = this.buffer[10];
          uint8array[index + 11] = this.buffer[11];
          return 12;
        }
        static createFromTime(time) {
          const buffer3 = ByteUtils.allocate(12);
          for (let i = 11; i >= 4; i--)
            buffer3[i] = 0;
          NumberUtils.setInt32BE(buffer3, 0, time);
          return new _ObjectId(buffer3);
        }
        static createFromHexString(hexString) {
          if (hexString?.length !== 24) {
            throw new BSONError("hex string must be 24 characters");
          }
          return new _ObjectId(ByteUtils.fromHex(hexString));
        }
        static createFromBase64(base64) {
          if (base64?.length !== 16) {
            throw new BSONError("base64 string must be 16 characters");
          }
          return new _ObjectId(ByteUtils.fromBase64(base64));
        }
        static isValid(id) {
          if (id == null)
            return false;
          try {
            new _ObjectId(id);
            return true;
          } catch {
            return false;
          }
        }
        toExtendedJSON() {
          if (this.toHexString)
            return { $oid: this.toHexString() };
          return { $oid: this.toString("hex") };
        }
        static fromExtendedJSON(doc) {
          return new _ObjectId(doc.$oid);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          return `new ObjectId(${inspect(this.toHexString(), options)})`;
        }
      };
      ObjectId.index = Math.floor(Math.random() * 16777215);
      function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
        let totalLength = 4 + 1;
        if (Array.isArray(object)) {
          for (let i = 0; i < object.length; i++) {
            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
          }
        } else {
          if (typeof object?.toBSON === "function") {
            object = object.toBSON();
          }
          for (const key of Object.keys(object)) {
            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
          }
        }
        return totalLength;
      }
      function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        switch (typeof value) {
          case "string":
            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
          case "number":
            if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
              if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
              } else {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
              }
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            }
          case "undefined":
            if (isArray || !ignoreUndefined)
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
            return 0;
          case "boolean":
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
          case "object":
            if (value != null && typeof value._bsontype === "string" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
            } else if (value._bsontype === "ObjectId") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
            } else if (value instanceof Date || isDate(value)) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
            } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            } else if (value._bsontype === "Decimal128") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
            } else if (value._bsontype === "Code") {
              if (value.scope != null && Object.keys(value.scope).length > 0) {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
              } else {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
              }
            } else if (value._bsontype === "Binary") {
              const binary = value;
              if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
              } else {
                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
              }
            } else if (value._bsontype === "Symbol") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
            } else if (value._bsontype === "DBRef") {
              const ordered_values = Object.assign({
                $ref: value.collection,
                $id: value.oid
              }, value.fields);
              if (value.db != null) {
                ordered_values["$db"] = value.db;
              }
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
            } else if (value instanceof RegExp || isRegExp(value)) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
            } else if (value._bsontype === "BSONRegExp") {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
            }
          case "function":
            if (serializeFunctions) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
            }
        }
        return 0;
      }
      function alphabetize(str) {
        return str.split("").sort().join("");
      }
      var BSONRegExp = class _BSONRegExp extends BSONValue {
        get _bsontype() {
          return "BSONRegExp";
        }
        constructor(pattern, options) {
          super();
          this.pattern = pattern;
          this.options = alphabetize(options ?? "");
          if (this.pattern.indexOf("\0") !== -1) {
            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
          }
          if (this.options.indexOf("\0") !== -1) {
            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
          }
          for (let i = 0; i < this.options.length; i++) {
            if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
              throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
            }
          }
        }
        static parseOptions(options) {
          return options ? options.split("").sort().join("") : "";
        }
        toExtendedJSON(options) {
          options = options || {};
          if (options.legacy) {
            return { $regex: this.pattern, $options: this.options };
          }
          return { $regularExpression: { pattern: this.pattern, options: this.options } };
        }
        static fromExtendedJSON(doc) {
          if ("$regex" in doc) {
            if (typeof doc.$regex !== "string") {
              if (doc.$regex._bsontype === "BSONRegExp") {
                return doc;
              }
            } else {
              return new _BSONRegExp(doc.$regex, _BSONRegExp.parseOptions(doc.$options));
            }
          }
          if ("$regularExpression" in doc) {
            return new _BSONRegExp(doc.$regularExpression.pattern, _BSONRegExp.parseOptions(doc.$regularExpression.options));
          }
          throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
        }
        inspect(depth, options, inspect) {
          const stylize = getStylizeFunction(options) ?? ((v) => v);
          inspect ??= defaultInspect;
          const pattern = stylize(inspect(this.pattern), "regexp");
          const flags = stylize(inspect(this.options), "regexp");
          return `new BSONRegExp(${pattern}, ${flags})`;
        }
      };
      var BSONSymbol = class _BSONSymbol extends BSONValue {
        get _bsontype() {
          return "BSONSymbol";
        }
        constructor(value) {
          super();
          this.value = value;
        }
        valueOf() {
          return this.value;
        }
        toString() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON() {
          return { $symbol: this.value };
        }
        static fromExtendedJSON(doc) {
          return new _BSONSymbol(doc.$symbol);
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          return `new BSONSymbol(${inspect(this.value, options)})`;
        }
      };
      var LongWithoutOverridesClass = Long2;
      var Timestamp = class _Timestamp extends LongWithoutOverridesClass {
        get _bsontype() {
          return "Timestamp";
        }
        constructor(low) {
          if (low == null) {
            super(0, 0, true);
          } else if (typeof low === "bigint") {
            super(low, true);
          } else if (Long2.isLong(low)) {
            super(low.low, low.high, true);
          } else if (typeof low === "object" && "t" in low && "i" in low) {
            if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
              throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
            }
            if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
              throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
            }
            const t2 = Number(low.t);
            const i = Number(low.i);
            if (t2 < 0 || Number.isNaN(t2)) {
              throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
            }
            if (i < 0 || Number.isNaN(i)) {
              throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
            }
            if (t2 > 4294967295) {
              throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
            }
            if (i > 4294967295) {
              throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
            }
            super(i, t2, true);
          } else {
            throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
          }
        }
        toJSON() {
          return {
            $timestamp: this.toString()
          };
        }
        static fromInt(value) {
          return new _Timestamp(Long2.fromInt(value, true));
        }
        static fromNumber(value) {
          return new _Timestamp(Long2.fromNumber(value, true));
        }
        static fromBits(lowBits, highBits) {
          return new _Timestamp({ i: lowBits, t: highBits });
        }
        static fromString(str, optRadix) {
          return new _Timestamp(Long2.fromString(str, true, optRadix));
        }
        toExtendedJSON() {
          return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
        }
        static fromExtendedJSON(doc) {
          const i = Long2.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
          const t2 = Long2.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
          return new _Timestamp({ t: t2, i });
        }
        inspect(depth, options, inspect) {
          inspect ??= defaultInspect;
          const t2 = inspect(this.high >>> 0, options);
          const i = inspect(this.low >>> 0, options);
          return `new Timestamp({ t: ${t2}, i: ${i} })`;
        }
      };
      Timestamp.MAX_VALUE = Long2.MAX_UNSIGNED_VALUE;
      var JS_INT_MAX_LONG = Long2.fromNumber(JS_INT_MAX);
      var JS_INT_MIN_LONG = Long2.fromNumber(JS_INT_MIN);
      function internalDeserialize(buffer3, options, isArray) {
        options = options == null ? {} : options;
        const index = options && options.index ? options.index : 0;
        const size = NumberUtils.getInt32LE(buffer3, index);
        if (size < 5) {
          throw new BSONError(`bson size must be >= 5, is ${size}`);
        }
        if (options.allowObjectSmallerThanBufferSize && buffer3.length < size) {
          throw new BSONError(`buffer length ${buffer3.length} must be >= bson size ${size}`);
        }
        if (!options.allowObjectSmallerThanBufferSize && buffer3.length !== size) {
          throw new BSONError(`buffer length ${buffer3.length} must === bson size ${size}`);
        }
        if (size + index > buffer3.byteLength) {
          throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer3.byteLength})`);
        }
        if (buffer3[index + size - 1] !== 0) {
          throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
        }
        return deserializeObject(buffer3, index, options, isArray);
      }
      var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
      function deserializeObject(buffer3, index, options, isArray = false) {
        const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
        const raw = options["raw"] == null ? false : options["raw"];
        const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
        const promoteBuffers = options.promoteBuffers ?? false;
        const promoteLongs = options.promoteLongs ?? true;
        const promoteValues = options.promoteValues ?? true;
        const useBigInt64 = options.useBigInt64 ?? false;
        if (useBigInt64 && !promoteValues) {
          throw new BSONError("Must either request bigint or Long for int64 deserialization");
        }
        if (useBigInt64 && !promoteLongs) {
          throw new BSONError("Must either request bigint or Long for int64 deserialization");
        }
        const validation = options.validation == null ? { utf8: true } : options.validation;
        let globalUTFValidation = true;
        let validationSetting;
        let utf8KeysSet;
        const utf8ValidatedKeys = validation.utf8;
        if (typeof utf8ValidatedKeys === "boolean") {
          validationSetting = utf8ValidatedKeys;
        } else {
          globalUTFValidation = false;
          const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
            return utf8ValidatedKeys[key];
          });
          if (utf8ValidationValues.length === 0) {
            throw new BSONError("UTF-8 validation setting cannot be empty");
          }
          if (typeof utf8ValidationValues[0] !== "boolean") {
            throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
          }
          validationSetting = utf8ValidationValues[0];
          if (!utf8ValidationValues.every((item) => item === validationSetting)) {
            throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
          }
        }
        if (!globalUTFValidation) {
          utf8KeysSet = /* @__PURE__ */ new Set();
          for (const key of Object.keys(utf8ValidatedKeys)) {
            utf8KeysSet.add(key);
          }
        }
        const startIndex = index;
        if (buffer3.length < 5)
          throw new BSONError("corrupt bson message < 5 bytes long");
        const size = NumberUtils.getInt32LE(buffer3, index);
        index += 4;
        if (size < 5 || size > buffer3.length)
          throw new BSONError("corrupt bson message");
        const object = isArray ? [] : {};
        let arrayIndex = 0;
        const done = false;
        let isPossibleDBRef = isArray ? false : null;
        while (!done) {
          const elementType = buffer3[index++];
          if (elementType === 0)
            break;
          let i = index;
          while (buffer3[i] !== 0 && i < buffer3.length) {
            i++;
          }
          if (i >= buffer3.byteLength)
            throw new BSONError("Bad BSON Document: illegal CString");
          const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer3, index, i, false);
          let shouldValidateKey = true;
          if (globalUTFValidation || utf8KeysSet?.has(name)) {
            shouldValidateKey = validationSetting;
          } else {
            shouldValidateKey = !validationSetting;
          }
          if (isPossibleDBRef !== false && name[0] === "$") {
            isPossibleDBRef = allowedDBRefKeys.test(name);
          }
          let value;
          index = i + 1;
          if (elementType === BSON_DATA_STRING) {
            const stringSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (stringSize <= 0 || stringSize > buffer3.length - index || buffer3[index + stringSize - 1] !== 0) {
              throw new BSONError("bad string length in bson");
            }
            value = ByteUtils.toUTF8(buffer3, index, index + stringSize - 1, shouldValidateKey);
            index = index + stringSize;
          } else if (elementType === BSON_DATA_OID) {
            const oid = ByteUtils.allocateUnsafe(12);
            for (let i2 = 0; i2 < 12; i2++)
              oid[i2] = buffer3[index + i2];
            value = new ObjectId(oid);
            index = index + 12;
          } else if (elementType === BSON_DATA_INT && promoteValues === false) {
            value = new Int32(NumberUtils.getInt32LE(buffer3, index));
            index += 4;
          } else if (elementType === BSON_DATA_INT) {
            value = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
          } else if (elementType === BSON_DATA_NUMBER) {
            value = NumberUtils.getFloat64LE(buffer3, index);
            index += 8;
            if (promoteValues === false)
              value = new Double(value);
          } else if (elementType === BSON_DATA_DATE) {
            const lowBits = NumberUtils.getInt32LE(buffer3, index);
            const highBits = NumberUtils.getInt32LE(buffer3, index + 4);
            index += 8;
            value = new Date(new Long2(lowBits, highBits).toNumber());
          } else if (elementType === BSON_DATA_BOOLEAN) {
            if (buffer3[index] !== 0 && buffer3[index] !== 1)
              throw new BSONError("illegal boolean type value");
            value = buffer3[index++] === 1;
          } else if (elementType === BSON_DATA_OBJECT) {
            const _index = index;
            const objectSize = NumberUtils.getInt32LE(buffer3, index);
            if (objectSize <= 0 || objectSize > buffer3.length - index)
              throw new BSONError("bad embedded document length in bson");
            if (raw) {
              value = buffer3.slice(index, index + objectSize);
            } else {
              let objectOptions = options;
              if (!globalUTFValidation) {
                objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
              }
              value = deserializeObject(buffer3, _index, objectOptions, false);
            }
            index = index + objectSize;
          } else if (elementType === BSON_DATA_ARRAY) {
            const _index = index;
            const objectSize = NumberUtils.getInt32LE(buffer3, index);
            let arrayOptions = options;
            const stopIndex = index + objectSize;
            if (fieldsAsRaw && fieldsAsRaw[name]) {
              arrayOptions = { ...options, raw: true };
            }
            if (!globalUTFValidation) {
              arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
            }
            value = deserializeObject(buffer3, _index, arrayOptions, true);
            index = index + objectSize;
            if (buffer3[index - 1] !== 0)
              throw new BSONError("invalid array terminator byte");
            if (index !== stopIndex)
              throw new BSONError("corrupted array bson");
          } else if (elementType === BSON_DATA_UNDEFINED) {
            value = void 0;
          } else if (elementType === BSON_DATA_NULL) {
            value = null;
          } else if (elementType === BSON_DATA_LONG) {
            if (useBigInt64) {
              value = NumberUtils.getBigInt64LE(buffer3, index);
              index += 8;
            } else {
              const lowBits = NumberUtils.getInt32LE(buffer3, index);
              const highBits = NumberUtils.getInt32LE(buffer3, index + 4);
              index += 8;
              const long = new Long2(lowBits, highBits);
              if (promoteLongs && promoteValues === true) {
                value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
              } else {
                value = long;
              }
            }
          } else if (elementType === BSON_DATA_DECIMAL128) {
            const bytes = ByteUtils.allocateUnsafe(16);
            for (let i2 = 0; i2 < 16; i2++)
              bytes[i2] = buffer3[index + i2];
            index = index + 16;
            value = new Decimal128(bytes);
          } else if (elementType === BSON_DATA_BINARY) {
            let binarySize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            const totalBinarySize = binarySize;
            const subType = buffer3[index++];
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found");
            if (binarySize > buffer3.byteLength)
              throw new BSONError("Binary type size larger than document size");
            if (buffer3["slice"] != null) {
              if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
                binarySize = NumberUtils.getInt32LE(buffer3, index);
                index += 4;
                if (binarySize < 0)
                  throw new BSONError("Negative binary type element size found for subtype 0x02");
                if (binarySize > totalBinarySize - 4)
                  throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
                if (binarySize < totalBinarySize - 4)
                  throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
              }
              if (promoteBuffers && promoteValues) {
                value = ByteUtils.toLocalBufferType(buffer3.slice(index, index + binarySize));
              } else {
                value = new Binary(buffer3.slice(index, index + binarySize), subType);
                if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
                  value = value.toUUID();
                }
              }
            } else {
              if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
                binarySize = NumberUtils.getInt32LE(buffer3, index);
                index += 4;
                if (binarySize < 0)
                  throw new BSONError("Negative binary type element size found for subtype 0x02");
                if (binarySize > totalBinarySize - 4)
                  throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
                if (binarySize < totalBinarySize - 4)
                  throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
              }
              if (promoteBuffers && promoteValues) {
                value = ByteUtils.allocateUnsafe(binarySize);
                for (i = 0; i < binarySize; i++) {
                  value[i] = buffer3[index + i];
                }
              } else {
                value = new Binary(buffer3.slice(index, index + binarySize), subType);
                if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
                  value = value.toUUID();
                }
              }
            }
            index = index + binarySize;
          } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
            i = index;
            while (buffer3[i] !== 0 && i < buffer3.length) {
              i++;
            }
            if (i >= buffer3.length)
              throw new BSONError("Bad BSON Document: illegal CString");
            const source = ByteUtils.toUTF8(buffer3, index, i, false);
            index = i + 1;
            i = index;
            while (buffer3[i] !== 0 && i < buffer3.length) {
              i++;
            }
            if (i >= buffer3.length)
              throw new BSONError("Bad BSON Document: illegal CString");
            const regExpOptions = ByteUtils.toUTF8(buffer3, index, i, false);
            index = i + 1;
            const optionsArray = new Array(regExpOptions.length);
            for (i = 0; i < regExpOptions.length; i++) {
              switch (regExpOptions[i]) {
                case "m":
                  optionsArray[i] = "m";
                  break;
                case "s":
                  optionsArray[i] = "g";
                  break;
                case "i":
                  optionsArray[i] = "i";
                  break;
              }
            }
            value = new RegExp(source, optionsArray.join(""));
          } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
            i = index;
            while (buffer3[i] !== 0 && i < buffer3.length) {
              i++;
            }
            if (i >= buffer3.length)
              throw new BSONError("Bad BSON Document: illegal CString");
            const source = ByteUtils.toUTF8(buffer3, index, i, false);
            index = i + 1;
            i = index;
            while (buffer3[i] !== 0 && i < buffer3.length) {
              i++;
            }
            if (i >= buffer3.length)
              throw new BSONError("Bad BSON Document: illegal CString");
            const regExpOptions = ByteUtils.toUTF8(buffer3, index, i, false);
            index = i + 1;
            value = new BSONRegExp(source, regExpOptions);
          } else if (elementType === BSON_DATA_SYMBOL) {
            const stringSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (stringSize <= 0 || stringSize > buffer3.length - index || buffer3[index + stringSize - 1] !== 0) {
              throw new BSONError("bad string length in bson");
            }
            const symbol = ByteUtils.toUTF8(buffer3, index, index + stringSize - 1, shouldValidateKey);
            value = promoteValues ? symbol : new BSONSymbol(symbol);
            index = index + stringSize;
          } else if (elementType === BSON_DATA_TIMESTAMP) {
            value = new Timestamp({
              i: NumberUtils.getUint32LE(buffer3, index),
              t: NumberUtils.getUint32LE(buffer3, index + 4)
            });
            index += 8;
          } else if (elementType === BSON_DATA_MIN_KEY) {
            value = new MinKey();
          } else if (elementType === BSON_DATA_MAX_KEY) {
            value = new MaxKey();
          } else if (elementType === BSON_DATA_CODE) {
            const stringSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (stringSize <= 0 || stringSize > buffer3.length - index || buffer3[index + stringSize - 1] !== 0) {
              throw new BSONError("bad string length in bson");
            }
            const functionString = ByteUtils.toUTF8(buffer3, index, index + stringSize - 1, shouldValidateKey);
            value = new Code(functionString);
            index = index + stringSize;
          } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
            const totalSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (totalSize < 4 + 4 + 4 + 1) {
              throw new BSONError("code_w_scope total size shorter minimum expected length");
            }
            const stringSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (stringSize <= 0 || stringSize > buffer3.length - index || buffer3[index + stringSize - 1] !== 0) {
              throw new BSONError("bad string length in bson");
            }
            const functionString = ByteUtils.toUTF8(buffer3, index, index + stringSize - 1, shouldValidateKey);
            index = index + stringSize;
            const _index = index;
            const objectSize = NumberUtils.getInt32LE(buffer3, index);
            const scopeObject = deserializeObject(buffer3, _index, options, false);
            index = index + objectSize;
            if (totalSize < 4 + 4 + objectSize + stringSize) {
              throw new BSONError("code_w_scope total size is too short, truncating scope");
            }
            if (totalSize > 4 + 4 + objectSize + stringSize) {
              throw new BSONError("code_w_scope total size is too long, clips outer document");
            }
            value = new Code(functionString, scopeObject);
          } else if (elementType === BSON_DATA_DBPOINTER) {
            const stringSize = NumberUtils.getInt32LE(buffer3, index);
            index += 4;
            if (stringSize <= 0 || stringSize > buffer3.length - index || buffer3[index + stringSize - 1] !== 0)
              throw new BSONError("bad string length in bson");
            const namespace = ByteUtils.toUTF8(buffer3, index, index + stringSize - 1, shouldValidateKey);
            index = index + stringSize;
            const oidBuffer = ByteUtils.allocateUnsafe(12);
            for (let i2 = 0; i2 < 12; i2++)
              oidBuffer[i2] = buffer3[index + i2];
            const oid = new ObjectId(oidBuffer);
            index = index + 12;
            value = new DBRef(namespace, oid);
          } else {
            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
          }
          if (name === "__proto__") {
            Object.defineProperty(object, name, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            object[name] = value;
          }
        }
        if (size !== index - startIndex) {
          if (isArray)
            throw new BSONError("corrupt array bson");
          throw new BSONError("corrupt object bson");
        }
        if (!isPossibleDBRef)
          return object;
        if (isDBRefLike(object)) {
          const copy = Object.assign({}, object);
          delete copy.$ref;
          delete copy.$id;
          delete copy.$db;
          return new DBRef(object.$ref, object.$id, object.$db, copy);
        }
        return object;
      }
      var regexp = /\x00/;
      var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
      function serializeString(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_STRING;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes + 1;
        buffer3[index - 1] = 0;
        const size = ByteUtils.encodeUTF8Into(buffer3, value, index + 4);
        NumberUtils.setInt32LE(buffer3, index, size + 1);
        index = index + 4 + size;
        buffer3[index++] = 0;
        return index;
      }
      function serializeNumber(buffer3, key, value, index) {
        const isNegativeZero = Object.is(value, -0);
        const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
        buffer3[index++] = type;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        if (type === BSON_DATA_INT) {
          index += NumberUtils.setInt32LE(buffer3, index, value);
        } else {
          index += NumberUtils.setFloat64LE(buffer3, index, value);
        }
        return index;
      }
      function serializeBigInt(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_LONG;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index += numberOfWrittenBytes;
        buffer3[index++] = 0;
        index += NumberUtils.setBigInt64LE(buffer3, index, value);
        return index;
      }
      function serializeNull(buffer3, key, _, index) {
        buffer3[index++] = BSON_DATA_NULL;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        return index;
      }
      function serializeBoolean(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_BOOLEAN;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        buffer3[index++] = value ? 1 : 0;
        return index;
      }
      function serializeDate(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_DATE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const dateInMilis = Long2.fromNumber(value.getTime());
        const lowBits = dateInMilis.getLowBits();
        const highBits = dateInMilis.getHighBits();
        index += NumberUtils.setInt32LE(buffer3, index, lowBits);
        index += NumberUtils.setInt32LE(buffer3, index, highBits);
        return index;
      }
      function serializeRegExp(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_REGEXP;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        if (value.source && value.source.match(regexp) != null) {
          throw new BSONError("value " + value.source + " must not contain null bytes");
        }
        index = index + ByteUtils.encodeUTF8Into(buffer3, value.source, index);
        buffer3[index++] = 0;
        if (value.ignoreCase)
          buffer3[index++] = 105;
        if (value.global)
          buffer3[index++] = 115;
        if (value.multiline)
          buffer3[index++] = 109;
        buffer3[index++] = 0;
        return index;
      }
      function serializeBSONRegExp(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_REGEXP;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        if (value.pattern.match(regexp) != null) {
          throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
        }
        index = index + ByteUtils.encodeUTF8Into(buffer3, value.pattern, index);
        buffer3[index++] = 0;
        const sortedOptions = value.options.split("").sort().join("");
        index = index + ByteUtils.encodeUTF8Into(buffer3, sortedOptions, index);
        buffer3[index++] = 0;
        return index;
      }
      function serializeMinMax(buffer3, key, value, index) {
        if (value === null) {
          buffer3[index++] = BSON_DATA_NULL;
        } else if (value._bsontype === "MinKey") {
          buffer3[index++] = BSON_DATA_MIN_KEY;
        } else {
          buffer3[index++] = BSON_DATA_MAX_KEY;
        }
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        return index;
      }
      function serializeObjectId(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_OID;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        index += value.serializeInto(buffer3, index);
        return index;
      }
      function serializeBuffer(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_BINARY;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const size = value.length;
        index += NumberUtils.setInt32LE(buffer3, index, size);
        buffer3[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
        if (size <= 16) {
          for (let i = 0; i < size; i++)
            buffer3[index + i] = value[i];
        } else {
          buffer3.set(value, index);
        }
        index = index + size;
        return index;
      }
      function serializeObject(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
        if (path.has(value)) {
          throw new BSONError("Cannot convert circular structure to BSON");
        }
        path.add(value);
        buffer3[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const endIndex = serializeInto(buffer3, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
        path.delete(value);
        return endIndex;
      }
      function serializeDecimal128(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_DECIMAL128;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        for (let i = 0; i < 16; i++)
          buffer3[index + i] = value.bytes[i];
        return index + 16;
      }
      function serializeLong(buffer3, key, value, index) {
        buffer3[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const lowBits = value.getLowBits();
        const highBits = value.getHighBits();
        index += NumberUtils.setInt32LE(buffer3, index, lowBits);
        index += NumberUtils.setInt32LE(buffer3, index, highBits);
        return index;
      }
      function serializeInt32(buffer3, key, value, index) {
        value = value.valueOf();
        buffer3[index++] = BSON_DATA_INT;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        index += NumberUtils.setInt32LE(buffer3, index, value);
        return index;
      }
      function serializeDouble(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_NUMBER;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        index += NumberUtils.setFloat64LE(buffer3, index, value.value);
        return index;
      }
      function serializeFunction(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_CODE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const functionString = value.toString();
        const size = ByteUtils.encodeUTF8Into(buffer3, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer3, index, size);
        index = index + 4 + size - 1;
        buffer3[index++] = 0;
        return index;
      }
      function serializeCode(buffer3, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
        if (value.scope && typeof value.scope === "object") {
          buffer3[index++] = BSON_DATA_CODE_W_SCOPE;
          const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
          index = index + numberOfWrittenBytes;
          buffer3[index++] = 0;
          let startIndex = index;
          const functionString = value.code;
          index = index + 4;
          const codeSize = ByteUtils.encodeUTF8Into(buffer3, functionString, index + 4) + 1;
          NumberUtils.setInt32LE(buffer3, index, codeSize);
          buffer3[index + 4 + codeSize - 1] = 0;
          index = index + codeSize + 4;
          const endIndex = serializeInto(buffer3, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
          index = endIndex - 1;
          const totalSize = endIndex - startIndex;
          startIndex += NumberUtils.setInt32LE(buffer3, startIndex, totalSize);
          buffer3[index++] = 0;
        } else {
          buffer3[index++] = BSON_DATA_CODE;
          const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
          index = index + numberOfWrittenBytes;
          buffer3[index++] = 0;
          const functionString = value.code.toString();
          const size = ByteUtils.encodeUTF8Into(buffer3, functionString, index + 4) + 1;
          NumberUtils.setInt32LE(buffer3, index, size);
          index = index + 4 + size - 1;
          buffer3[index++] = 0;
        }
        return index;
      }
      function serializeBinary(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_BINARY;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const data = value.buffer;
        let size = value.position;
        if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
          size = size + 4;
        index += NumberUtils.setInt32LE(buffer3, index, size);
        buffer3[index++] = value.sub_type;
        if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
          size = size - 4;
          index += NumberUtils.setInt32LE(buffer3, index, size);
        }
        if (size <= 16) {
          for (let i = 0; i < size; i++)
            buffer3[index + i] = data[i];
        } else {
          buffer3.set(data, index);
        }
        index = index + value.position;
        return index;
      }
      function serializeSymbol(buffer3, key, value, index) {
        buffer3[index++] = BSON_DATA_SYMBOL;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        const size = ByteUtils.encodeUTF8Into(buffer3, value.value, index + 4) + 1;
        NumberUtils.setInt32LE(buffer3, index, size);
        index = index + 4 + size - 1;
        buffer3[index++] = 0;
        return index;
      }
      function serializeDBRef(buffer3, key, value, index, depth, serializeFunctions, path) {
        buffer3[index++] = BSON_DATA_OBJECT;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer3, key, index);
        index = index + numberOfWrittenBytes;
        buffer3[index++] = 0;
        let startIndex = index;
        let output = {
          $ref: value.collection || value.namespace,
          $id: value.oid
        };
        if (value.db != null) {
          output.$db = value.db;
        }
        output = Object.assign(output, value.fields);
        const endIndex = serializeInto(buffer3, output, false, index, depth + 1, serializeFunctions, true, path);
        const size = endIndex - startIndex;
        startIndex += NumberUtils.setInt32LE(buffer3, index, size);
        return endIndex;
      }
      function serializeInto(buffer3, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
        if (path == null) {
          if (object == null) {
            buffer3[0] = 5;
            buffer3[1] = 0;
            buffer3[2] = 0;
            buffer3[3] = 0;
            buffer3[4] = 0;
            return 5;
          }
          if (Array.isArray(object)) {
            throw new BSONError("serialize does not support an array as the root input");
          }
          if (typeof object !== "object") {
            throw new BSONError("serialize does not support non-object as the root input");
          } else if ("_bsontype" in object && typeof object._bsontype === "string") {
            throw new BSONError(`BSON types cannot be serialized as a document`);
          } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
          }
          path = /* @__PURE__ */ new Set();
        }
        path.add(object);
        let index = startingIndex + 4;
        if (Array.isArray(object)) {
          for (let i = 0; i < object.length; i++) {
            const key = `${i}`;
            let value = object[i];
            if (typeof value?.toBSON === "function") {
              value = value.toBSON();
            }
            if (typeof value === "string") {
              index = serializeString(buffer3, key, value, index);
            } else if (typeof value === "number") {
              index = serializeNumber(buffer3, key, value, index);
            } else if (typeof value === "bigint") {
              index = serializeBigInt(buffer3, key, value, index);
            } else if (typeof value === "boolean") {
              index = serializeBoolean(buffer3, key, value, index);
            } else if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer3, key, value, index);
            } else if (value === void 0) {
              index = serializeNull(buffer3, key, value, index);
            } else if (value === null) {
              index = serializeNull(buffer3, key, value, index);
            } else if (isUint8Array(value)) {
              index = serializeBuffer(buffer3, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer3, key, value, index);
            } else if (typeof value === "object" && value._bsontype == null) {
              index = serializeObject(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer3, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer3, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer3, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer3, key, value, index);
            } else if (typeof value === "function" && serializeFunctions) {
              index = serializeFunction(buffer3, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer3, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer3, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer3, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer3, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer3, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer3, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          }
        } else if (object instanceof Map || isMap(object)) {
          const iterator = object.entries();
          let done = false;
          while (!done) {
            const entry = iterator.next();
            done = !!entry.done;
            if (done)
              continue;
            const key = entry.value[0];
            let value = entry.value[1];
            if (typeof value?.toBSON === "function") {
              value = value.toBSON();
            }
            const type = typeof value;
            if (typeof key === "string" && !ignoreKeys.has(key)) {
              if (key.match(regexp) != null) {
                throw new BSONError("key " + key + " must not contain null bytes");
              }
              if (checkKeys) {
                if ("$" === key[0]) {
                  throw new BSONError("key " + key + " must not start with '$'");
                } else if (key.includes(".")) {
                  throw new BSONError("key " + key + " must not contain '.'");
                }
              }
            }
            if (type === "string") {
              index = serializeString(buffer3, key, value, index);
            } else if (type === "number") {
              index = serializeNumber(buffer3, key, value, index);
            } else if (type === "bigint") {
              index = serializeBigInt(buffer3, key, value, index);
            } else if (type === "boolean") {
              index = serializeBoolean(buffer3, key, value, index);
            } else if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer3, key, value, index);
            } else if (value === null || value === void 0 && ignoreUndefined === false) {
              index = serializeNull(buffer3, key, value, index);
            } else if (isUint8Array(value)) {
              index = serializeBuffer(buffer3, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer3, key, value, index);
            } else if (type === "object" && value._bsontype == null) {
              index = serializeObject(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer3, key, value, index);
            } else if (type === "object" && value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer3, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer3, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer3, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (typeof value === "function" && serializeFunctions) {
              index = serializeFunction(buffer3, key, value, index);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer3, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer3, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer3, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer3, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer3, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer3, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          }
        } else {
          if (typeof object?.toBSON === "function") {
            object = object.toBSON();
            if (object != null && typeof object !== "object") {
              throw new BSONError("toBSON function did not return an object");
            }
          }
          for (const key of Object.keys(object)) {
            let value = object[key];
            if (typeof value?.toBSON === "function") {
              value = value.toBSON();
            }
            const type = typeof value;
            if (typeof key === "string" && !ignoreKeys.has(key)) {
              if (key.match(regexp) != null) {
                throw new BSONError("key " + key + " must not contain null bytes");
              }
              if (checkKeys) {
                if ("$" === key[0]) {
                  throw new BSONError("key " + key + " must not start with '$'");
                } else if (key.includes(".")) {
                  throw new BSONError("key " + key + " must not contain '.'");
                }
              }
            }
            if (type === "string") {
              index = serializeString(buffer3, key, value, index);
            } else if (type === "number") {
              index = serializeNumber(buffer3, key, value, index);
            } else if (type === "bigint") {
              index = serializeBigInt(buffer3, key, value, index);
            } else if (type === "boolean") {
              index = serializeBoolean(buffer3, key, value, index);
            } else if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer3, key, value, index);
            } else if (value === void 0) {
              if (ignoreUndefined === false)
                index = serializeNull(buffer3, key, value, index);
            } else if (value === null) {
              index = serializeNull(buffer3, key, value, index);
            } else if (isUint8Array(value)) {
              index = serializeBuffer(buffer3, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer3, key, value, index);
            } else if (type === "object" && value._bsontype == null) {
              index = serializeObject(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer3, key, value, index);
            } else if (type === "object" && value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer3, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer3, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer3, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer3, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (typeof value === "function" && serializeFunctions) {
              index = serializeFunction(buffer3, key, value, index);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer3, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer3, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer3, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer3, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer3, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer3, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          }
        }
        path.delete(object);
        buffer3[index++] = 0;
        const size = index - startingIndex;
        startingIndex += NumberUtils.setInt32LE(buffer3, startingIndex, size);
        return index;
      }
      function isBSONType(value) {
        return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
      }
      var keysToCodecs = {
        $oid: ObjectId,
        $binary: Binary,
        $uuid: Binary,
        $symbol: BSONSymbol,
        $numberInt: Int32,
        $numberDecimal: Decimal128,
        $numberDouble: Double,
        $numberLong: Long2,
        $minKey: MinKey,
        $maxKey: MaxKey,
        $regex: BSONRegExp,
        $regularExpression: BSONRegExp,
        $timestamp: Timestamp
      };
      function deserializeValue(value, options = {}) {
        if (typeof value === "number") {
          const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
          const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
          if (options.relaxed || options.legacy) {
            return value;
          }
          if (Number.isInteger(value) && !Object.is(value, -0)) {
            if (in32BitRange) {
              return new Int32(value);
            }
            if (in64BitRange) {
              if (options.useBigInt64) {
                return BigInt(value);
              }
              return Long2.fromNumber(value);
            }
          }
          return new Double(value);
        }
        if (value == null || typeof value !== "object")
          return value;
        if (value.$undefined)
          return null;
        const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
        for (let i = 0; i < keys.length; i++) {
          const c = keysToCodecs[keys[i]];
          if (c)
            return c.fromExtendedJSON(value, options);
        }
        if (value.$date != null) {
          const d = value.$date;
          const date = /* @__PURE__ */ new Date();
          if (options.legacy) {
            if (typeof d === "number")
              date.setTime(d);
            else if (typeof d === "string")
              date.setTime(Date.parse(d));
            else if (typeof d === "bigint")
              date.setTime(Number(d));
            else
              throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
          } else {
            if (typeof d === "string")
              date.setTime(Date.parse(d));
            else if (Long2.isLong(d))
              date.setTime(d.toNumber());
            else if (typeof d === "number" && options.relaxed)
              date.setTime(d);
            else if (typeof d === "bigint")
              date.setTime(Number(d));
            else
              throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
          }
          return date;
        }
        if (value.$code != null) {
          const copy = Object.assign({}, value);
          if (value.$scope) {
            copy.$scope = deserializeValue(value.$scope);
          }
          return Code.fromExtendedJSON(value);
        }
        if (isDBRefLike(value) || value.$dbPointer) {
          const v = value.$ref ? value : value.$dbPointer;
          if (v instanceof DBRef)
            return v;
          const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
          let valid = true;
          dollarKeys.forEach((k) => {
            if (["$ref", "$id", "$db"].indexOf(k) === -1)
              valid = false;
          });
          if (valid)
            return DBRef.fromExtendedJSON(v);
        }
        return value;
      }
      function serializeArray(array, options) {
        return array.map((v, index) => {
          options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
          try {
            return serializeValue(v, options);
          } finally {
            options.seenObjects.pop();
          }
        });
      }
      function getISOString(date) {
        const isoStr = date.toISOString();
        return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
      }
      function serializeValue(value, options) {
        if (value instanceof Map || isMap(value)) {
          const obj = /* @__PURE__ */ Object.create(null);
          for (const [k, v] of value) {
            if (typeof k !== "string") {
              throw new BSONError("Can only serialize maps with string keys");
            }
            obj[k] = v;
          }
          return serializeValue(obj, options);
        }
        if ((typeof value === "object" || typeof value === "function") && value !== null) {
          const index = options.seenObjects.findIndex((entry) => entry.obj === value);
          if (index !== -1) {
            const props = options.seenObjects.map((entry) => entry.propertyName);
            const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
            const alreadySeen = props[index];
            const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
            const current = props[props.length - 1];
            const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
            const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
            throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`);
          }
          options.seenObjects[options.seenObjects.length - 1].obj = value;
        }
        if (Array.isArray(value))
          return serializeArray(value, options);
        if (value === void 0)
          return null;
        if (value instanceof Date || isDate(value)) {
          const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
          if (options.legacy) {
            return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
          }
          return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
        }
        if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
          if (Number.isInteger(value) && !Object.is(value, -0)) {
            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
              return { $numberInt: value.toString() };
            }
            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
              return { $numberLong: value.toString() };
            }
          }
          return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
        }
        if (typeof value === "bigint") {
          if (!options.relaxed) {
            return { $numberLong: BigInt.asIntN(64, value).toString() };
          }
          return Number(BigInt.asIntN(64, value));
        }
        if (value instanceof RegExp || isRegExp(value)) {
          let flags = value.flags;
          if (flags === void 0) {
            const match = value.toString().match(/[gimuy]*$/);
            if (match) {
              flags = match[0];
            }
          }
          const rx = new BSONRegExp(value.source, flags);
          return rx.toExtendedJSON(options);
        }
        if (value != null && typeof value === "object")
          return serializeDocument(value, options);
        return value;
      }
      var BSON_TYPE_MAPPINGS = {
        Binary: (o) => new Binary(o.value(), o.sub_type),
        Code: (o) => new Code(o.code, o.scope),
        DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
        Decimal128: (o) => new Decimal128(o.bytes),
        Double: (o) => new Double(o.value),
        Int32: (o) => new Int32(o.value),
        Long: (o) => Long2.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
        MaxKey: () => new MaxKey(),
        MinKey: () => new MinKey(),
        ObjectId: (o) => new ObjectId(o),
        BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
        BSONSymbol: (o) => new BSONSymbol(o.value),
        Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
      };
      function serializeDocument(doc, options) {
        if (doc == null || typeof doc !== "object")
          throw new BSONError("not an object instance");
        const bsontype = doc._bsontype;
        if (typeof bsontype === "undefined") {
          const _doc = {};
          for (const name of Object.keys(doc)) {
            options.seenObjects.push({ propertyName: name, obj: null });
            try {
              const value = serializeValue(doc[name], options);
              if (name === "__proto__") {
                Object.defineProperty(_doc, name, {
                  value,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              } else {
                _doc[name] = value;
              }
            } finally {
              options.seenObjects.pop();
            }
          }
          return _doc;
        } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (isBSONType(doc)) {
          let outDoc = doc;
          if (typeof outDoc.toExtendedJSON !== "function") {
            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
            if (!mapper) {
              throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
            }
            outDoc = mapper(outDoc);
          }
          if (bsontype === "Code" && outDoc.scope) {
            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
          } else if (bsontype === "DBRef" && outDoc.oid) {
            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
          }
          return outDoc.toExtendedJSON(options);
        } else {
          throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
        }
      }
      function parse2(text, options) {
        const ejsonOptions = {
          useBigInt64: options?.useBigInt64 ?? false,
          relaxed: options?.relaxed ?? true,
          legacy: options?.legacy ?? false
        };
        return JSON.parse(text, (key, value) => {
          if (key.indexOf("\0") !== -1) {
            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
          }
          return deserializeValue(value, ejsonOptions);
        });
      }
      function stringify(value, replacer, space, options) {
        if (space != null && typeof space === "object") {
          options = space;
          space = 0;
        }
        if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
          options = replacer;
          replacer = void 0;
          space = 0;
        }
        const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
          seenObjects: [{ propertyName: "(root)", obj: null }]
        });
        const doc = serializeValue(value, serializeOptions);
        return JSON.stringify(doc, replacer, space);
      }
      function EJSONserialize(value, options) {
        options = options || {};
        return JSON.parse(stringify(value, options));
      }
      function EJSONdeserialize(ejson, options) {
        options = options || {};
        return parse2(JSON.stringify(ejson), options);
      }
      var EJSON = /* @__PURE__ */ Object.create(null);
      EJSON.parse = parse2;
      EJSON.stringify = stringify;
      EJSON.serialize = EJSONserialize;
      EJSON.deserialize = EJSONdeserialize;
      Object.freeze(EJSON);
      function getSize(source, offset) {
        try {
          return NumberUtils.getNonnegativeInt32LE(source, offset);
        } catch (cause) {
          throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
        }
      }
      function findNull(bytes, offset) {
        let nullTerminatorOffset = offset;
        for (; bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
          ;
        if (nullTerminatorOffset === bytes.length - 1) {
          throw new BSONOffsetError("Null terminator not found", offset);
        }
        return nullTerminatorOffset;
      }
      function parseToElements(bytes, startOffset = 0) {
        startOffset ??= 0;
        if (bytes.length < 5) {
          throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
        }
        const documentSize = getSize(bytes, startOffset);
        if (documentSize > bytes.length - startOffset) {
          throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
        }
        if (bytes[startOffset + documentSize - 1] !== 0) {
          throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
        }
        const elements = [];
        let offset = startOffset + 4;
        while (offset <= documentSize + startOffset) {
          const type = bytes[offset];
          offset += 1;
          if (type === 0) {
            if (offset - startOffset !== documentSize) {
              throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
            }
            break;
          }
          const nameOffset = offset;
          const nameLength = findNull(bytes, offset) - nameOffset;
          offset += nameLength + 1;
          let length;
          if (type === 1 || type === 18 || type === 9 || type === 17) {
            length = 8;
          } else if (type === 16) {
            length = 4;
          } else if (type === 7) {
            length = 12;
          } else if (type === 19) {
            length = 16;
          } else if (type === 8) {
            length = 1;
          } else if (type === 10 || type === 6 || type === 127 || type === 255) {
            length = 0;
          } else if (type === 11) {
            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
          } else if (type === 3 || type === 4 || type === 15) {
            length = getSize(bytes, offset);
          } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {
            length = getSize(bytes, offset) + 4;
            if (type === 5) {
              length += 1;
            }
            if (type === 12) {
              length += 12;
            }
          } else {
            throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
          }
          if (length > documentSize) {
            throw new BSONOffsetError("value reports length larger than document", offset);
          }
          elements.push([type, nameOffset, nameLength, offset, length]);
          offset += length;
        }
        return elements;
      }
      var onDemand = /* @__PURE__ */ Object.create(null);
      onDemand.parseToElements = parseToElements;
      onDemand.ByteUtils = ByteUtils;
      onDemand.NumberUtils = NumberUtils;
      Object.freeze(onDemand);
      var MAXSIZE = 1024 * 1024 * 17;
      var buffer2 = ByteUtils.allocate(MAXSIZE);
      function setInternalBufferSize(size) {
        if (buffer2.length < size) {
          buffer2 = ByteUtils.allocate(size);
        }
      }
      function serialize(object, options = {}) {
        const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
        const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
        if (buffer2.length < minInternalBufferSize) {
          buffer2 = ByteUtils.allocate(minInternalBufferSize);
        }
        const serializationIndex = serializeInto(buffer2, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
        const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
        finishedBuffer.set(buffer2.subarray(0, serializationIndex), 0);
        return finishedBuffer;
      }
      function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
        const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
        const startIndex = typeof options.index === "number" ? options.index : 0;
        const serializationIndex = serializeInto(buffer2, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
        finalBuffer.set(buffer2.subarray(0, serializationIndex), startIndex);
        return startIndex + serializationIndex - 1;
      }
      function deserialize(buffer3, options = {}) {
        return internalDeserialize(ByteUtils.toLocalBufferType(buffer3), options);
      }
      function calculateObjectSize(object, options = {}) {
        options = options || {};
        const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
        return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
      }
      function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
        const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
        const bufferData = ByteUtils.toLocalBufferType(data);
        let index = startIndex;
        for (let i = 0; i < numberOfDocuments; i++) {
          const size = NumberUtils.getInt32LE(bufferData, index);
          internalOptions.index = index;
          documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
          index = index + size;
        }
        return index;
      }
      var bson = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BSONError,
        BSONOffsetError,
        BSONRegExp,
        BSONRuntimeError,
        BSONSymbol,
        BSONType,
        BSONValue,
        BSONVersionError,
        Binary,
        Code,
        DBRef,
        Decimal128,
        Double,
        EJSON,
        Int32,
        Long: Long2,
        MaxKey,
        MinKey,
        ObjectId,
        Timestamp,
        UUID,
        calculateObjectSize,
        deserialize,
        deserializeStream,
        onDemand,
        serialize,
        serializeWithBufferAndIndex,
        setInternalBufferSize
      });
      exports.BSON = bson;
      exports.BSONError = BSONError;
      exports.BSONOffsetError = BSONOffsetError;
      exports.BSONRegExp = BSONRegExp;
      exports.BSONRuntimeError = BSONRuntimeError;
      exports.BSONSymbol = BSONSymbol;
      exports.BSONType = BSONType;
      exports.BSONValue = BSONValue;
      exports.BSONVersionError = BSONVersionError;
      exports.Binary = Binary;
      exports.Code = Code;
      exports.DBRef = DBRef;
      exports.Decimal128 = Decimal128;
      exports.Double = Double;
      exports.EJSON = EJSON;
      exports.Int32 = Int32;
      exports.Long = Long2;
      exports.MaxKey = MaxKey;
      exports.MinKey = MinKey;
      exports.ObjectId = ObjectId;
      exports.Timestamp = Timestamp;
      exports.UUID = UUID;
      exports.calculateObjectSize = calculateObjectSize;
      exports.deserialize = deserialize;
      exports.deserializeStream = deserializeStream;
      exports.onDemand = onDemand;
      exports.serialize = serialize;
      exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
      exports.setInternalBufferSize = setInternalBufferSize;
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/primordials.js
  var require_primordials = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = {
        ArrayIsArray(self2) {
          return Array.isArray(self2);
        },
        ArrayPrototypeIncludes(self2, el) {
          return self2.includes(el);
        },
        ArrayPrototypeIndexOf(self2, el) {
          return self2.indexOf(el);
        },
        ArrayPrototypeJoin(self2, sep) {
          return self2.join(sep);
        },
        ArrayPrototypeMap(self2, fn) {
          return self2.map(fn);
        },
        ArrayPrototypePop(self2, el) {
          return self2.pop(el);
        },
        ArrayPrototypePush(self2, el) {
          return self2.push(el);
        },
        ArrayPrototypeSlice(self2, start, end) {
          return self2.slice(start, end);
        },
        Error,
        FunctionPrototypeCall(fn, thisArgs, ...args) {
          return fn.call(thisArgs, ...args);
        },
        FunctionPrototypeSymbolHasInstance(self2, instance) {
          return Function.prototype[Symbol.hasInstance].call(self2, instance);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties(self2, props) {
          return Object.defineProperties(self2, props);
        },
        ObjectDefineProperty(self2, name, prop) {
          return Object.defineProperty(self2, name, prop);
        },
        ObjectGetOwnPropertyDescriptor(self2, name) {
          return Object.getOwnPropertyDescriptor(self2, name);
        },
        ObjectKeys(obj) {
          return Object.keys(obj);
        },
        ObjectSetPrototypeOf(target, proto) {
          return Object.setPrototypeOf(target, proto);
        },
        Promise,
        PromisePrototypeCatch(self2, fn) {
          return self2.catch(fn);
        },
        PromisePrototypeThen(self2, thenFn, catchFn) {
          return self2.then(thenFn, catchFn);
        },
        PromiseReject(err) {
          return Promise.reject(err);
        },
        PromiseResolve(val2) {
          return Promise.resolve(val2);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest(self2, value) {
          return self2.test(value);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice(self2, start, end) {
          return self2.slice(start, end);
        },
        StringPrototypeToLowerCase(self2) {
          return self2.toLowerCase();
        },
        StringPrototypeToUpperCase(self2) {
          return self2.toUpperCase();
        },
        StringPrototypeTrim(self2) {
          return self2.trim();
        },
        Symbol,
        SymbolFor: Symbol.for,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
        SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
        TypedArrayPrototypeSet(self2, buf, len) {
          return self2.set(buf, len);
        },
        Boolean,
        Uint8Array
      };
    }
  });

  // node_modules/abort-controller/browser.js
  var require_browser3 = __commonJS({
    "node_modules/abort-controller/browser.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
        /* otherwise */
        void 0
      );
      module.exports = AbortController2;
      module.exports.AbortSignal = AbortSignal;
      module.exports.default = AbortController2;
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/util.js
  var require_util2 = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var bufferModule = require_buffer();
      var { kResistStopPropagation, SymbolDispose } = require_primordials();
      var AbortSignal = globalThis.AbortSignal || require_browser3().AbortSignal;
      var AbortController2 = globalThis.AbortController || require_browser3().AbortController;
      var AsyncFunction = Object.getPrototypeOf(async function() {
      }).constructor;
      var Blob2 = globalThis.Blob || bufferModule.Blob;
      var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
        return b instanceof Blob2;
      } : function isBlob2(b) {
        return false;
      };
      var validateAbortSignal = (signal, name) => {
        if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
          throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
        }
      };
      var validateFunction = (value, name) => {
        if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      };
      var AggregateError2 = class extends Error {
        constructor(errors) {
          if (!Array.isArray(errors)) {
            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
          }
          let message = "";
          for (let i = 0; i < errors.length; i++) {
            message += `    ${errors[i].stack}
`;
          }
          super(message);
          this.name = "AggregateError";
          this.errors = errors;
        }
      };
      module.exports = {
        AggregateError: AggregateError2,
        kEmptyObject: Object.freeze({}),
        once(callback) {
          let called = false;
          return function(...args) {
            if (called) {
              return;
            }
            called = true;
            callback.apply(this, args);
          };
        },
        createDeferredPromise: function() {
          let resolve2;
          let reject;
          const promise = new Promise((res, rej) => {
            resolve2 = res;
            reject = rej;
          });
          return {
            promise,
            resolve: resolve2,
            reject
          };
        },
        promisify(fn) {
          return new Promise((resolve2, reject) => {
            fn((err, ...args) => {
              if (err) {
                return reject(err);
              }
              return resolve2(...args);
            });
          });
        },
        debuglog() {
          return function() {
          };
        },
        format(format, ...args) {
          return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
            const replacement = args.shift();
            if (type === "f") {
              return replacement.toFixed(6);
            } else if (type === "j") {
              return JSON.stringify(replacement);
            } else if (type === "s" && typeof replacement === "object") {
              const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
              return `${ctor} {}`.trim();
            } else {
              return replacement.toString();
            }
          });
        },
        inspect(value) {
          switch (typeof value) {
            case "string":
              if (value.includes("'")) {
                if (!value.includes('"')) {
                  return `"${value}"`;
                } else if (!value.includes("`") && !value.includes("${")) {
                  return `\`${value}\``;
                }
              }
              return `'${value}'`;
            case "number":
              if (isNaN(value)) {
                return "NaN";
              } else if (Object.is(value, -0)) {
                return String(value);
              }
              return value;
            case "bigint":
              return `${String(value)}n`;
            case "boolean":
            case "undefined":
              return String(value);
            case "object":
              return "{}";
          }
        },
        types: {
          isAsyncFunction(fn) {
            return fn instanceof AsyncFunction;
          },
          isArrayBufferView(arr) {
            return ArrayBuffer.isView(arr);
          }
        },
        isBlob,
        deprecate(fn, message) {
          return fn;
        },
        addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
          if (signal === void 0) {
            throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
          }
          validateAbortSignal(signal, "signal");
          validateFunction(listener, "listener");
          let removeEventListener;
          if (signal.aborted) {
            queueMicrotask(() => listener());
          } else {
            signal.addEventListener("abort", listener, {
              __proto__: null,
              once: true,
              [kResistStopPropagation]: true
            });
            removeEventListener = () => {
              signal.removeEventListener("abort", listener);
            };
          }
          return {
            __proto__: null,
            [SymbolDispose]() {
              var _removeEventListener;
              (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
            }
          };
        },
        AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
          if (signals.length === 1) {
            return signals[0];
          }
          const ac = new AbortController2();
          const abort = () => ac.abort();
          signals.forEach((signal) => {
            validateAbortSignal(signal, "signals");
            signal.addEventListener("abort", abort, {
              once: true
            });
          });
          ac.signal.addEventListener(
            "abort",
            () => {
              signals.forEach((signal) => signal.removeEventListener("abort", abort));
            },
            {
              once: true
            }
          );
          return ac.signal;
        }
      };
      module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/errors.js
  var require_errors = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { format, inspect, AggregateError: CustomAggregateError } = require_util2();
      var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
      var kIsNodeError = Symbol("kIsNodeError");
      var kTypes = [
        "string",
        "function",
        "number",
        "object",
        // Accept 'Function' and 'Object' as alternative to the lower cased version.
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol"
      ];
      var classRegExp = /^([A-Z][a-z0-9]*)+$/;
      var nodeInternalPrefix = "__node_internal_";
      var codes = {};
      function assert(value, message) {
        if (!value) {
          throw new codes.ERR_INTERNAL_ASSERTION(message);
        }
      }
      function addNumericalSeparator(val2) {
        let res = "";
        let i = val2.length;
        const start = val2[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val2.slice(i - 3, i)}${res}`;
        }
        return `${val2.slice(0, i)}${res}`;
      }
      function getMessage(key, msg, args) {
        if (typeof msg === "function") {
          assert(
            msg.length <= args.length,
            // Default options do not count.
            `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
          );
          return msg(...args);
        }
        const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
        assert(
          expectedLength === args.length,
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
        );
        if (args.length === 0) {
          return msg;
        }
        return format(msg, ...args);
      }
      function E(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        class NodeError extends Base {
          constructor(...args) {
            super(getMessage(code, message, args));
          }
          toString() {
            return `${this.name} [${code}]: ${this.message}`;
          }
        }
        Object.defineProperties(NodeError.prototype, {
          name: {
            value: Base.name,
            writable: true,
            enumerable: false,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${code}]: ${this.message}`;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        NodeError.prototype.code = code;
        NodeError.prototype[kIsNodeError] = true;
        codes[code] = NodeError;
      }
      function hideStackFrames(fn) {
        const hidden = nodeInternalPrefix + fn.name;
        Object.defineProperty(fn, "name", {
          value: hidden
        });
        return fn;
      }
      function aggregateTwoErrors(innerError, outerError) {
        if (innerError && outerError && innerError !== outerError) {
          if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
          }
          const err = new AggregateError2([outerError, innerError], outerError.message);
          err.code = outerError.code;
          return err;
        }
        return innerError || outerError;
      }
      var AbortError = class extends Error {
        constructor(message = "The operation was aborted", options = void 0) {
          if (options !== void 0 && typeof options !== "object") {
            throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          super(message, options);
          this.code = "ABORT_ERR";
          this.name = "AbortError";
        }
      };
      E("ERR_ASSERTION", "%s", Error);
      E(
        "ERR_INVALID_ARG_TYPE",
        (name, expected, actual) => {
          assert(typeof name === "string", "'name' must be a string");
          if (!Array.isArray(expected)) {
            expected = [expected];
          }
          let msg = "The ";
          if (name.endsWith(" argument")) {
            msg += `${name} `;
          } else {
            msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
          }
          msg += "must be ";
          const types3 = [];
          const instances = [];
          const other = [];
          for (const value of expected) {
            assert(typeof value === "string", "All expected entries have to be of type string");
            if (kTypes.includes(value)) {
              types3.push(value.toLowerCase());
            } else if (classRegExp.test(value)) {
              instances.push(value);
            } else {
              assert(value !== "object", 'The value "object" should be written as "Object"');
              other.push(value);
            }
          }
          if (instances.length > 0) {
            const pos = types3.indexOf("object");
            if (pos !== -1) {
              types3.splice(types3, pos, 1);
              instances.push("Object");
            }
          }
          if (types3.length > 0) {
            switch (types3.length) {
              case 1:
                msg += `of type ${types3[0]}`;
                break;
              case 2:
                msg += `one of type ${types3[0]} or ${types3[1]}`;
                break;
              default: {
                const last = types3.pop();
                msg += `one of type ${types3.join(", ")}, or ${last}`;
              }
            }
            if (instances.length > 0 || other.length > 0) {
              msg += " or ";
            }
          }
          if (instances.length > 0) {
            switch (instances.length) {
              case 1:
                msg += `an instance of ${instances[0]}`;
                break;
              case 2:
                msg += `an instance of ${instances[0]} or ${instances[1]}`;
                break;
              default: {
                const last = instances.pop();
                msg += `an instance of ${instances.join(", ")}, or ${last}`;
              }
            }
            if (other.length > 0) {
              msg += " or ";
            }
          }
          switch (other.length) {
            case 0:
              break;
            case 1:
              if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
              }
              msg += `${other[0]}`;
              break;
            case 2:
              msg += `one of ${other[0]} or ${other[1]}`;
              break;
            default: {
              const last = other.pop();
              msg += `one of ${other.join(", ")}, or ${last}`;
            }
          }
          if (actual == null) {
            msg += `. Received ${actual}`;
          } else if (typeof actual === "function" && actual.name) {
            msg += `. Received function ${actual.name}`;
          } else if (typeof actual === "object") {
            var _actual$constructor;
            if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
              msg += `. Received an instance of ${actual.constructor.name}`;
            } else {
              const inspected = inspect(actual, {
                depth: -1
              });
              msg += `. Received ${inspected}`;
            }
          } else {
            let inspected = inspect(actual, {
              colors: false
            });
            if (inspected.length > 25) {
              inspected = `${inspected.slice(0, 25)}...`;
            }
            msg += `. Received type ${typeof actual} (${inspected})`;
          }
          return msg;
        },
        TypeError
      );
      E(
        "ERR_INVALID_ARG_VALUE",
        (name, value, reason = "is invalid") => {
          let inspected = inspect(value);
          if (inspected.length > 128) {
            inspected = inspected.slice(0, 128) + "...";
          }
          const type = name.includes(".") ? "property" : "argument";
          return `The ${type} '${name}' ${reason}. Received ${inspected}`;
        },
        TypeError
      );
      E(
        "ERR_INVALID_RETURN_VALUE",
        (input, name, value) => {
          var _value$constructor;
          const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
          return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
        },
        TypeError
      );
      E(
        "ERR_MISSING_ARGS",
        (...args) => {
          assert(args.length > 0, "At least one arg needs to be specified");
          let msg;
          const len = args.length;
          args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
          switch (len) {
            case 1:
              msg += `The ${args[0]} argument`;
              break;
            case 2:
              msg += `The ${args[0]} and ${args[1]} arguments`;
              break;
            default:
              {
                const last = args.pop();
                msg += `The ${args.join(", ")}, and ${last} arguments`;
              }
              break;
          }
          return `${msg} must be specified`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        (str, range, input) => {
          assert(range, 'Missing "range" argument');
          let received;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          } else {
            received = inspect(input);
          }
          return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
        },
        RangeError
      );
      E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
      E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
      E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
      E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
      E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
      E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
      E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
      E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
      E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
      E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
      module.exports = {
        AbortError,
        aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
        hideStackFrames,
        codes
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/validators.js
  var require_validators = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var {
        ArrayIsArray,
        ArrayPrototypeIncludes,
        ArrayPrototypeJoin,
        ArrayPrototypeMap,
        NumberIsInteger,
        NumberIsNaN,
        NumberMAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER,
        NumberParseInt,
        ObjectPrototypeHasOwnProperty,
        RegExpPrototypeExec,
        String: String2,
        StringPrototypeToUpperCase,
        StringPrototypeTrim
      } = require_primordials();
      var {
        hideStackFrames,
        codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
      } = require_errors();
      var { normalizeEncoding } = require_util2();
      var { isAsyncFunction, isArrayBufferView } = require_util2().types;
      var signals = {};
      function isInt32(value) {
        return value === (value | 0);
      }
      function isUint32(value) {
        return value === value >>> 0;
      }
      var octalReg = /^[0-7]+$/;
      var modeDesc = "must be a 32-bit unsigned integer or an octal string";
      function parseFileMode(value, name, def) {
        if (typeof value === "undefined") {
          value = def;
        }
        if (typeof value === "string") {
          if (RegExpPrototypeExec(octalReg, value) === null) {
            throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
          }
          value = NumberParseInt(value, 8);
        }
        validateUint32(value, name);
        return value;
      }
      var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
        if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
        if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
        if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      });
      var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
        if (typeof value !== "number") {
          throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
        }
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        if (value < min || value > max) {
          throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }
      });
      var validateUint32 = hideStackFrames((value, name, positive = false) => {
        if (typeof value !== "number") {
          throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
        }
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        const max = 4294967295;
        if (value < min || value > max) {
          throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }
      });
      function validateString(value, name) {
        if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
      }
      function validateNumber(value, name, min = void 0, max) {
        if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
        if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
          throw new ERR_OUT_OF_RANGE(
            name,
            `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
            value
          );
        }
      }
      var validateOneOf = hideStackFrames((value, name, oneOf) => {
        if (!ArrayPrototypeIncludes(oneOf, value)) {
          const allowed = ArrayPrototypeJoin(
            ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
            ", "
          );
          const reason = "must be one of: " + allowed;
          throw new ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      });
      function validateBoolean(value, name) {
        if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
      }
      function getOwnPropertyValueOrDefault(options, key, defaultValue) {
        return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
      }
      var validateObject = hideStackFrames((value, name, options = null) => {
        const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
        const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
        const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
        if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
          throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
        }
      });
      var validateDictionary = hideStackFrames((value, name) => {
        if (value != null && typeof value !== "object" && typeof value !== "function") {
          throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
        }
      });
      var validateArray = hideStackFrames((value, name, minLength = 0) => {
        if (!ArrayIsArray(value)) {
          throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
        }
        if (value.length < minLength) {
          const reason = `must be longer than ${minLength}`;
          throw new ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      });
      function validateStringArray(value, name) {
        validateArray(value, name);
        for (let i = 0; i < value.length; i++) {
          validateString(value[i], `${name}[${i}]`);
        }
      }
      function validateBooleanArray(value, name) {
        validateArray(value, name);
        for (let i = 0; i < value.length; i++) {
          validateBoolean(value[i], `${name}[${i}]`);
        }
      }
      function validateAbortSignalArray(value, name) {
        validateArray(value, name);
        for (let i = 0; i < value.length; i++) {
          const signal = value[i];
          const indexedName = `${name}[${i}]`;
          if (signal == null) {
            throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
          }
          validateAbortSignal(signal, indexedName);
        }
      }
      function validateSignalName(signal, name = "signal") {
        validateString(signal, name);
        if (signals[signal] === void 0) {
          if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
            throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
          }
          throw new ERR_UNKNOWN_SIGNAL(signal);
        }
      }
      var validateBuffer = hideStackFrames((buffer2, name = "buffer") => {
        if (!isArrayBufferView(buffer2)) {
          throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer2);
        }
      });
      function validateEncoding(data, encoding) {
        const normalizedEncoding = normalizeEncoding(encoding);
        const length = data.length;
        if (normalizedEncoding === "hex" && length % 2 !== 0) {
          throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
        }
      }
      function validatePort(port, name = "Port", allowZero = true) {
        if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
          throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
        }
        return port | 0;
      }
      var validateAbortSignal = hideStackFrames((signal, name) => {
        if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
          throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
        }
      });
      var validateFunction = hideStackFrames((value, name) => {
        if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
      });
      var validatePlainFunction = hideStackFrames((value, name) => {
        if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
      });
      var validateUndefined = hideStackFrames((value, name) => {
        if (value !== void 0) throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
      });
      function validateUnion(value, name, union) {
        if (!ArrayPrototypeIncludes(union, value)) {
          throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
        }
      }
      var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
      function validateLinkHeaderFormat(value, name) {
        if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
          throw new ERR_INVALID_ARG_VALUE(
            name,
            value,
            'must be an array or string of format "</styles.css>; rel=preload; as=style"'
          );
        }
      }
      function validateLinkHeaderValue(hints) {
        if (typeof hints === "string") {
          validateLinkHeaderFormat(hints, "hints");
          return hints;
        } else if (ArrayIsArray(hints)) {
          const hintsLength = hints.length;
          let result = "";
          if (hintsLength === 0) {
            return result;
          }
          for (let i = 0; i < hintsLength; i++) {
            const link3 = hints[i];
            validateLinkHeaderFormat(link3, "hints");
            result += link3;
            if (i !== hintsLength - 1) {
              result += ", ";
            }
          }
          return result;
        }
        throw new ERR_INVALID_ARG_VALUE(
          "hints",
          hints,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
      module.exports = {
        isInt32,
        isUint32,
        parseFileMode,
        validateArray,
        validateStringArray,
        validateBooleanArray,
        validateAbortSignalArray,
        validateBoolean,
        validateBuffer,
        validateDictionary,
        validateEncoding,
        validateFunction,
        validateInt32,
        validateInteger,
        validateNumber,
        validateObject,
        validateOneOf,
        validatePlainFunction,
        validatePort,
        validateSignalName,
        validateString,
        validateUint32,
        validateUndefined,
        validateUnion,
        validateAbortSignal,
        validateLinkHeaderValue
      };
    }
  });

  // node_modules/process/browser.js
  var require_browser4 = __commonJS({
    "node_modules/process/browser.js"(exports, module) {
      init_esbuild_shims();
      var process2 = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e2) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e2) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e2) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e3) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e2) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e3) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop() {
      }
      process2.on = noop;
      process2.addListener = noop;
      process2.once = noop;
      process2.off = noop;
      process2.removeListener = noop;
      process2.removeAllListeners = noop;
      process2.emit = noop;
      process2.prependListener = noop;
      process2.prependOnceListener = noop;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/utils.js
  var require_utils = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
      var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
      var kIsErrored = SymbolFor("nodejs.stream.errored");
      var kIsReadable = SymbolFor("nodejs.stream.readable");
      var kIsWritable = SymbolFor("nodejs.stream.writable");
      var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
      var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
      var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
      function isReadableNodeStream(obj, strict = false) {
        var _obj$_readableState;
        return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
        (!obj._writableState || obj._readableState));
      }
      function isWritableNodeStream(obj) {
        var _obj$_writableState;
        return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
      }
      function isDuplexNodeStream(obj) {
        return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
      }
      function isNodeStream(obj) {
        return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
      }
      function isReadableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
      }
      function isWritableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
      }
      function isTransformStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
      }
      function isWebStream(obj) {
        return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
      }
      function isIterable(obj, isAsync) {
        if (obj == null) return false;
        if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
        if (isAsync === false) return typeof obj[SymbolIterator] === "function";
        return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
      }
      function isDestroyed(stream2) {
        if (!isNodeStream(stream2)) return null;
        const wState = stream2._writableState;
        const rState = stream2._readableState;
        const state = wState || rState;
        return !!(stream2.destroyed || stream2[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
      }
      function isWritableEnded(stream2) {
        if (!isWritableNodeStream(stream2)) return null;
        if (stream2.writableEnded === true) return true;
        const wState = stream2._writableState;
        if (wState !== null && wState !== void 0 && wState.errored) return false;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
        return wState.ended;
      }
      function isWritableFinished(stream2, strict) {
        if (!isWritableNodeStream(stream2)) return null;
        if (stream2.writableFinished === true) return true;
        const wState = stream2._writableState;
        if (wState !== null && wState !== void 0 && wState.errored) return false;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
        return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
      }
      function isReadableEnded(stream2) {
        if (!isReadableNodeStream(stream2)) return null;
        if (stream2.readableEnded === true) return true;
        const rState = stream2._readableState;
        if (!rState || rState.errored) return false;
        if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
        return rState.ended;
      }
      function isReadableFinished(stream2, strict) {
        if (!isReadableNodeStream(stream2)) return null;
        const rState = stream2._readableState;
        if (rState !== null && rState !== void 0 && rState.errored) return false;
        if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
        return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
      }
      function isReadable2(stream2) {
        if (stream2 && stream2[kIsReadable] != null) return stream2[kIsReadable];
        if (typeof (stream2 === null || stream2 === void 0 ? void 0 : stream2.readable) !== "boolean") return null;
        if (isDestroyed(stream2)) return false;
        return isReadableNodeStream(stream2) && stream2.readable && !isReadableFinished(stream2);
      }
      function isWritable(stream2) {
        if (stream2 && stream2[kIsWritable] != null) return stream2[kIsWritable];
        if (typeof (stream2 === null || stream2 === void 0 ? void 0 : stream2.writable) !== "boolean") return null;
        if (isDestroyed(stream2)) return false;
        return isWritableNodeStream(stream2) && stream2.writable && !isWritableEnded(stream2);
      }
      function isFinished(stream2, opts) {
        if (!isNodeStream(stream2)) {
          return null;
        }
        if (isDestroyed(stream2)) {
          return true;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable2(stream2)) {
          return false;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream2)) {
          return false;
        }
        return true;
      }
      function isWritableErrored(stream2) {
        var _stream$_writableStat, _stream$_writableStat2;
        if (!isNodeStream(stream2)) {
          return null;
        }
        if (stream2.writableErrored) {
          return stream2.writableErrored;
        }
        return (_stream$_writableStat = (_stream$_writableStat2 = stream2._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
      }
      function isReadableErrored(stream2) {
        var _stream$_readableStat, _stream$_readableStat2;
        if (!isNodeStream(stream2)) {
          return null;
        }
        if (stream2.readableErrored) {
          return stream2.readableErrored;
        }
        return (_stream$_readableStat = (_stream$_readableStat2 = stream2._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
      }
      function isClosed(stream2) {
        if (!isNodeStream(stream2)) {
          return null;
        }
        if (typeof stream2.closed === "boolean") {
          return stream2.closed;
        }
        const wState = stream2._writableState;
        const rState = stream2._readableState;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
          return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
        }
        if (typeof stream2._closed === "boolean" && isOutgoingMessage(stream2)) {
          return stream2._closed;
        }
        return null;
      }
      function isOutgoingMessage(stream2) {
        return typeof stream2._closed === "boolean" && typeof stream2._defaultKeepAlive === "boolean" && typeof stream2._removedConnection === "boolean" && typeof stream2._removedContLen === "boolean";
      }
      function isServerResponse(stream2) {
        return typeof stream2._sent100 === "boolean" && isOutgoingMessage(stream2);
      }
      function isServerRequest(stream2) {
        var _stream$req;
        return typeof stream2._consuming === "boolean" && typeof stream2._dumped === "boolean" && ((_stream$req = stream2.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
      }
      function willEmitClose(stream2) {
        if (!isNodeStream(stream2)) return null;
        const wState = stream2._writableState;
        const rState = stream2._readableState;
        const state = wState || rState;
        return !state && isServerResponse(stream2) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
      }
      function isDisturbed(stream2) {
        var _stream$kIsDisturbed;
        return !!(stream2 && ((_stream$kIsDisturbed = stream2[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream2.readableDidRead || stream2.readableAborted));
      }
      function isErrored(stream2) {
        var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
        return !!(stream2 && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream2[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream2.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream2.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream2._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream2._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream2._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream2._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
      }
      module.exports = {
        isDestroyed,
        kIsDestroyed,
        isDisturbed,
        kIsDisturbed,
        isErrored,
        kIsErrored,
        isReadable: isReadable2,
        kIsReadable,
        kIsClosedPromise,
        kControllerErrorFunction,
        kIsWritable,
        isClosed,
        isDuplexNodeStream,
        isFinished,
        isIterable,
        isReadableNodeStream,
        isReadableStream,
        isReadableEnded,
        isReadableFinished,
        isReadableErrored,
        isNodeStream,
        isWebStream,
        isWritable,
        isWritableNodeStream,
        isWritableStream,
        isWritableEnded,
        isWritableFinished,
        isWritableErrored,
        isServerRequest,
        isServerResponse,
        willEmitClose,
        isTransformStream
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      init_esbuild_shims();
      var process2 = require_browser4();
      var { AbortError, codes } = require_errors();
      var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
      var { kEmptyObject, once } = require_util2();
      var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
      var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
      var {
        isClosed,
        isReadable: isReadable2,
        isReadableNodeStream,
        isReadableStream,
        isReadableFinished,
        isReadableErrored,
        isWritable,
        isWritableNodeStream,
        isWritableStream,
        isWritableFinished,
        isWritableErrored,
        isNodeStream,
        willEmitClose: _willEmitClose,
        kIsClosedPromise
      } = require_utils();
      var addAbortListener;
      function isRequest(stream2) {
        return stream2.setHeader && typeof stream2.abort === "function";
      }
      var nop2 = () => {
      };
      function eos(stream2, options, callback) {
        var _options$readable, _options$writable;
        if (arguments.length === 2) {
          callback = options;
          options = kEmptyObject;
        } else if (options == null) {
          options = kEmptyObject;
        } else {
          validateObject(options, "options");
        }
        validateFunction(callback, "callback");
        validateAbortSignal(options.signal, "options.signal");
        callback = once(callback);
        if (isReadableStream(stream2) || isWritableStream(stream2)) {
          return eosWeb(stream2, options, callback);
        }
        if (!isNodeStream(stream2)) {
          throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream2);
        }
        const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream2);
        const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream2);
        const wState = stream2._writableState;
        const rState = stream2._readableState;
        const onlegacyfinish = () => {
          if (!stream2.writable) {
            onfinish();
          }
        };
        let willEmitClose = _willEmitClose(stream2) && isReadableNodeStream(stream2) === readable && isWritableNodeStream(stream2) === writable;
        let writableFinished = isWritableFinished(stream2, false);
        const onfinish = () => {
          writableFinished = true;
          if (stream2.destroyed) {
            willEmitClose = false;
          }
          if (willEmitClose && (!stream2.readable || readable)) {
            return;
          }
          if (!readable || readableFinished) {
            callback.call(stream2);
          }
        };
        let readableFinished = isReadableFinished(stream2, false);
        const onend = () => {
          readableFinished = true;
          if (stream2.destroyed) {
            willEmitClose = false;
          }
          if (willEmitClose && (!stream2.writable || writable)) {
            return;
          }
          if (!writable || writableFinished) {
            callback.call(stream2);
          }
        };
        const onerror = (err) => {
          callback.call(stream2, err);
        };
        let closed = isClosed(stream2);
        const onclose = () => {
          closed = true;
          const errored = isWritableErrored(stream2) || isReadableErrored(stream2);
          if (errored && typeof errored !== "boolean") {
            return callback.call(stream2, errored);
          }
          if (readable && !readableFinished && isReadableNodeStream(stream2, true)) {
            if (!isReadableFinished(stream2, false)) return callback.call(stream2, new ERR_STREAM_PREMATURE_CLOSE());
          }
          if (writable && !writableFinished) {
            if (!isWritableFinished(stream2, false)) return callback.call(stream2, new ERR_STREAM_PREMATURE_CLOSE());
          }
          callback.call(stream2);
        };
        const onclosed = () => {
          closed = true;
          const errored = isWritableErrored(stream2) || isReadableErrored(stream2);
          if (errored && typeof errored !== "boolean") {
            return callback.call(stream2, errored);
          }
          callback.call(stream2);
        };
        const onrequest = () => {
          stream2.req.on("finish", onfinish);
        };
        if (isRequest(stream2)) {
          stream2.on("complete", onfinish);
          if (!willEmitClose) {
            stream2.on("abort", onclose);
          }
          if (stream2.req) {
            onrequest();
          } else {
            stream2.on("request", onrequest);
          }
        } else if (writable && !wState) {
          stream2.on("end", onlegacyfinish);
          stream2.on("close", onlegacyfinish);
        }
        if (!willEmitClose && typeof stream2.aborted === "boolean") {
          stream2.on("aborted", onclose);
        }
        stream2.on("end", onend);
        stream2.on("finish", onfinish);
        if (options.error !== false) {
          stream2.on("error", onerror);
        }
        stream2.on("close", onclose);
        if (closed) {
          process2.nextTick(onclose);
        } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
          if (!willEmitClose) {
            process2.nextTick(onclosed);
          }
        } else if (!readable && (!willEmitClose || isReadable2(stream2)) && (writableFinished || isWritable(stream2) === false)) {
          process2.nextTick(onclosed);
        } else if (!writable && (!willEmitClose || isWritable(stream2)) && (readableFinished || isReadable2(stream2) === false)) {
          process2.nextTick(onclosed);
        } else if (rState && stream2.req && stream2.aborted) {
          process2.nextTick(onclosed);
        }
        const cleanup = () => {
          callback = nop2;
          stream2.removeListener("aborted", onclose);
          stream2.removeListener("complete", onfinish);
          stream2.removeListener("abort", onclose);
          stream2.removeListener("request", onrequest);
          if (stream2.req) stream2.req.removeListener("finish", onfinish);
          stream2.removeListener("end", onlegacyfinish);
          stream2.removeListener("close", onlegacyfinish);
          stream2.removeListener("finish", onfinish);
          stream2.removeListener("end", onend);
          stream2.removeListener("error", onerror);
          stream2.removeListener("close", onclose);
        };
        if (options.signal && !closed) {
          const abort = () => {
            const endCallback = callback;
            cleanup();
            endCallback.call(
              stream2,
              new AbortError(void 0, {
                cause: options.signal.reason
              })
            );
          };
          if (options.signal.aborted) {
            process2.nextTick(abort);
          } else {
            addAbortListener = addAbortListener || require_util2().addAbortListener;
            const disposable = addAbortListener(options.signal, abort);
            const originalCallback = callback;
            callback = once((...args) => {
              disposable[SymbolDispose]();
              originalCallback.apply(stream2, args);
            });
          }
        }
        return cleanup;
      }
      function eosWeb(stream2, options, callback) {
        let isAborted = false;
        let abort = nop2;
        if (options.signal) {
          abort = () => {
            isAborted = true;
            callback.call(
              stream2,
              new AbortError(void 0, {
                cause: options.signal.reason
              })
            );
          };
          if (options.signal.aborted) {
            process2.nextTick(abort);
          } else {
            addAbortListener = addAbortListener || require_util2().addAbortListener;
            const disposable = addAbortListener(options.signal, abort);
            const originalCallback = callback;
            callback = once((...args) => {
              disposable[SymbolDispose]();
              originalCallback.apply(stream2, args);
            });
          }
        }
        const resolverFn = (...args) => {
          if (!isAborted) {
            process2.nextTick(() => callback.apply(stream2, args));
          }
        };
        PromisePrototypeThen(stream2[kIsClosedPromise].promise, resolverFn, resolverFn);
        return nop2;
      }
      function finished(stream2, opts) {
        var _opts;
        let autoCleanup = false;
        if (opts === null) {
          opts = kEmptyObject;
        }
        if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
          validateBoolean(opts.cleanup, "cleanup");
          autoCleanup = opts.cleanup;
        }
        return new Promise2((resolve2, reject) => {
          const cleanup = eos(stream2, opts, (err) => {
            if (autoCleanup) {
              cleanup();
            }
            if (err) {
              reject(err);
            } else {
              resolve2();
            }
          });
        });
      }
      module.exports = eos;
      module.exports.finished = finished;
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var process2 = require_browser4();
      var {
        aggregateTwoErrors,
        codes: { ERR_MULTIPLE_CALLBACK },
        AbortError
      } = require_errors();
      var { Symbol: Symbol2 } = require_primordials();
      var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
      var kDestroy = Symbol2("kDestroy");
      var kConstruct = Symbol2("kConstruct");
      function checkError(err, w, r) {
        if (err) {
          err.stack;
          if (w && !w.errored) {
            w.errored = err;
          }
          if (r && !r.errored) {
            r.errored = err;
          }
        }
      }
      function destroy(err, cb) {
        const r = this._readableState;
        const w = this._writableState;
        const s = w || r;
        if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
          if (typeof cb === "function") {
            cb();
          }
          return this;
        }
        checkError(err, w, r);
        if (w) {
          w.destroyed = true;
        }
        if (r) {
          r.destroyed = true;
        }
        if (!s.constructed) {
          this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
          });
        } else {
          _destroy(this, err, cb);
        }
        return this;
      }
      function _destroy(self2, err, cb) {
        let called = false;
        function onDestroy(err2) {
          if (called) {
            return;
          }
          called = true;
          const r = self2._readableState;
          const w = self2._writableState;
          checkError(err2, w, r);
          if (w) {
            w.closed = true;
          }
          if (r) {
            r.closed = true;
          }
          if (typeof cb === "function") {
            cb(err2);
          }
          if (err2) {
            process2.nextTick(emitErrorCloseNT, self2, err2);
          } else {
            process2.nextTick(emitCloseNT, self2);
          }
        }
        try {
          self2._destroy(err || null, onDestroy);
        } catch (err2) {
          onDestroy(err2);
        }
      }
      function emitErrorCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        const r = self2._readableState;
        const w = self2._writableState;
        if (w) {
          w.closeEmitted = true;
        }
        if (r) {
          r.closeEmitted = true;
        }
        if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
          self2.emit("close");
        }
      }
      function emitErrorNT(self2, err) {
        const r = self2._readableState;
        const w = self2._writableState;
        if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
          return;
        }
        if (w) {
          w.errorEmitted = true;
        }
        if (r) {
          r.errorEmitted = true;
        }
        self2.emit("error", err);
      }
      function undestroy() {
        const r = this._readableState;
        const w = this._writableState;
        if (r) {
          r.constructed = true;
          r.closed = false;
          r.closeEmitted = false;
          r.destroyed = false;
          r.errored = null;
          r.errorEmitted = false;
          r.reading = false;
          r.ended = r.readable === false;
          r.endEmitted = r.readable === false;
        }
        if (w) {
          w.constructed = true;
          w.destroyed = false;
          w.closed = false;
          w.closeEmitted = false;
          w.errored = null;
          w.errorEmitted = false;
          w.finalCalled = false;
          w.prefinished = false;
          w.ended = w.writable === false;
          w.ending = w.writable === false;
          w.finished = w.writable === false;
        }
      }
      function errorOrDestroy(stream2, err, sync) {
        const r = stream2._readableState;
        const w = stream2._writableState;
        if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
          return this;
        }
        if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
          stream2.destroy(err);
        else if (err) {
          err.stack;
          if (w && !w.errored) {
            w.errored = err;
          }
          if (r && !r.errored) {
            r.errored = err;
          }
          if (sync) {
            process2.nextTick(emitErrorNT, stream2, err);
          } else {
            emitErrorNT(stream2, err);
          }
        }
      }
      function construct(stream2, cb) {
        if (typeof stream2._construct !== "function") {
          return;
        }
        const r = stream2._readableState;
        const w = stream2._writableState;
        if (r) {
          r.constructed = false;
        }
        if (w) {
          w.constructed = false;
        }
        stream2.once(kConstruct, cb);
        if (stream2.listenerCount(kConstruct) > 1) {
          return;
        }
        process2.nextTick(constructNT, stream2);
      }
      function constructNT(stream2) {
        let called = false;
        function onConstruct(err) {
          if (called) {
            errorOrDestroy(stream2, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
            return;
          }
          called = true;
          const r = stream2._readableState;
          const w = stream2._writableState;
          const s = w || r;
          if (r) {
            r.constructed = true;
          }
          if (w) {
            w.constructed = true;
          }
          if (s.destroyed) {
            stream2.emit(kDestroy, err);
          } else if (err) {
            errorOrDestroy(stream2, err, true);
          } else {
            process2.nextTick(emitConstructNT, stream2);
          }
        }
        try {
          stream2._construct((err) => {
            process2.nextTick(onConstruct, err);
          });
        } catch (err) {
          process2.nextTick(onConstruct, err);
        }
      }
      function emitConstructNT(stream2) {
        stream2.emit(kConstruct);
      }
      function isRequest(stream2) {
        return (stream2 === null || stream2 === void 0 ? void 0 : stream2.setHeader) && typeof stream2.abort === "function";
      }
      function emitCloseLegacy(stream2) {
        stream2.emit("close");
      }
      function emitErrorCloseLegacy(stream2, err) {
        stream2.emit("error", err);
        process2.nextTick(emitCloseLegacy, stream2);
      }
      function destroyer(stream2, err) {
        if (!stream2 || isDestroyed(stream2)) {
          return;
        }
        if (!err && !isFinished(stream2)) {
          err = new AbortError();
        }
        if (isServerRequest(stream2)) {
          stream2.socket = null;
          stream2.destroy(err);
        } else if (isRequest(stream2)) {
          stream2.abort();
        } else if (isRequest(stream2.req)) {
          stream2.req.abort();
        } else if (typeof stream2.destroy === "function") {
          stream2.destroy(err);
        } else if (typeof stream2.close === "function") {
          stream2.close();
        } else if (err) {
          process2.nextTick(emitErrorCloseLegacy, stream2, err);
        } else {
          process2.nextTick(emitCloseLegacy, stream2);
        }
        if (!stream2.destroyed) {
          stream2[kIsDestroyed] = true;
        }
      }
      module.exports = {
        construct,
        destroyer,
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/legacy.js
  var require_legacy = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
      var { EventEmitter: EE } = require_events();
      function Stream(opts) {
        EE.call(this, opts);
      }
      ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
      ObjectSetPrototypeOf(Stream, EE);
      Stream.prototype.pipe = function(dest, options) {
        const source = this;
        function ondata(chunk) {
          if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        let didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            this.emit("error", er);
          }
        }
        prependListener(source, "error", onerror);
        prependListener(dest, "error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      module.exports = {
        Stream,
        prependListener
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
  var require_add_abort_signal = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { SymbolDispose } = require_primordials();
      var { AbortError, codes } = require_errors();
      var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
      var eos = require_end_of_stream();
      var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
      var addAbortListener;
      var validateAbortSignal = (signal, name) => {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
        }
      };
      module.exports.addAbortSignal = function addAbortSignal(signal, stream2) {
        validateAbortSignal(signal, "signal");
        if (!isNodeStream(stream2) && !isWebStream(stream2)) {
          throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream2);
        }
        return module.exports.addAbortSignalNoValidate(signal, stream2);
      };
      module.exports.addAbortSignalNoValidate = function(signal, stream2) {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          return stream2;
        }
        const onAbort = isNodeStream(stream2) ? () => {
          stream2.destroy(
            new AbortError(void 0, {
              cause: signal.reason
            })
          );
        } : () => {
          stream2[kControllerErrorFunction](
            new AbortError(void 0, {
              cause: signal.reason
            })
          );
        };
        if (signal.aborted) {
          onAbort();
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(signal, onAbort);
          eos(stream2, disposable[SymbolDispose]);
        }
        return stream2;
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
      var { Buffer: Buffer6 } = require_buffer();
      var { inspect } = require_util2();
      module.exports = class BufferList {
        constructor() {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        push(v) {
          const entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
        unshift(v) {
          const entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
        shift() {
          if (this.length === 0) return;
          const ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
        clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
        join(s) {
          if (this.length === 0) return "";
          let p = this.head;
          let ret = "" + p.data;
          while ((p = p.next) !== null) ret += s + p.data;
          return ret;
        }
        concat(n) {
          if (this.length === 0) return Buffer6.alloc(0);
          const ret = Buffer6.allocUnsafe(n >>> 0);
          let p = this.head;
          let i = 0;
          while (p) {
            TypedArrayPrototypeSet(ret, p.data, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
        consume(n, hasStrings) {
          const data = this.head.data;
          if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
          }
          if (n === data.length) {
            return this.shift();
          }
          return hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        first() {
          return this.head.data;
        }
        *[SymbolIterator]() {
          for (let p = this.head; p; p = p.next) {
            yield p.data;
          }
        }
        // Consumes a specified amount of characters from the buffered data.
        _getString(n) {
          let ret = "";
          let p = this.head;
          let c = 0;
          do {
            const str = p.data;
            if (n > str.length) {
              ret += str;
              n -= str.length;
            } else {
              if (n === str.length) {
                ret += str;
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                ret += StringPrototypeSlice(str, 0, n);
                this.head = p;
                p.data = StringPrototypeSlice(str, n);
              }
              break;
            }
            ++c;
          } while ((p = p.next) !== null);
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
        _getBuffer(n) {
          const ret = Buffer6.allocUnsafe(n);
          const retLen = n;
          let p = this.head;
          let c = 0;
          do {
            const buf = p.data;
            if (n > buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              n -= buf.length;
            } else {
              if (n === buf.length) {
                TypedArrayPrototypeSet(ret, buf, retLen - n);
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
                this.head = p;
                p.data = buf.slice(n);
              }
              break;
            }
            ++c;
          } while ((p = p.next) !== null);
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
        [Symbol.for("nodejs.util.inspect.custom")](_, options) {
          return inspect(this, {
            ...options,
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          });
        }
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { MathFloor, NumberIsInteger } = require_primordials();
      var { validateInteger } = require_validators();
      var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
      var defaultHighWaterMarkBytes = 16 * 1024;
      var defaultHighWaterMarkObjectMode = 16;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getDefaultHighWaterMark(objectMode) {
        return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
      }
      function setDefaultHighWaterMark(objectMode, value) {
        validateInteger(value, "value", 0);
        if (objectMode) {
          defaultHighWaterMarkObjectMode = value;
        } else {
          defaultHighWaterMarkBytes = value;
        }
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!NumberIsInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
          }
          return MathFloor(hwm);
        }
        return getDefaultHighWaterMark(state.objectMode);
      }
      module.exports = {
        getHighWaterMark,
        getDefaultHighWaterMark,
        setDefaultHighWaterMark
      };
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      init_esbuild_shims();
      var buffer2 = require_buffer();
      var Buffer6 = buffer2.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer6.from && Buffer6.alloc && Buffer6.allocUnsafe && Buffer6.allocUnsafeSlow) {
        module.exports = buffer2;
      } else {
        copyProps(buffer2, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer6(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer6.prototype);
      copyProps(Buffer6, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer6(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer6(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer6(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    }
  });

  // node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var Buffer6 = require_safe_buffer().Buffer;
      var isEncoding = Buffer6.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried) return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer6.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer6.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0) return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127) return 0;
        else if (byte >> 5 === 6) return 2;
        else if (byte >> 4 === 14) return 3;
        else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;
            else self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/from.js
  var require_from = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var process2 = require_browser4();
      var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
      var { Buffer: Buffer6 } = require_buffer();
      var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;
      function from(Readable2, iterable, opts) {
        let iterator;
        if (typeof iterable === "string" || iterable instanceof Buffer6) {
          return new Readable2({
            objectMode: true,
            ...opts,
            read() {
              this.push(iterable);
              this.push(null);
            }
          });
        }
        let isAsync;
        if (iterable && iterable[SymbolAsyncIterator]) {
          isAsync = true;
          iterator = iterable[SymbolAsyncIterator]();
        } else if (iterable && iterable[SymbolIterator]) {
          isAsync = false;
          iterator = iterable[SymbolIterator]();
        } else {
          throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
        }
        const readable = new Readable2({
          objectMode: true,
          highWaterMark: 1,
          // TODO(ronag): What options should be allowed?
          ...opts
        });
        let reading = false;
        readable._read = function() {
          if (!reading) {
            reading = true;
            next();
          }
        };
        readable._destroy = function(error, cb) {
          PromisePrototypeThen(
            close2(error),
            () => process2.nextTick(cb, error),
            // nextTick is here in case cb throws
            (e2) => process2.nextTick(cb, e2 || error)
          );
        };
        async function close2(error) {
          const hadError = error !== void 0 && error !== null;
          const hasThrow = typeof iterator.throw === "function";
          if (hadError && hasThrow) {
            const { value, done } = await iterator.throw(error);
            await value;
            if (done) {
              return;
            }
          }
          if (typeof iterator.return === "function") {
            const { value } = await iterator.return();
            await value;
          }
        }
        async function next() {
          for (; ; ) {
            try {
              const { value, done } = isAsync ? await iterator.next() : iterator.next();
              if (done) {
                readable.push(null);
              } else {
                const res = value && typeof value.then === "function" ? await value : value;
                if (res === null) {
                  reading = false;
                  throw new ERR_STREAM_NULL_VALUES();
                } else if (readable.push(res)) {
                  continue;
                } else {
                  reading = false;
                }
              }
            } catch (err) {
              readable.destroy(err);
            }
            break;
          }
        }
        return readable;
      }
      module.exports = from;
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/readable.js
  var require_readable = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
      init_esbuild_shims();
      var process2 = require_browser4();
      var {
        ArrayPrototypeIndexOf,
        NumberIsInteger,
        NumberIsNaN,
        NumberParseInt,
        ObjectDefineProperties,
        ObjectKeys,
        ObjectSetPrototypeOf,
        Promise: Promise2,
        SafeSet,
        SymbolAsyncDispose,
        SymbolAsyncIterator,
        Symbol: Symbol2
      } = require_primordials();
      module.exports = Readable2;
      Readable2.ReadableState = ReadableState;
      var { EventEmitter: EE } = require_events();
      var { Stream, prependListener } = require_legacy();
      var { Buffer: Buffer6 } = require_buffer();
      var { addAbortSignal } = require_add_abort_signal();
      var eos = require_end_of_stream();
      var debug = require_util2().debuglog("stream", (fn) => {
        debug = fn;
      });
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy();
      var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
      var {
        aggregateTwoErrors,
        codes: {
          ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
          ERR_METHOD_NOT_IMPLEMENTED,
          ERR_OUT_OF_RANGE,
          ERR_STREAM_PUSH_AFTER_EOF,
          ERR_STREAM_UNSHIFT_AFTER_END_EVENT
        },
        AbortError
      } = require_errors();
      var { validateObject } = require_validators();
      var kPaused = Symbol2("kPaused");
      var { StringDecoder } = require_string_decoder();
      var from = require_from();
      ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Readable2, Stream);
      var nop2 = () => {
      };
      var { errorOrDestroy } = destroyImpl;
      var kObjectMode = 1 << 0;
      var kEnded = 1 << 1;
      var kEndEmitted = 1 << 2;
      var kReading = 1 << 3;
      var kConstructed = 1 << 4;
      var kSync = 1 << 5;
      var kNeedReadable = 1 << 6;
      var kEmittedReadable = 1 << 7;
      var kReadableListening = 1 << 8;
      var kResumeScheduled = 1 << 9;
      var kErrorEmitted = 1 << 10;
      var kEmitClose = 1 << 11;
      var kAutoDestroy = 1 << 12;
      var kDestroyed = 1 << 13;
      var kClosed = 1 << 14;
      var kCloseEmitted = 1 << 15;
      var kMultiAwaitDrain = 1 << 16;
      var kReadingMore = 1 << 17;
      var kDataEmitted = 1 << 18;
      function makeBitMapDescriptor(bit) {
        return {
          enumerable: false,
          get() {
            return (this.state & bit) !== 0;
          },
          set(value) {
            if (value) this.state |= bit;
            else this.state &= ~bit;
          }
        };
      }
      ObjectDefineProperties(ReadableState.prototype, {
        objectMode: makeBitMapDescriptor(kObjectMode),
        ended: makeBitMapDescriptor(kEnded),
        endEmitted: makeBitMapDescriptor(kEndEmitted),
        reading: makeBitMapDescriptor(kReading),
        // Stream is still being constructed and cannot be
        // destroyed until construction finished or failed.
        // Async construction is opt in, therefore we start as
        // constructed.
        constructed: makeBitMapDescriptor(kConstructed),
        // A flag to be able to tell if the event 'readable'/'data' is emitted
        // immediately, or on a later tick.  We set this to true at first, because
        // any actions that shouldn't happen until "later" should generally also
        // not happen before the first read call.
        sync: makeBitMapDescriptor(kSync),
        // Whenever we return null, then we set a flag to say
        // that we're awaiting a 'readable' event emission.
        needReadable: makeBitMapDescriptor(kNeedReadable),
        emittedReadable: makeBitMapDescriptor(kEmittedReadable),
        readableListening: makeBitMapDescriptor(kReadableListening),
        resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
        // True if the error was already emitted and should not be thrown again.
        errorEmitted: makeBitMapDescriptor(kErrorEmitted),
        emitClose: makeBitMapDescriptor(kEmitClose),
        autoDestroy: makeBitMapDescriptor(kAutoDestroy),
        // Has it been destroyed.
        destroyed: makeBitMapDescriptor(kDestroyed),
        // Indicates whether the stream has finished destroying.
        closed: makeBitMapDescriptor(kClosed),
        // True if close has been emitted or would have been emitted
        // depending on emitClose.
        closeEmitted: makeBitMapDescriptor(kCloseEmitted),
        multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
        // If true, a maybeReadMore has been scheduled.
        readingMore: makeBitMapDescriptor(kReadingMore),
        dataEmitted: makeBitMapDescriptor(kDataEmitted)
      });
      function ReadableState(options, stream2, isDuplex) {
        if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof require_duplex();
        this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
        if (options && options.objectMode) this.state |= kObjectMode;
        if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
        this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = [];
        this.flowing = null;
        this[kPaused] = null;
        if (options && options.emitClose === false) this.state &= ~kEmitClose;
        if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
        this.errored = null;
        this.defaultEncoding = options && options.defaultEncoding || "utf8";
        this.awaitDrainWriters = null;
        this.decoder = null;
        this.encoding = null;
        if (options && options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        if (!(this instanceof Readable2)) return new Readable2(options);
        const isDuplex = this instanceof require_duplex();
        this._readableState = new ReadableState(options, this, isDuplex);
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.construct === "function") this._construct = options.construct;
          if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
        }
        Stream.call(this, options);
        destroyImpl.construct(this, () => {
          if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
          }
        });
      }
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      Readable2.prototype[SymbolAsyncDispose] = function() {
        let error;
        if (!this.destroyed) {
          error = this.readableEnded ? null : new AbortError();
          this.destroy(error);
        }
        return new Promise2((resolve2, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve2(null)));
      };
      Readable2.prototype.push = function(chunk, encoding) {
        return readableAddChunk(this, chunk, encoding, false);
      };
      Readable2.prototype.unshift = function(chunk, encoding) {
        return readableAddChunk(this, chunk, encoding, true);
      };
      function readableAddChunk(stream2, chunk, encoding, addToFront) {
        debug("readableAddChunk", chunk);
        const state = stream2._readableState;
        let err;
        if ((state.state & kObjectMode) === 0) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
              if (addToFront && state.encoding) {
                chunk = Buffer6.from(chunk, encoding).toString(state.encoding);
              } else {
                chunk = Buffer6.from(chunk, encoding);
                encoding = "";
              }
            }
          } else if (chunk instanceof Buffer6) {
            encoding = "";
          } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
          } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
          }
        }
        if (err) {
          errorOrDestroy(stream2, err);
        } else if (chunk === null) {
          state.state &= ~kReading;
          onEofChunk(stream2, state);
        } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
          if (addToFront) {
            if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else if (state.destroyed || state.errored) return false;
            else addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed || state.errored) {
            return false;
          } else {
            state.state &= ~kReading;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream2, state, chunk, false);
              else maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.state &= ~kReading;
          maybeReadMore(stream2, state);
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream2, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync && stream2.listenerCount("data") > 0) {
          if ((state.state & kMultiAwaitDrain) !== 0) {
            state.awaitDrainWriters.clear();
          } else {
            state.awaitDrainWriters = null;
          }
          state.dataEmitted = true;
          stream2.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if ((state.state & kNeedReadable) !== 0) emitReadable(stream2);
        }
        maybeReadMore(stream2, state);
      }
      Readable2.prototype.isPaused = function() {
        const state = this._readableState;
        return state[kPaused] === true || state.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        const decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        const buffer2 = this._readableState.buffer;
        let content = "";
        for (const data of buffer2) {
          content += decoder.write(data);
        }
        buffer2.clear();
        if (content !== "") buffer2.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n > MAX_HWM) {
          throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if ((state.state & kObjectMode) !== 0) return 1;
        if (NumberIsNaN(n)) {
          if (state.flowing && state.length) return state.buffer.first().length;
          return state.length;
        }
        if (n <= state.length) return n;
        return state.ended ? state.length : 0;
      }
      Readable2.prototype.read = function(n) {
        debug("read", n);
        if (n === void 0) {
          n = NaN;
        } else if (!NumberIsInteger(n)) {
          n = NumberParseInt(n, 10);
        }
        const state = this._readableState;
        const nOrig = n;
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n !== 0) state.state &= ~kEmittedReadable;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        let doRead = (state.state & kNeedReadable) !== 0;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
          doRead = false;
          debug("reading, ended or constructing", doRead);
        } else if (doRead) {
          debug("do read");
          state.state |= kReading | kSync;
          if (state.length === 0) state.state |= kNeedReadable;
          try {
            this._read(state.highWaterMark);
          } catch (err) {
            errorOrDestroy(this, err);
          }
          state.state &= ~kSync;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        let ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
          } else {
            state.awaitDrainWriters = null;
          }
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
          state.dataEmitted = true;
          this.emit("data", ret);
        }
        return ret;
      };
      function onEofChunk(stream2, state) {
        debug("onEofChunk");
        if (state.ended) return;
        if (state.decoder) {
          const chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream2);
        } else {
          state.needReadable = false;
          state.emittedReadable = true;
          emitReadable_(stream2);
        }
      }
      function emitReadable(stream2) {
        const state = stream2._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          process2.nextTick(emitReadable_, stream2);
        }
      }
      function emitReadable_(stream2) {
        const state = stream2._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && !state.errored && (state.length || state.ended)) {
          stream2.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream2);
      }
      function maybeReadMore(stream2, state) {
        if (!state.readingMore && state.constructed) {
          state.readingMore = true;
          process2.nextTick(maybeReadMore_, stream2, state);
        }
      }
      function maybeReadMore_(stream2, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          const len = state.length;
          debug("maybeReadMore read 0");
          stream2.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        const src = this;
        const state = this._readableState;
        if (state.pipes.length === 1) {
          if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
          }
        }
        state.pipes.push(dest);
        debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
        const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
        const endFn = doEnd ? onend : unpipe;
        if (state.endEmitted) process2.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        let ondrain;
        let cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          if (ondrain) {
            dest.removeListener("drain", ondrain);
          }
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        function pause() {
          if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
              debug("false write response, pause", 0);
              state.awaitDrainWriters = dest;
              state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
              debug("false write response, pause", state.awaitDrainWriters.size);
              state.awaitDrainWriters.add(dest);
            }
            src.pause();
          }
          if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
          }
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          const ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (dest.listenerCount("error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
              errorOrDestroy(dest, er);
            } else {
              dest.emit("error", er);
            }
          }
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (dest.writableNeedDrain === true) {
          pause();
        } else if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src, dest) {
        return function pipeOnDrainFunctionResult() {
          const state = src._readableState;
          if (state.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
          } else if (state.multiAwaitDrain) {
            debug("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
          }
          if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
            src.resume();
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        const state = this._readableState;
        const unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipes.length === 0) return this;
        if (!dest) {
          const dests = state.pipes;
          state.pipes = [];
          this.pause();
          for (let i = 0; i < dests.length; i++)
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          return this;
        }
        const index = ArrayPrototypeIndexOf(state.pipes, dest);
        if (index === -1) return this;
        state.pipes.splice(index, 1);
        if (state.pipes.length === 0) this.pause();
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        const res = Stream.prototype.on.call(this, ev, fn);
        const state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false) this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              process2.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        const res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process2.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.off = Readable2.prototype.removeListener;
      Readable2.prototype.removeAllListeners = function(ev) {
        const res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process2.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        const state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && state[kPaused] === false) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        } else if (!state.readableListening) {
          state.flowing = null;
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        const state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state[kPaused] = false;
        return this;
      };
      function resume(stream2, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process2.nextTick(resume_, stream2, state);
        }
      }
      function resume_(stream2, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream2.read(0);
        }
        state.resumeScheduled = false;
        stream2.emit("resume");
        flow(stream2);
        if (state.flowing && !state.reading) stream2.read(0);
      }
      Readable2.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState[kPaused] = true;
        return this;
      };
      function flow(stream2) {
        const state = stream2._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream2.read() !== null) ;
      }
      Readable2.prototype.wrap = function(stream2) {
        let paused = false;
        stream2.on("data", (chunk) => {
          if (!this.push(chunk) && stream2.pause) {
            paused = true;
            stream2.pause();
          }
        });
        stream2.on("end", () => {
          this.push(null);
        });
        stream2.on("error", (err) => {
          errorOrDestroy(this, err);
        });
        stream2.on("close", () => {
          this.destroy();
        });
        stream2.on("destroy", () => {
          this.destroy();
        });
        this._read = () => {
          if (paused && stream2.resume) {
            paused = false;
            stream2.resume();
          }
        };
        const streamKeys = ObjectKeys(stream2);
        for (let j = 1; j < streamKeys.length; j++) {
          const i = streamKeys[j];
          if (this[i] === void 0 && typeof stream2[i] === "function") {
            this[i] = stream2[i].bind(stream2);
          }
        }
        return this;
      };
      Readable2.prototype[SymbolAsyncIterator] = function() {
        return streamToAsyncIterator(this);
      };
      Readable2.prototype.iterator = function(options) {
        if (options !== void 0) {
          validateObject(options, "options");
        }
        return streamToAsyncIterator(this, options);
      };
      function streamToAsyncIterator(stream2, options) {
        if (typeof stream2.read !== "function") {
          stream2 = Readable2.wrap(stream2, {
            objectMode: true
          });
        }
        const iter = createAsyncIterator(stream2, options);
        iter.stream = stream2;
        return iter;
      }
      async function* createAsyncIterator(stream2, options) {
        let callback = nop2;
        function next(resolve2) {
          if (this === stream2) {
            callback();
            callback = nop2;
          } else {
            callback = resolve2;
          }
        }
        stream2.on("readable", next);
        let error;
        const cleanup = eos(
          stream2,
          {
            writable: false
          },
          (err) => {
            error = err ? aggregateTwoErrors(error, err) : null;
            callback();
            callback = nop2;
          }
        );
        try {
          while (true) {
            const chunk = stream2.destroyed ? null : stream2.read();
            if (chunk !== null) {
              yield chunk;
            } else if (error) {
              throw error;
            } else if (error === null) {
              return;
            } else {
              await new Promise2(next);
            }
          }
        } catch (err) {
          error = aggregateTwoErrors(error, err);
          throw error;
        } finally {
          if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream2._readableState.autoDestroy)) {
            destroyImpl.destroyer(stream2, null);
          } else {
            stream2.off("readable", next);
            cleanup();
          }
        }
      }
      ObjectDefineProperties(Readable2.prototype, {
        readable: {
          __proto__: null,
          get() {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
          },
          set(val2) {
            if (this._readableState) {
              this._readableState.readable = !!val2;
            }
          }
        },
        readableDidRead: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.dataEmitted;
          }
        },
        readableAborted: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
          }
        },
        readableHighWaterMark: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.highWaterMark;
          }
        },
        readableBuffer: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState && this._readableState.buffer;
          }
        },
        readableFlowing: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.flowing;
          },
          set: function(state) {
            if (this._readableState) {
              this._readableState.flowing = state;
            }
          }
        },
        readableLength: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState.length;
          }
        },
        readableObjectMode: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.objectMode : false;
          }
        },
        readableEncoding: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.encoding : null;
          }
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.errored : null;
          }
        },
        closed: {
          __proto__: null,
          get() {
            return this._readableState ? this._readableState.closed : false;
          }
        },
        destroyed: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.destroyed : false;
          },
          set(value) {
            if (!this._readableState) {
              return;
            }
            this._readableState.destroyed = value;
          }
        },
        readableEnded: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.endEmitted : false;
          }
        }
      });
      ObjectDefineProperties(ReadableState.prototype, {
        // Legacy getter for `pipesCount`.
        pipesCount: {
          __proto__: null,
          get() {
            return this.pipes.length;
          }
        },
        // Legacy property for `paused`.
        paused: {
          __proto__: null,
          get() {
            return this[kPaused] !== false;
          },
          set(value) {
            this[kPaused] = !!value;
          }
        }
      });
      Readable2._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0) return null;
        let ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.first();
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream2) {
        const state = stream2._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process2.nextTick(endReadableNT, state, stream2);
        }
      }
      function endReadableNT(state, stream2) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream2.emit("end");
          if (stream2.writable && stream2.allowHalfOpen === false) {
            process2.nextTick(endWritableNT, stream2);
          } else if (state.autoDestroy) {
            const wState = stream2._writableState;
            const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
            // if writable is explicitly set to false.
            (wState.finished || wState.writable === false);
            if (autoDestroy) {
              stream2.destroy();
            }
          }
        }
      }
      function endWritableNT(stream2) {
        const writable = stream2.writable && !stream2.writableEnded && !stream2.destroyed;
        if (writable) {
          stream2.end();
        }
      }
      Readable2.from = function(iterable, opts) {
        return from(Readable2, iterable, opts);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0) webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Readable2.fromWeb = function(readableStream, options) {
        return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
      };
      Readable2.toWeb = function(streamReadable, options) {
        return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
      };
      Readable2.wrap = function(src, options) {
        var _ref, _src$readableObjectMo;
        return new Readable2({
          objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
          ...options,
          destroy(err, callback) {
            destroyImpl.destroyer(src, err);
            callback(err);
          }
        }).wrap(src);
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/writable.js
  var require_writable = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
      init_esbuild_shims();
      var process2 = require_browser4();
      var {
        ArrayPrototypeSlice,
        Error: Error2,
        FunctionPrototypeSymbolHasInstance,
        ObjectDefineProperty,
        ObjectDefineProperties,
        ObjectSetPrototypeOf,
        StringPrototypeToLowerCase,
        Symbol: Symbol2,
        SymbolHasInstance
      } = require_primordials();
      module.exports = Writable2;
      Writable2.WritableState = WritableState;
      var { EventEmitter: EE } = require_events();
      var Stream = require_legacy().Stream;
      var { Buffer: Buffer6 } = require_buffer();
      var destroyImpl = require_destroy();
      var { addAbortSignal } = require_add_abort_signal();
      var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
      var {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK,
        ERR_STREAM_CANNOT_PIPE,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_ALREADY_FINISHED,
        ERR_STREAM_NULL_VALUES,
        ERR_STREAM_WRITE_AFTER_END,
        ERR_UNKNOWN_ENCODING
      } = require_errors().codes;
      var { errorOrDestroy } = destroyImpl;
      ObjectSetPrototypeOf(Writable2.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Writable2, Stream);
      function nop2() {
      }
      var kOnFinished = Symbol2("kOnFinished");
      function WritableState(options, stream2, isDuplex) {
        if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof require_duplex();
        this.objectMode = !!(options && options.objectMode);
        if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
        this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        const noDecode = !!(options && options.decodeStrings === false);
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options && options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = onwrite.bind(void 0, stream2);
        this.writecb = null;
        this.writelen = 0;
        this.afterWriteTickInfo = null;
        resetBuffer(this);
        this.pendingcb = 0;
        this.constructed = true;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = !options || options.emitClose !== false;
        this.autoDestroy = !options || options.autoDestroy !== false;
        this.errored = null;
        this.closed = false;
        this.closeEmitted = false;
        this[kOnFinished] = [];
      }
      function resetBuffer(state) {
        state.buffered = [];
        state.bufferedIndex = 0;
        state.allBuffers = true;
        state.allNoop = true;
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
      };
      ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        }
      });
      function Writable2(options) {
        const isDuplex = this instanceof require_duplex();
        if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable2, this)) return new Writable2(options);
        this._writableState = new WritableState(options, this, isDuplex);
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
          if (typeof options.construct === "function") this._construct = options.construct;
          if (options.signal) addAbortSignal(options.signal, this);
        }
        Stream.call(this, options);
        destroyImpl.construct(this, () => {
          const state = this._writableState;
          if (!state.writing) {
            clearBuffer(this, state);
          }
          finishMaybe(this, state);
        });
      }
      ObjectDefineProperty(Writable2, SymbolHasInstance, {
        __proto__: null,
        value: function(object) {
          if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
          if (this !== Writable2) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function _write(stream2, chunk, encoding, cb) {
        const state = stream2._writableState;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = state.defaultEncoding;
        } else {
          if (!encoding) encoding = state.defaultEncoding;
          else if (encoding !== "buffer" && !Buffer6.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
          if (typeof cb !== "function") cb = nop2;
        }
        if (chunk === null) {
          throw new ERR_STREAM_NULL_VALUES();
        } else if (!state.objectMode) {
          if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
              chunk = Buffer6.from(chunk, encoding);
              encoding = "buffer";
            }
          } else if (chunk instanceof Buffer6) {
            encoding = "buffer";
          } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "buffer";
          } else {
            throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
          }
        }
        let err;
        if (state.ending) {
          err = new ERR_STREAM_WRITE_AFTER_END();
        } else if (state.destroyed) {
          err = new ERR_STREAM_DESTROYED("write");
        }
        if (err) {
          process2.nextTick(cb, err);
          errorOrDestroy(stream2, err, true);
          return err;
        }
        state.pendingcb++;
        return writeOrBuffer(stream2, state, chunk, encoding, cb);
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        return _write(this, chunk, encoding, cb) === true;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        const state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing) clearBuffer(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
        if (!Buffer6.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function writeOrBuffer(stream2, state, chunk, encoding, callback) {
        const len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        const ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked || state.errored || !state.constructed) {
          state.buffered.push({
            chunk,
            encoding,
            callback
          });
          if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
          }
          if (state.allNoop && callback !== nop2) {
            state.allNoop = false;
          }
        } else {
          state.writelen = len;
          state.writecb = callback;
          state.writing = true;
          state.sync = true;
          stream2._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        return ret && !state.errored && !state.destroyed;
      }
      function doWrite(stream2, state, writev2, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev2) stream2._writev(chunk, state.onwrite);
        else stream2._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream2, state, er, cb) {
        --state.pendingcb;
        cb(er);
        errorBuffer(state);
        errorOrDestroy(stream2, er);
      }
      function onwrite(stream2, er) {
        const state = stream2._writableState;
        const sync = state.sync;
        const cb = state.writecb;
        if (typeof cb !== "function") {
          errorOrDestroy(stream2, new ERR_MULTIPLE_CALLBACK());
          return;
        }
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
        if (er) {
          er.stack;
          if (!state.errored) {
            state.errored = er;
          }
          if (stream2._readableState && !stream2._readableState.errored) {
            stream2._readableState.errored = er;
          }
          if (sync) {
            process2.nextTick(onwriteError, stream2, state, er, cb);
          } else {
            onwriteError(stream2, state, er, cb);
          }
        } else {
          if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream2, state);
          }
          if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
              state.afterWriteTickInfo.count++;
            } else {
              state.afterWriteTickInfo = {
                count: 1,
                cb,
                stream: stream2,
                state
              };
              process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
            }
          } else {
            afterWrite(stream2, state, 1, cb);
          }
        }
      }
      function afterWriteTick({ stream: stream2, state, count, cb }) {
        state.afterWriteTickInfo = null;
        return afterWrite(stream2, state, count, cb);
      }
      function afterWrite(stream2, state, count, cb) {
        const needDrain = !state.ending && !stream2.destroyed && state.length === 0 && state.needDrain;
        if (needDrain) {
          state.needDrain = false;
          stream2.emit("drain");
        }
        while (count-- > 0) {
          state.pendingcb--;
          cb();
        }
        if (state.destroyed) {
          errorBuffer(state);
        }
        finishMaybe(stream2, state);
      }
      function errorBuffer(state) {
        if (state.writing) {
          return;
        }
        for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
          var _state$errored;
          const { chunk, callback } = state.buffered[n];
          const len = state.objectMode ? 1 : chunk.length;
          state.length -= len;
          callback(
            (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
          );
        }
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0; i < onfinishCallbacks.length; i++) {
          var _state$errored2;
          onfinishCallbacks[i](
            (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
          );
        }
        resetBuffer(state);
      }
      function clearBuffer(stream2, state) {
        if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
          return;
        }
        const { buffered, bufferedIndex, objectMode } = state;
        const bufferedLength = buffered.length - bufferedIndex;
        if (!bufferedLength) {
          return;
        }
        let i = bufferedIndex;
        state.bufferProcessing = true;
        if (bufferedLength > 1 && stream2._writev) {
          state.pendingcb -= bufferedLength - 1;
          const callback = state.allNoop ? nop2 : (err) => {
            for (let n = i; n < buffered.length; ++n) {
              buffered[n].callback(err);
            }
          };
          const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
          chunks.allBuffers = state.allBuffers;
          doWrite(stream2, state, true, state.length, chunks, "", callback);
          resetBuffer(state);
        } else {
          do {
            const { chunk, encoding, callback } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream2, state, false, len, chunk, encoding, callback);
          } while (i < buffered.length && !state.writing);
          if (i === buffered.length) {
            resetBuffer(state);
          } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
          } else {
            state.bufferedIndex = i;
          }
        }
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        if (this._writev) {
          this._writev(
            [
              {
                chunk,
                encoding
              }
            ],
            cb
          );
        } else {
          throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
        }
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        const state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        let err;
        if (chunk !== null && chunk !== void 0) {
          const ret = _write(this, chunk, encoding);
          if (ret instanceof Error2) {
            err = ret;
          }
        }
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (err) {
        } else if (!state.errored && !state.ending) {
          state.ending = true;
          finishMaybe(this, state, true);
          state.ended = true;
        } else if (state.finished) {
          err = new ERR_STREAM_ALREADY_FINISHED("end");
        } else if (state.destroyed) {
          err = new ERR_STREAM_DESTROYED("end");
        }
        if (typeof cb === "function") {
          if (err || state.finished) {
            process2.nextTick(cb, err);
          } else {
            state[kOnFinished].push(cb);
          }
        }
        return this;
      };
      function needFinish(state) {
        return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
      }
      function callFinal(stream2, state) {
        let called = false;
        function onFinish(err) {
          if (called) {
            errorOrDestroy(stream2, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
            return;
          }
          called = true;
          state.pendingcb--;
          if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for (let i = 0; i < onfinishCallbacks.length; i++) {
              onfinishCallbacks[i](err);
            }
            errorOrDestroy(stream2, err, state.sync);
          } else if (needFinish(state)) {
            state.prefinished = true;
            stream2.emit("prefinish");
            state.pendingcb++;
            process2.nextTick(finish, stream2, state);
          }
        }
        state.sync = true;
        state.pendingcb++;
        try {
          stream2._final(onFinish);
        } catch (err) {
          onFinish(err);
        }
        state.sync = false;
      }
      function prefinish(stream2, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream2._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream2, state);
          } else {
            state.prefinished = true;
            stream2.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream2, state, sync) {
        if (needFinish(state)) {
          prefinish(stream2, state);
          if (state.pendingcb === 0) {
            if (sync) {
              state.pendingcb++;
              process2.nextTick(
                (stream3, state2) => {
                  if (needFinish(state2)) {
                    finish(stream3, state2);
                  } else {
                    state2.pendingcb--;
                  }
                },
                stream2,
                state
              );
            } else if (needFinish(state)) {
              state.pendingcb++;
              finish(stream2, state);
            }
          }
        }
      }
      function finish(stream2, state) {
        state.pendingcb--;
        state.finished = true;
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0; i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i]();
        }
        stream2.emit("finish");
        if (state.autoDestroy) {
          const rState = stream2._readableState;
          const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
          // if readable is explicitly set to false.
          (rState.endEmitted || rState.readable === false);
          if (autoDestroy) {
            stream2.destroy();
          }
        }
      }
      ObjectDefineProperties(Writable2.prototype, {
        closed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.closed : false;
          }
        },
        destroyed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.destroyed : false;
          },
          set(value) {
            if (this._writableState) {
              this._writableState.destroyed = value;
            }
          }
        },
        writable: {
          __proto__: null,
          get() {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
          },
          set(val2) {
            if (this._writableState) {
              this._writableState.writable = !!val2;
            }
          }
        },
        writableFinished: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.finished : false;
          }
        },
        writableObjectMode: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.objectMode : false;
          }
        },
        writableBuffer: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.getBuffer();
          }
        },
        writableEnded: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.ending : false;
          }
        },
        writableNeedDrain: {
          __proto__: null,
          get() {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
          }
        },
        writableHighWaterMark: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.highWaterMark;
          }
        },
        writableCorked: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.corked : 0;
          }
        },
        writableLength: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.length;
          }
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._writableState ? this._writableState.errored : null;
          }
        },
        writableAborted: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
          }
        }
      });
      var destroy = destroyImpl.destroy;
      Writable2.prototype.destroy = function(err, cb) {
        const state = this._writableState;
        if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
          process2.nextTick(errorBuffer, state);
        }
        destroy.call(this, err, cb);
        return this;
      };
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Writable2.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0) webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Writable2.fromWeb = function(writableStream, options) {
        return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
      };
      Writable2.toWeb = function(streamWritable) {
        return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/duplexify.js
  var require_duplexify = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
      init_esbuild_shims();
      var process2 = require_browser4();
      var bufferModule = require_buffer();
      var {
        isReadable: isReadable2,
        isWritable,
        isIterable,
        isNodeStream,
        isReadableNodeStream,
        isWritableNodeStream,
        isDuplexNodeStream,
        isReadableStream,
        isWritableStream
      } = require_utils();
      var eos = require_end_of_stream();
      var {
        AbortError,
        codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
      } = require_errors();
      var { destroyer } = require_destroy();
      var Duplex = require_duplex();
      var Readable2 = require_readable();
      var Writable2 = require_writable();
      var { createDeferredPromise } = require_util2();
      var from = require_from();
      var Blob2 = globalThis.Blob || bufferModule.Blob;
      var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
        return b instanceof Blob2;
      } : function isBlob2(b) {
        return false;
      };
      var AbortController2 = globalThis.AbortController || require_browser3().AbortController;
      var { FunctionPrototypeCall } = require_primordials();
      var Duplexify = class extends Duplex {
        constructor(options) {
          super(options);
          if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
          }
          if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
          }
        }
      };
      module.exports = function duplexify(body, name) {
        if (isDuplexNodeStream(body)) {
          return body;
        }
        if (isReadableNodeStream(body)) {
          return _duplexify({
            readable: body
          });
        }
        if (isWritableNodeStream(body)) {
          return _duplexify({
            writable: body
          });
        }
        if (isNodeStream(body)) {
          return _duplexify({
            writable: false,
            readable: false
          });
        }
        if (isReadableStream(body)) {
          return _duplexify({
            readable: Readable2.fromWeb(body)
          });
        }
        if (isWritableStream(body)) {
          return _duplexify({
            writable: Writable2.fromWeb(body)
          });
        }
        if (typeof body === "function") {
          const { value, write: write2, final, destroy } = fromAsyncGen(body);
          if (isIterable(value)) {
            return from(Duplexify, value, {
              // TODO (ronag): highWaterMark?
              objectMode: true,
              write: write2,
              final,
              destroy
            });
          }
          const then2 = value === null || value === void 0 ? void 0 : value.then;
          if (typeof then2 === "function") {
            let d;
            const promise = FunctionPrototypeCall(
              then2,
              value,
              (val2) => {
                if (val2 != null) {
                  throw new ERR_INVALID_RETURN_VALUE("nully", "body", val2);
                }
              },
              (err) => {
                destroyer(d, err);
              }
            );
            return d = new Duplexify({
              // TODO (ronag): highWaterMark?
              objectMode: true,
              readable: false,
              write: write2,
              final(cb) {
                final(async () => {
                  try {
                    await promise;
                    process2.nextTick(cb, null);
                  } catch (err) {
                    process2.nextTick(cb, err);
                  }
                });
              },
              destroy
            });
          }
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
        }
        if (isBlob(body)) {
          return duplexify(body.arrayBuffer());
        }
        if (isIterable(body)) {
          return from(Duplexify, body, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            writable: false
          });
        }
        if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
          return Duplexify.fromWeb(body);
        }
        if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
          const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
          const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
          return _duplexify({
            readable,
            writable
          });
        }
        const then = body === null || body === void 0 ? void 0 : body.then;
        if (typeof then === "function") {
          let d;
          FunctionPrototypeCall(
            then,
            body,
            (val2) => {
              if (val2 != null) {
                d.push(val2);
              }
              d.push(null);
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            objectMode: true,
            writable: false,
            read() {
            }
          });
        }
        throw new ERR_INVALID_ARG_TYPE2(
          name,
          [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise"
          ],
          body
        );
      };
      function fromAsyncGen(fn) {
        let { promise, resolve: resolve2 } = createDeferredPromise();
        const ac = new AbortController2();
        const signal = ac.signal;
        const value = fn(
          async function* () {
            while (true) {
              const _promise = promise;
              promise = null;
              const { chunk, done, cb } = await _promise;
              process2.nextTick(cb);
              if (done) return;
              if (signal.aborted)
                throw new AbortError(void 0, {
                  cause: signal.reason
                });
              ({ promise, resolve: resolve2 } = createDeferredPromise());
              yield chunk;
            }
          }(),
          {
            signal
          }
        );
        return {
          value,
          write(chunk, encoding, cb) {
            const _resolve = resolve2;
            resolve2 = null;
            _resolve({
              chunk,
              done: false,
              cb
            });
          },
          final(cb) {
            const _resolve = resolve2;
            resolve2 = null;
            _resolve({
              done: true,
              cb
            });
          },
          destroy(err, cb) {
            ac.abort();
            cb(err);
          }
        };
      }
      function _duplexify(pair) {
        const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
        const w = pair.writable;
        let readable = !!isReadable2(r);
        let writable = !!isWritable(w);
        let ondrain;
        let onfinish;
        let onreadable;
        let onclose;
        let d;
        function onfinished(err) {
          const cb = onclose;
          onclose = null;
          if (cb) {
            cb(err);
          } else if (err) {
            d.destroy(err);
          }
        }
        d = new Duplexify({
          // TODO (ronag): highWaterMark?
          readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
          writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
          readable,
          writable
        });
        if (writable) {
          eos(w, (err) => {
            writable = false;
            if (err) {
              destroyer(r, err);
            }
            onfinished(err);
          });
          d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            w.end();
            onfinish = callback;
          };
          w.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
          w.on("finish", function() {
            if (onfinish) {
              const cb = onfinish;
              onfinish = null;
              cb();
            }
          });
        }
        if (readable) {
          eos(r, (err) => {
            readable = false;
            if (err) {
              destroyer(r, err);
            }
            onfinished(err);
          });
          r.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          r.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = r.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        }
        d._destroy = function(err, callback) {
          if (!err && onclose !== null) {
            err = new AbortError();
          }
          onreadable = null;
          ondrain = null;
          onfinish = null;
          if (onclose === null) {
            callback(err);
          } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
          }
        };
        return d;
      }
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/duplex.js
  var require_duplex = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var {
        ObjectDefineProperties,
        ObjectGetOwnPropertyDescriptor,
        ObjectKeys,
        ObjectSetPrototypeOf
      } = require_primordials();
      module.exports = Duplex;
      var Readable2 = require_readable();
      var Writable2 = require_writable();
      ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
      ObjectSetPrototypeOf(Duplex, Readable2);
      {
        const keys = ObjectKeys(Writable2.prototype);
        for (let i = 0; i < keys.length; i++) {
          const method = keys[i];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable2.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        if (options) {
          this.allowHalfOpen = options.allowHalfOpen !== false;
          if (options.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
          }
          if (options.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
          }
        } else {
          this.allowHalfOpen = true;
        }
      }
      ObjectDefineProperties(Duplex.prototype, {
        writable: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writable")
        },
        writableHighWaterMark: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableObjectMode")
        },
        writableBuffer: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableBuffer")
        },
        writableLength: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableLength")
        },
        writableFinished: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableFinished")
        },
        writableCorked: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableCorked")
        },
        writableEnded: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableEnded")
        },
        writableNeedDrain: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableNeedDrain")
        },
        destroyed: {
          __proto__: null,
          get() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set(value) {
            if (this._readableState && this._writableState) {
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          }
        }
      });
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0) webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Duplex.fromWeb = function(pair, options) {
        return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
      };
      Duplex.toWeb = function(duplex) {
        return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
      };
      var duplexify;
      Duplex.from = function(body) {
        if (!duplexify) {
          duplexify = require_duplexify();
        }
        return duplexify(body, "body");
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/transform.js
  var require_transform = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
      module.exports = Transform;
      var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
      var Duplex = require_duplex();
      var { getHighWaterMark } = require_state();
      ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
      ObjectSetPrototypeOf(Transform, Duplex);
      var kCallback = Symbol2("kCallback");
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
        if (readableHighWaterMark === 0) {
          options = {
            ...options,
            highWaterMark: null,
            readableHighWaterMark,
            // TODO (ronag): 0 is not optimal since we have
            // a "bug" where we check needDrain before calling _write and not after.
            // Refs: https://github.com/nodejs/node/pull/32887
            // Refs: https://github.com/nodejs/node/pull/35941
            writableHighWaterMark: options.writableHighWaterMark || 0
          };
        }
        Duplex.call(this, options);
        this._readableState.sync = false;
        this[kCallback] = null;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function final(cb) {
        if (typeof this._flush === "function" && !this.destroyed) {
          this._flush((er, data) => {
            if (er) {
              if (cb) {
                cb(er);
              } else {
                this.destroy(er);
              }
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              cb();
            }
          });
        } else {
          this.push(null);
          if (cb) {
            cb();
          }
        }
      }
      function prefinish() {
        if (this._final !== final) {
          final.call(this);
        }
      }
      Transform.prototype._final = final;
      Transform.prototype._transform = function(chunk, encoding, callback) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
      };
      Transform.prototype._write = function(chunk, encoding, callback) {
        const rState = this._readableState;
        const wState = this._writableState;
        const length = rState.length;
        this._transform(chunk, encoding, (err, val2) => {
          if (err) {
            callback(err);
            return;
          }
          if (val2 != null) {
            this.push(val2);
          }
          if (wState.ended || // Backwards compat.
          length === rState.length || // Backwards compat.
          rState.length < rState.highWaterMark) {
            callback();
          } else {
            this[kCallback] = callback;
          }
        });
      };
      Transform.prototype._read = function() {
        if (this[kCallback]) {
          const callback = this[kCallback];
          this[kCallback] = null;
          callback();
        }
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/passthrough.js
  var require_passthrough = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { ObjectSetPrototypeOf } = require_primordials();
      module.exports = PassThrough;
      var Transform = require_transform();
      ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
      ObjectSetPrototypeOf(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      init_esbuild_shims();
      var process2 = require_browser4();
      var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
      var eos = require_end_of_stream();
      var { once } = require_util2();
      var destroyImpl = require_destroy();
      var Duplex = require_duplex();
      var {
        aggregateTwoErrors,
        codes: {
          ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
          ERR_INVALID_RETURN_VALUE,
          ERR_MISSING_ARGS,
          ERR_STREAM_DESTROYED,
          ERR_STREAM_PREMATURE_CLOSE
        },
        AbortError
      } = require_errors();
      var { validateFunction, validateAbortSignal } = require_validators();
      var {
        isIterable,
        isReadable: isReadable2,
        isReadableNodeStream,
        isNodeStream,
        isTransformStream,
        isWebStream,
        isReadableStream,
        isReadableFinished
      } = require_utils();
      var AbortController2 = globalThis.AbortController || require_browser3().AbortController;
      var PassThrough;
      var Readable2;
      var addAbortListener;
      function destroyer(stream2, reading, writing) {
        let finished = false;
        stream2.on("close", () => {
          finished = true;
        });
        const cleanup = eos(
          stream2,
          {
            readable: reading,
            writable: writing
          },
          (err) => {
            finished = !err;
          }
        );
        return {
          destroy: (err) => {
            if (finished) return;
            finished = true;
            destroyImpl.destroyer(stream2, err || new ERR_STREAM_DESTROYED("pipe"));
          },
          cleanup
        };
      }
      function popCallback(streams) {
        validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
        return streams.pop();
      }
      function makeAsyncIterable(val2) {
        if (isIterable(val2)) {
          return val2;
        } else if (isReadableNodeStream(val2)) {
          return fromReadable(val2);
        }
        throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val2);
      }
      async function* fromReadable(val2) {
        if (!Readable2) {
          Readable2 = require_readable();
        }
        yield* Readable2.prototype[SymbolAsyncIterator].call(val2);
      }
      async function pumpToNode(iterable, writable, finish, { end }) {
        let error;
        let onresolve = null;
        const resume = (err) => {
          if (err) {
            error = err;
          }
          if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
          }
        };
        const wait = () => new Promise2((resolve2, reject) => {
          if (error) {
            reject(error);
          } else {
            onresolve = () => {
              if (error) {
                reject(error);
              } else {
                resolve2();
              }
            };
          }
        });
        writable.on("drain", resume);
        const cleanup = eos(
          writable,
          {
            readable: false
          },
          resume
        );
        try {
          if (writable.writableNeedDrain) {
            await wait();
          }
          for await (const chunk of iterable) {
            if (!writable.write(chunk)) {
              await wait();
            }
          }
          if (end) {
            writable.end();
            await wait();
          }
          finish();
        } catch (err) {
          finish(error !== err ? aggregateTwoErrors(error, err) : err);
        } finally {
          cleanup();
          writable.off("drain", resume);
        }
      }
      async function pumpToWeb(readable, writable, finish, { end }) {
        if (isTransformStream(writable)) {
          writable = writable.writable;
        }
        const writer = writable.getWriter();
        try {
          for await (const chunk of readable) {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
          }
          await writer.ready;
          if (end) {
            await writer.close();
          }
          finish();
        } catch (err) {
          try {
            await writer.abort(err);
            finish(err);
          } catch (err2) {
            finish(err2);
          }
        }
      }
      function pipeline(...streams) {
        return pipelineImpl(streams, once(popCallback(streams)));
      }
      function pipelineImpl(streams, callback, opts) {
        if (streams.length === 1 && ArrayIsArray(streams[0])) {
          streams = streams[0];
        }
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        const ac = new AbortController2();
        const signal = ac.signal;
        const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
        const lastStreamCleanup = [];
        validateAbortSignal(outerSignal, "options.signal");
        function abort() {
          finishImpl(new AbortError());
        }
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        let disposable;
        if (outerSignal) {
          disposable = addAbortListener(outerSignal, abort);
        }
        let error;
        let value;
        const destroys = [];
        let finishCount = 0;
        function finish(err) {
          finishImpl(err, --finishCount === 0);
        }
        function finishImpl(err, final) {
          var _disposable;
          if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
          }
          if (!error && !final) {
            return;
          }
          while (destroys.length) {
            destroys.shift()(error);
          }
          ;
          (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
          ac.abort();
          if (final) {
            if (!error) {
              lastStreamCleanup.forEach((fn) => fn());
            }
            process2.nextTick(callback, error, value);
          }
        }
        let ret;
        for (let i = 0; i < streams.length; i++) {
          const stream2 = streams[i];
          const reading = i < streams.length - 1;
          const writing = i > 0;
          const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
          const isLastStream = i === streams.length - 1;
          if (isNodeStream(stream2)) {
            let onError2 = function(err) {
              if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                finish(err);
              }
            };
            var onError = onError2;
            if (end) {
              const { destroy, cleanup } = destroyer(stream2, reading, writing);
              destroys.push(destroy);
              if (isReadable2(stream2) && isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            }
            stream2.on("error", onError2);
            if (isReadable2(stream2) && isLastStream) {
              lastStreamCleanup.push(() => {
                stream2.removeListener("error", onError2);
              });
            }
          }
          if (i === 0) {
            if (typeof stream2 === "function") {
              ret = stream2({
                signal
              });
              if (!isIterable(ret)) {
                throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
              }
            } else if (isIterable(stream2) || isReadableNodeStream(stream2) || isTransformStream(stream2)) {
              ret = stream2;
            } else {
              ret = Duplex.from(stream2);
            }
          } else if (typeof stream2 === "function") {
            if (isTransformStream(ret)) {
              var _ret;
              ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
            } else {
              ret = makeAsyncIterable(ret);
            }
            ret = stream2(ret, {
              signal
            });
            if (reading) {
              if (!isIterable(ret, true)) {
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
              }
            } else {
              var _ret2;
              if (!PassThrough) {
                PassThrough = require_passthrough();
              }
              const pt = new PassThrough({
                objectMode: true
              });
              const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
              if (typeof then === "function") {
                finishCount++;
                then.call(
                  ret,
                  (val2) => {
                    value = val2;
                    if (val2 != null) {
                      pt.write(val2);
                    }
                    if (end) {
                      pt.end();
                    }
                    process2.nextTick(finish);
                  },
                  (err) => {
                    pt.destroy(err);
                    process2.nextTick(finish, err);
                  }
                );
              } else if (isIterable(ret, true)) {
                finishCount++;
                pumpToNode(ret, pt, finish, {
                  end
                });
              } else if (isReadableStream(ret) || isTransformStream(ret)) {
                const toRead = ret.readable || ret;
                finishCount++;
                pumpToNode(toRead, pt, finish, {
                  end
                });
              } else {
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
              }
              ret = pt;
              const { destroy, cleanup } = destroyer(ret, false, true);
              destroys.push(destroy);
              if (isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            }
          } else if (isNodeStream(stream2)) {
            if (isReadableNodeStream(ret)) {
              finishCount += 2;
              const cleanup = pipe(ret, stream2, finish, {
                end
              });
              if (isReadable2(stream2) && isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            } else if (isTransformStream(ret) || isReadableStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, stream2, finish, {
                end
              });
            } else if (isIterable(ret)) {
              finishCount++;
              pumpToNode(ret, stream2, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_ARG_TYPE2(
                "val",
                ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
                ret
              );
            }
            ret = stream2;
          } else if (isWebStream(stream2)) {
            if (isReadableNodeStream(ret)) {
              finishCount++;
              pumpToWeb(makeAsyncIterable(ret), stream2, finish, {
                end
              });
            } else if (isReadableStream(ret) || isIterable(ret)) {
              finishCount++;
              pumpToWeb(ret, stream2, finish, {
                end
              });
            } else if (isTransformStream(ret)) {
              finishCount++;
              pumpToWeb(ret.readable, stream2, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_ARG_TYPE2(
                "val",
                ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
                ret
              );
            }
            ret = stream2;
          } else {
            ret = Duplex.from(stream2);
          }
        }
        if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
          process2.nextTick(abort);
        }
        return ret;
      }
      function pipe(src, dst, finish, { end }) {
        let ended = false;
        dst.on("close", () => {
          if (!ended) {
            finish(new ERR_STREAM_PREMATURE_CLOSE());
          }
        });
        src.pipe(dst, {
          end: false
        });
        if (end) {
          let endFn2 = function() {
            ended = true;
            dst.end();
          };
          var endFn = endFn2;
          if (isReadableFinished(src)) {
            process2.nextTick(endFn2);
          } else {
            src.once("end", endFn2);
          }
        } else {
          finish();
        }
        eos(
          src,
          {
            readable: true,
            writable: false
          },
          (err) => {
            const rState = src._readableState;
            if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
              src.once("end", finish).once("error", finish);
            } else {
              finish(err);
            }
          }
        );
        return eos(
          dst,
          {
            readable: false,
            writable: true
          },
          finish
        );
      }
      module.exports = {
        pipelineImpl,
        pipeline
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/compose.js
  var require_compose = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { pipeline } = require_pipeline();
      var Duplex = require_duplex();
      var { destroyer } = require_destroy();
      var {
        isNodeStream,
        isReadable: isReadable2,
        isWritable,
        isWebStream,
        isTransformStream,
        isWritableStream,
        isReadableStream
      } = require_utils();
      var {
        AbortError,
        codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
      } = require_errors();
      var eos = require_end_of_stream();
      module.exports = function compose(...streams) {
        if (streams.length === 0) {
          throw new ERR_MISSING_ARGS("streams");
        }
        if (streams.length === 1) {
          return Duplex.from(streams[0]);
        }
        const orgStreams = [...streams];
        if (typeof streams[0] === "function") {
          streams[0] = Duplex.from(streams[0]);
        }
        if (typeof streams[streams.length - 1] === "function") {
          const idx = streams.length - 1;
          streams[idx] = Duplex.from(streams[idx]);
        }
        for (let n = 0; n < streams.length; ++n) {
          if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
            continue;
          }
          if (n < streams.length - 1 && !(isReadable2(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
          }
          if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
          }
        }
        let ondrain;
        let onfinish;
        let onreadable;
        let onclose;
        let d;
        function onfinished(err) {
          const cb = onclose;
          onclose = null;
          if (cb) {
            cb(err);
          } else if (err) {
            d.destroy(err);
          } else if (!readable && !writable) {
            d.destroy();
          }
        }
        const head = streams[0];
        const tail = pipeline(streams, onfinished);
        const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
        const readable = !!(isReadable2(tail) || isReadableStream(tail) || isTransformStream(tail));
        d = new Duplex({
          // TODO (ronag): highWaterMark?
          writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
          readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
          writable,
          readable
        });
        if (writable) {
          if (isNodeStream(head)) {
            d._write = function(chunk, encoding, callback) {
              if (head.write(chunk, encoding)) {
                callback();
              } else {
                ondrain = callback;
              }
            };
            d._final = function(callback) {
              head.end();
              onfinish = callback;
            };
            head.on("drain", function() {
              if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
              }
            });
          } else if (isWebStream(head)) {
            const writable2 = isTransformStream(head) ? head.writable : head;
            const writer = writable2.getWriter();
            d._write = async function(chunk, encoding, callback) {
              try {
                await writer.ready;
                writer.write(chunk).catch(() => {
                });
                callback();
              } catch (err) {
                callback(err);
              }
            };
            d._final = async function(callback) {
              try {
                await writer.ready;
                writer.close().catch(() => {
                });
                onfinish = callback;
              } catch (err) {
                callback(err);
              }
            };
          }
          const toRead = isTransformStream(tail) ? tail.readable : tail;
          eos(toRead, () => {
            if (onfinish) {
              const cb = onfinish;
              onfinish = null;
              cb();
            }
          });
        }
        if (readable) {
          if (isNodeStream(tail)) {
            tail.on("readable", function() {
              if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
              }
            });
            tail.on("end", function() {
              d.push(null);
            });
            d._read = function() {
              while (true) {
                const buf = tail.read();
                if (buf === null) {
                  onreadable = d._read;
                  return;
                }
                if (!d.push(buf)) {
                  return;
                }
              }
            };
          } else if (isWebStream(tail)) {
            const readable2 = isTransformStream(tail) ? tail.readable : tail;
            const reader = readable2.getReader();
            d._read = async function() {
              while (true) {
                try {
                  const { value, done } = await reader.read();
                  if (!d.push(value)) {
                    return;
                  }
                  if (done) {
                    d.push(null);
                    return;
                  }
                } catch {
                  return;
                }
              }
            };
          }
        }
        d._destroy = function(err, callback) {
          if (!err && onclose !== null) {
            err = new AbortError();
          }
          onreadable = null;
          ondrain = null;
          onfinish = null;
          if (onclose === null) {
            callback(err);
          } else {
            onclose = callback;
            if (isNodeStream(tail)) {
              destroyer(tail, err);
            }
          }
        };
        return d;
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/operators.js
  var require_operators = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var AbortController2 = globalThis.AbortController || require_browser3().AbortController;
      var {
        codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
        AbortError
      } = require_errors();
      var { validateAbortSignal, validateInteger, validateObject } = require_validators();
      var kWeakHandler = require_primordials().Symbol("kWeak");
      var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
      var { finished } = require_end_of_stream();
      var staticCompose = require_compose();
      var { addAbortSignalNoValidate } = require_add_abort_signal();
      var { isWritable, isNodeStream } = require_utils();
      var { deprecate } = require_util2();
      var {
        ArrayPrototypePush,
        Boolean: Boolean2,
        MathFloor,
        Number: Number2,
        NumberIsNaN,
        Promise: Promise2,
        PromiseReject,
        PromiseResolve,
        PromisePrototypeThen,
        Symbol: Symbol2
      } = require_primordials();
      var kEmpty = Symbol2("kEmpty");
      var kEof = Symbol2("kEof");
      function compose(stream2, options) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        if (isNodeStream(stream2) && !isWritable(stream2)) {
          throw new ERR_INVALID_ARG_VALUE("stream", stream2, "must be writable");
        }
        const composedStream = staticCompose(this, stream2);
        if (options !== null && options !== void 0 && options.signal) {
          addAbortSignalNoValidate(options.signal, composedStream);
        }
        return composedStream;
      }
      function map2(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
        }
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        let concurrency = 1;
        if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
          concurrency = MathFloor(options.concurrency);
        }
        let highWaterMark = concurrency - 1;
        if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
          highWaterMark = MathFloor(options.highWaterMark);
        }
        validateInteger(concurrency, "options.concurrency", 1);
        validateInteger(highWaterMark, "options.highWaterMark", 0);
        highWaterMark += concurrency;
        return async function* map3() {
          const signal = require_util2().AbortSignalAny(
            [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
          );
          const stream2 = this;
          const queue = [];
          const signalOpt = {
            signal
          };
          let next;
          let resume;
          let done = false;
          let cnt = 0;
          function onCatch() {
            done = true;
            afterItemProcessed();
          }
          function afterItemProcessed() {
            cnt -= 1;
            maybeResume();
          }
          function maybeResume() {
            if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
              resume();
              resume = null;
            }
          }
          async function pump() {
            try {
              for await (let val2 of stream2) {
                if (done) {
                  return;
                }
                if (signal.aborted) {
                  throw new AbortError();
                }
                try {
                  val2 = fn(val2, signalOpt);
                  if (val2 === kEmpty) {
                    continue;
                  }
                  val2 = PromiseResolve(val2);
                } catch (err) {
                  val2 = PromiseReject(err);
                }
                cnt += 1;
                PromisePrototypeThen(val2, afterItemProcessed, onCatch);
                queue.push(val2);
                if (next) {
                  next();
                  next = null;
                }
                if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                  await new Promise2((resolve2) => {
                    resume = resolve2;
                  });
                }
              }
              queue.push(kEof);
            } catch (err) {
              const val2 = PromiseReject(err);
              PromisePrototypeThen(val2, afterItemProcessed, onCatch);
              queue.push(val2);
            } finally {
              done = true;
              if (next) {
                next();
                next = null;
              }
            }
          }
          pump();
          try {
            while (true) {
              while (queue.length > 0) {
                const val2 = await queue[0];
                if (val2 === kEof) {
                  return;
                }
                if (signal.aborted) {
                  throw new AbortError();
                }
                if (val2 !== kEmpty) {
                  yield val2;
                }
                queue.shift();
                maybeResume();
              }
              await new Promise2((resolve2) => {
                next = resolve2;
              });
            }
          } finally {
            done = true;
            if (resume) {
              resume();
              resume = null;
            }
          }
        }.call(this);
      }
      function asIndexedPairs(options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        return async function* asIndexedPairs2() {
          let index = 0;
          for await (const val2 of this) {
            var _options$signal;
            if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
              throw new AbortError({
                cause: options.signal.reason
              });
            }
            yield [index++, val2];
          }
        }.call(this);
      }
      async function some(fn, options = void 0) {
        for await (const unused of filter.call(this, fn, options)) {
          return true;
        }
        return false;
      }
      async function every(fn, options = void 0) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
        }
        return !await some.call(
          this,
          async (...args) => {
            return !await fn(...args);
          },
          options
        );
      }
      async function find(fn, options) {
        for await (const result of filter.call(this, fn, options)) {
          return result;
        }
        return void 0;
      }
      async function forEach(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
        }
        async function forEachFn(value, options2) {
          await fn(value, options2);
          return kEmpty;
        }
        for await (const unused of map2.call(this, forEachFn, options)) ;
      }
      function filter(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
        }
        async function filterFn(value, options2) {
          if (await fn(value, options2)) {
            return value;
          }
          return kEmpty;
        }
        return map2.call(this, filterFn, options);
      }
      var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
        constructor() {
          super("reduce");
          this.message = "Reduce of an empty stream requires an initial value";
        }
      };
      async function reduce(reducer, initialValue, options) {
        var _options$signal2;
        if (typeof reducer !== "function") {
          throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
        }
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        let hasInitialValue = arguments.length > 1;
        if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
          const err = new AbortError(void 0, {
            cause: options.signal.reason
          });
          this.once("error", () => {
          });
          await finished(this.destroy(err));
          throw err;
        }
        const ac = new AbortController2();
        const signal = ac.signal;
        if (options !== null && options !== void 0 && options.signal) {
          const opts = {
            once: true,
            [kWeakHandler]: this,
            [kResistStopPropagation]: true
          };
          options.signal.addEventListener("abort", () => ac.abort(), opts);
        }
        let gotAnyItemFromStream = false;
        try {
          for await (const value of this) {
            var _options$signal3;
            gotAnyItemFromStream = true;
            if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
              throw new AbortError();
            }
            if (!hasInitialValue) {
              initialValue = value;
              hasInitialValue = true;
            } else {
              initialValue = await reducer(initialValue, value, {
                signal
              });
            }
          }
          if (!gotAnyItemFromStream && !hasInitialValue) {
            throw new ReduceAwareErrMissingArgs();
          }
        } finally {
          ac.abort();
        }
        return initialValue;
      }
      async function toArray(options) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        const result = [];
        for await (const val2 of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError(void 0, {
              cause: options.signal.reason
            });
          }
          ArrayPrototypePush(result, val2);
        }
        return result;
      }
      function flatMap(fn, options) {
        const values = map2.call(this, fn, options);
        return async function* flatMap2() {
          for await (const val2 of values) {
            yield* val2;
          }
        }.call(this);
      }
      function toIntegerOrInfinity(number) {
        number = Number2(number);
        if (NumberIsNaN(number)) {
          return 0;
        }
        if (number < 0) {
          throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
        }
        return number;
      }
      function drop(number, options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        number = toIntegerOrInfinity(number);
        return async function* drop2() {
          var _options$signal5;
          if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
            throw new AbortError();
          }
          for await (const val2 of this) {
            var _options$signal6;
            if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
              throw new AbortError();
            }
            if (number-- <= 0) {
              yield val2;
            }
          }
        }.call(this);
      }
      function take(number, options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        number = toIntegerOrInfinity(number);
        return async function* take2() {
          var _options$signal7;
          if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
            throw new AbortError();
          }
          for await (const val2 of this) {
            var _options$signal8;
            if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
              throw new AbortError();
            }
            if (number-- > 0) {
              yield val2;
            }
            if (number <= 0) {
              return;
            }
          }
        }.call(this);
      }
      module.exports.streamReturningOperators = {
        asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
        drop,
        filter,
        flatMap,
        map: map2,
        take,
        compose
      };
      module.exports.promiseReturningOperators = {
        every,
        forEach,
        reduce,
        toArray,
        some,
        find
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/stream/promises.js
  var require_promises = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
      var { isIterable, isNodeStream, isWebStream } = require_utils();
      var { pipelineImpl: pl } = require_pipeline();
      var { finished } = require_end_of_stream();
      require_stream();
      function pipeline(...streams) {
        return new Promise2((resolve2, reject) => {
          let signal;
          let end;
          const lastArg = streams[streams.length - 1];
          if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
            const options = ArrayPrototypePop(streams);
            signal = options.signal;
            end = options.end;
          }
          pl(
            streams,
            (err, value) => {
              if (err) {
                reject(err);
              } else {
                resolve2(value);
              }
            },
            {
              signal,
              end
            }
          );
        });
      }
      module.exports = {
        finished,
        pipeline
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/stream.js
  var require_stream = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/stream.js"(exports, module) {
      init_esbuild_shims();
      var { Buffer: Buffer6 } = require_buffer();
      var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
      var {
        promisify: { custom: customPromisify }
      } = require_util2();
      var { streamReturningOperators, promiseReturningOperators } = require_operators();
      var {
        codes: { ERR_ILLEGAL_CONSTRUCTOR }
      } = require_errors();
      var compose = require_compose();
      var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
      var { pipeline } = require_pipeline();
      var { destroyer } = require_destroy();
      var eos = require_end_of_stream();
      var promises = require_promises();
      var utils = require_utils();
      var Stream = module.exports = require_legacy().Stream;
      Stream.isDestroyed = utils.isDestroyed;
      Stream.isDisturbed = utils.isDisturbed;
      Stream.isErrored = utils.isErrored;
      Stream.isReadable = utils.isReadable;
      Stream.isWritable = utils.isWritable;
      Stream.Readable = require_readable();
      for (const key of ObjectKeys(streamReturningOperators)) {
        let fn2 = function(...args) {
          if (new.target) {
            throw ERR_ILLEGAL_CONSTRUCTOR();
          }
          return Stream.Readable.from(ReflectApply(op, this, args));
        };
        fn = fn2;
        const op = streamReturningOperators[key];
        ObjectDefineProperty(fn2, "name", {
          __proto__: null,
          value: op.name
        });
        ObjectDefineProperty(fn2, "length", {
          __proto__: null,
          value: op.length
        });
        ObjectDefineProperty(Stream.Readable.prototype, key, {
          __proto__: null,
          value: fn2,
          enumerable: false,
          configurable: true,
          writable: true
        });
      }
      var fn;
      for (const key of ObjectKeys(promiseReturningOperators)) {
        let fn2 = function(...args) {
          if (new.target) {
            throw ERR_ILLEGAL_CONSTRUCTOR();
          }
          return ReflectApply(op, this, args);
        };
        fn = fn2;
        const op = promiseReturningOperators[key];
        ObjectDefineProperty(fn2, "name", {
          __proto__: null,
          value: op.name
        });
        ObjectDefineProperty(fn2, "length", {
          __proto__: null,
          value: op.length
        });
        ObjectDefineProperty(Stream.Readable.prototype, key, {
          __proto__: null,
          value: fn2,
          enumerable: false,
          configurable: true,
          writable: true
        });
      }
      var fn;
      Stream.Writable = require_writable();
      Stream.Duplex = require_duplex();
      Stream.Transform = require_transform();
      Stream.PassThrough = require_passthrough();
      Stream.pipeline = pipeline;
      var { addAbortSignal } = require_add_abort_signal();
      Stream.addAbortSignal = addAbortSignal;
      Stream.finished = eos;
      Stream.destroy = destroyer;
      Stream.compose = compose;
      Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
      Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
      ObjectDefineProperty(Stream, "promises", {
        __proto__: null,
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      ObjectDefineProperty(pipeline, customPromisify, {
        __proto__: null,
        enumerable: true,
        get() {
          return promises.pipeline;
        }
      });
      ObjectDefineProperty(eos, customPromisify, {
        __proto__: null,
        enumerable: true,
        get() {
          return promises.finished;
        }
      });
      Stream.Stream = Stream;
      Stream._isUint8Array = function isUint8Array(value) {
        return value instanceof Uint8Array;
      };
      Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
        return Buffer6.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      };
    }
  });

  // node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/browser.js
  var require_browser5 = __commonJS({
    "node_modules/@zenfs/core/node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var CustomStream = require_stream();
      var promises = require_promises();
      var originalDestroy = CustomStream.Readable.destroy;
      module.exports = CustomStream.Readable;
      module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module.exports._isUint8Array = CustomStream._isUint8Array;
      module.exports.isDisturbed = CustomStream.isDisturbed;
      module.exports.isErrored = CustomStream.isErrored;
      module.exports.isReadable = CustomStream.isReadable;
      module.exports.Readable = CustomStream.Readable;
      module.exports.Writable = CustomStream.Writable;
      module.exports.Duplex = CustomStream.Duplex;
      module.exports.Transform = CustomStream.Transform;
      module.exports.PassThrough = CustomStream.PassThrough;
      module.exports.addAbortSignal = CustomStream.addAbortSignal;
      module.exports.finished = CustomStream.finished;
      module.exports.destroy = CustomStream.destroy;
      module.exports.destroy = originalDestroy;
      module.exports.pipeline = CustomStream.pipeline;
      module.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module.exports.Stream = CustomStream.Stream;
      module.exports.default = module.exports;
    }
  });

  // node_modules/int53/index.js
  var require_int53 = __commonJS({
    "node_modules/int53/index.js"(exports, module) {
      init_esbuild_shims();
      var int53 = {};
      var MAX_UINT32 = 4294967295;
      var MAX_INT53 = 9007199254740991;
      function assert(test, message) {
        if (!test) throw new Error(message);
      }
      function onesComplement(number) {
        number = ~number;
        if (number < 0) {
          number = (number & 2147483647) + 2147483648;
        }
        return number;
      }
      function uintHighLow(number) {
        assert(number > -1 && number <= MAX_INT53, "number out of range");
        assert(Math.floor(number) === number, "number must be an integer");
        var high = 0;
        var signbit = number & 4294967295;
        var low = signbit < 0 ? (number & 2147483647) + 2147483648 : signbit;
        if (number > MAX_UINT32) {
          high = (number - low) / (MAX_UINT32 + 1);
        }
        return [high, low];
      }
      function intHighLow(number) {
        if (number > -1) {
          return uintHighLow(number);
        }
        var hl = uintHighLow(-number);
        var high = onesComplement(hl[0]);
        var low = onesComplement(hl[1]);
        if (low === MAX_UINT32) {
          high += 1;
          low = 0;
        } else {
          low += 1;
        }
        return [high, low];
      }
      function toDouble(high, low, signed) {
        if (signed && (high & 2147483648) !== 0) {
          high = onesComplement(high);
          low = onesComplement(low);
          assert(high < 2097152, "number too small");
          return -(high * (MAX_UINT32 + 1) + low + 1);
        } else {
          assert(high < 2097152, "number too large");
          return high * (MAX_UINT32 + 1) + low;
        }
      }
      int53.readInt64BE = function(buffer2, offset) {
        offset = offset || 0;
        var high = buffer2.readUInt32BE(offset);
        var low = buffer2.readUInt32BE(offset + 4);
        return toDouble(high, low, true);
      };
      int53.readInt64LE = function(buffer2, offset) {
        offset = offset || 0;
        var low = buffer2.readUInt32LE(offset);
        var high = buffer2.readUInt32LE(offset + 4);
        return toDouble(high, low, true);
      };
      int53.readUInt64BE = function(buffer2, offset) {
        offset = offset || 0;
        var high = buffer2.readUInt32BE(offset);
        var low = buffer2.readUInt32BE(offset + 4);
        return toDouble(high, low, false);
      };
      int53.readUInt64LE = function(buffer2, offset) {
        offset = offset || 0;
        var low = buffer2.readUInt32LE(offset);
        var high = buffer2.readUInt32LE(offset + 4);
        return toDouble(high, low, false);
      };
      int53.writeInt64BE = function(number, buffer2, offset) {
        offset = offset || 0;
        var hl = intHighLow(number);
        buffer2.writeUInt32BE(hl[0], offset);
        buffer2.writeUInt32BE(hl[1], offset + 4);
      };
      int53.writeInt64LE = function(number, buffer2, offset) {
        offset = offset || 0;
        var hl = intHighLow(number);
        buffer2.writeUInt32LE(hl[1], offset);
        buffer2.writeUInt32LE(hl[0], offset + 4);
      };
      int53.writeUInt64BE = function(number, buffer2, offset) {
        offset = offset || 0;
        var hl = uintHighLow(number);
        buffer2.writeUInt32BE(hl[0], offset);
        buffer2.writeUInt32BE(hl[1], offset + 4);
      };
      int53.writeUInt64LE = function(number, buffer2, offset) {
        offset = offset || 0;
        var hl = uintHighLow(number);
        buffer2.writeUInt32LE(hl[1], offset);
        buffer2.writeUInt32LE(hl[0], offset + 4);
      };
      module.exports = int53;
    }
  });

  // node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/varint/encode.js"(exports, module) {
      init_esbuild_shims();
      module.exports = encode2;
      var MSB = 128;
      var REST = 127;
      var MSBALL = ~REST;
      var INT = Math.pow(2, 31);
      function encode2(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode2.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT) {
          out[offset++] = num & 255 | MSB;
          num /= 128;
        }
        while (num & MSBALL) {
          out[offset++] = num & 255 | MSB;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode2.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/varint/decode.js"(exports, module) {
      init_esbuild_shims();
      module.exports = read2;
      var MSB = 128;
      var REST = 127;
      function read2(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l || shift > 49) {
            read2.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB);
        read2.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/varint/length.js"(exports, module) {
      init_esbuild_shims();
      var N1 = Math.pow(2, 7);
      var N2 = Math.pow(2, 14);
      var N3 = Math.pow(2, 21);
      var N4 = Math.pow(2, 28);
      var N5 = Math.pow(2, 35);
      var N6 = Math.pow(2, 42);
      var N7 = Math.pow(2, 49);
      var N8 = Math.pow(2, 56);
      var N9 = Math.pow(2, 63);
      module.exports = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
    }
  });

  // node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/varint/index.js"(exports, module) {
      init_esbuild_shims();
      module.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/snappyjs/snappy_decompressor.js
  var require_snappy_decompressor = __commonJS({
    "node_modules/snappyjs/snappy_decompressor.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
      function copyBytes(fromArray, fromPos, toArray, toPos, length) {
        var i;
        for (i = 0; i < length; i++) {
          toArray[toPos + i] = fromArray[fromPos + i];
        }
      }
      function selfCopyBytes(array, pos, offset, length) {
        var i;
        for (i = 0; i < length; i++) {
          array[pos + i] = array[pos - offset + i];
        }
      }
      function SnappyDecompressor(compressed) {
        this.array = compressed;
        this.pos = 0;
      }
      SnappyDecompressor.prototype.readUncompressedLength = function() {
        var result = 0;
        var shift = 0;
        var c, val2;
        while (shift < 32 && this.pos < this.array.length) {
          c = this.array[this.pos];
          this.pos += 1;
          val2 = c & 127;
          if (val2 << shift >>> shift !== val2) {
            return -1;
          }
          result |= val2 << shift;
          if (c < 128) {
            return result;
          }
          shift += 7;
        }
        return -1;
      };
      SnappyDecompressor.prototype.uncompressToBuffer = function(outBuffer) {
        var array = this.array;
        var arrayLength = array.length;
        var pos = this.pos;
        var outPos = 0;
        var c, len, smallLen;
        var offset;
        while (pos < array.length) {
          c = array[pos];
          pos += 1;
          if ((c & 3) === 0) {
            len = (c >>> 2) + 1;
            if (len > 60) {
              if (pos + 3 >= arrayLength) {
                return false;
              }
              smallLen = len - 60;
              len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
              len = (len & WORD_MASK[smallLen]) + 1;
              pos += smallLen;
            }
            if (pos + len > arrayLength) {
              return false;
            }
            copyBytes(array, pos, outBuffer, outPos, len);
            pos += len;
            outPos += len;
          } else {
            switch (c & 3) {
              case 1:
                len = (c >>> 2 & 7) + 4;
                offset = array[pos] + (c >>> 5 << 8);
                pos += 1;
                break;
              case 2:
                if (pos + 1 >= arrayLength) {
                  return false;
                }
                len = (c >>> 2) + 1;
                offset = array[pos] + (array[pos + 1] << 8);
                pos += 2;
                break;
              case 3:
                if (pos + 3 >= arrayLength) {
                  return false;
                }
                len = (c >>> 2) + 1;
                offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
                pos += 4;
                break;
              default:
                break;
            }
            if (offset === 0 || offset > outPos) {
              return false;
            }
            selfCopyBytes(outBuffer, outPos, offset, len);
            outPos += len;
          }
        }
        return true;
      };
      exports.SnappyDecompressor = SnappyDecompressor;
    }
  });

  // node_modules/snappyjs/snappy_compressor.js
  var require_snappy_compressor = __commonJS({
    "node_modules/snappyjs/snappy_compressor.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var BLOCK_LOG = 16;
      var BLOCK_SIZE = 1 << BLOCK_LOG;
      var MAX_HASH_TABLE_BITS = 14;
      var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
      function hashFunc(key, hashFuncShift) {
        return key * 506832829 >>> hashFuncShift;
      }
      function load32(array, pos) {
        return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
      }
      function equals32(array, pos1, pos2) {
        return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
      }
      function copyBytes(fromArray, fromPos, toArray, toPos, length) {
        var i;
        for (i = 0; i < length; i++) {
          toArray[toPos + i] = fromArray[fromPos + i];
        }
      }
      function emitLiteral(input, ip, len, output, op) {
        if (len <= 60) {
          output[op] = len - 1 << 2;
          op += 1;
        } else if (len < 256) {
          output[op] = 60 << 2;
          output[op + 1] = len - 1;
          op += 2;
        } else {
          output[op] = 61 << 2;
          output[op + 1] = len - 1 & 255;
          output[op + 2] = len - 1 >>> 8;
          op += 3;
        }
        copyBytes(input, ip, output, op, len);
        return op + len;
      }
      function emitCopyLessThan64(output, op, offset, len) {
        if (len < 12 && offset < 2048) {
          output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
          output[op + 1] = offset & 255;
          return op + 2;
        } else {
          output[op] = 2 + (len - 1 << 2);
          output[op + 1] = offset & 255;
          output[op + 2] = offset >>> 8;
          return op + 3;
        }
      }
      function emitCopy(output, op, offset, len) {
        while (len >= 68) {
          op = emitCopyLessThan64(output, op, offset, 64);
          len -= 64;
        }
        if (len > 64) {
          op = emitCopyLessThan64(output, op, offset, 60);
          len -= 60;
        }
        return emitCopyLessThan64(output, op, offset, len);
      }
      function compressFragment(input, ip, inputSize, output, op) {
        var hashTableBits = 1;
        while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
          hashTableBits += 1;
        }
        hashTableBits -= 1;
        var hashFuncShift = 32 - hashTableBits;
        if (typeof globalHashTables[hashTableBits] === "undefined") {
          globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
        }
        var hashTable = globalHashTables[hashTableBits];
        var i;
        for (i = 0; i < hashTable.length; i++) {
          hashTable[i] = 0;
        }
        var ipEnd = ip + inputSize;
        var ipLimit;
        var baseIp = ip;
        var nextEmit = ip;
        var hash, nextHash;
        var nextIp, candidate, skip;
        var bytesBetweenHashLookups;
        var base, matched, offset;
        var prevHash, curHash;
        var flag = true;
        var INPUT_MARGIN = 15;
        if (inputSize >= INPUT_MARGIN) {
          ipLimit = ipEnd - INPUT_MARGIN;
          ip += 1;
          nextHash = hashFunc(load32(input, ip), hashFuncShift);
          while (flag) {
            skip = 32;
            nextIp = ip;
            do {
              ip = nextIp;
              hash = nextHash;
              bytesBetweenHashLookups = skip >>> 5;
              skip += 1;
              nextIp = ip + bytesBetweenHashLookups;
              if (ip > ipLimit) {
                flag = false;
                break;
              }
              nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
              candidate = baseIp + hashTable[hash];
              hashTable[hash] = ip - baseIp;
            } while (!equals32(input, ip, candidate));
            if (!flag) {
              break;
            }
            op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);
            do {
              base = ip;
              matched = 4;
              while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
                matched += 1;
              }
              ip += matched;
              offset = base - candidate;
              op = emitCopy(output, op, offset, matched);
              nextEmit = ip;
              if (ip >= ipLimit) {
                flag = false;
                break;
              }
              prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
              hashTable[prevHash] = ip - 1 - baseIp;
              curHash = hashFunc(load32(input, ip), hashFuncShift);
              candidate = baseIp + hashTable[curHash];
              hashTable[curHash] = ip - baseIp;
            } while (equals32(input, ip, candidate));
            if (!flag) {
              break;
            }
            ip += 1;
            nextHash = hashFunc(load32(input, ip), hashFuncShift);
          }
        }
        if (nextEmit < ipEnd) {
          op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
        }
        return op;
      }
      function putVarint(value, output, op) {
        do {
          output[op] = value & 127;
          value = value >>> 7;
          if (value > 0) {
            output[op] += 128;
          }
          op += 1;
        } while (value > 0);
        return op;
      }
      function SnappyCompressor(uncompressed) {
        this.array = uncompressed;
      }
      SnappyCompressor.prototype.maxCompressedLength = function() {
        var sourceLen = this.array.length;
        return 32 + sourceLen + Math.floor(sourceLen / 6);
      };
      SnappyCompressor.prototype.compressToBuffer = function(outBuffer) {
        var array = this.array;
        var length = array.length;
        var pos = 0;
        var outPos = 0;
        var fragmentSize;
        outPos = putVarint(length, outBuffer, outPos);
        while (pos < length) {
          fragmentSize = Math.min(length - pos, BLOCK_SIZE);
          outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
          pos += fragmentSize;
        }
        return outPos;
      };
      exports.SnappyCompressor = SnappyCompressor;
    }
  });

  // node_modules/snappyjs/index.js
  var require_snappyjs = __commonJS({
    "node_modules/snappyjs/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      function isNode() {
        if (typeof process === "object") {
          if (typeof process.versions === "object") {
            if (typeof process.versions.node !== "undefined") {
              return true;
            }
          }
        }
        return false;
      }
      function isUint8Array(object) {
        return object instanceof Uint8Array && (!isNode() || !Buffer2.isBuffer(object));
      }
      function isArrayBuffer2(object) {
        return object instanceof ArrayBuffer;
      }
      function isBuffer(object) {
        if (!isNode()) {
          return false;
        }
        return Buffer2.isBuffer(object);
      }
      var SnappyDecompressor = require_snappy_decompressor().SnappyDecompressor;
      var SnappyCompressor = require_snappy_compressor().SnappyCompressor;
      var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
      function uncompress(compressed, maxLength) {
        if (!isUint8Array(compressed) && !isArrayBuffer2(compressed) && !isBuffer(compressed)) {
          throw new TypeError(TYPE_ERROR_MSG);
        }
        var uint8Mode = false;
        var arrayBufferMode = false;
        if (isUint8Array(compressed)) {
          uint8Mode = true;
        } else if (isArrayBuffer2(compressed)) {
          arrayBufferMode = true;
          compressed = new Uint8Array(compressed);
        }
        var decompressor = new SnappyDecompressor(compressed);
        var length = decompressor.readUncompressedLength();
        if (length === -1) {
          throw new Error("Invalid Snappy bitstream");
        }
        if (length > maxLength) {
          throw new Error(`The uncompressed length of ${length} is too big, expect at most ${maxLength}`);
        }
        var uncompressed, uncompressedView;
        if (uint8Mode) {
          uncompressed = new Uint8Array(length);
          if (!decompressor.uncompressToBuffer(uncompressed)) {
            throw new Error("Invalid Snappy bitstream");
          }
        } else if (arrayBufferMode) {
          uncompressed = new ArrayBuffer(length);
          uncompressedView = new Uint8Array(uncompressed);
          if (!decompressor.uncompressToBuffer(uncompressedView)) {
            throw new Error("Invalid Snappy bitstream");
          }
        } else {
          uncompressed = Buffer2.alloc(length);
          if (!decompressor.uncompressToBuffer(uncompressed)) {
            throw new Error("Invalid Snappy bitstream");
          }
        }
        return uncompressed;
      }
      function compress(uncompressed) {
        if (!isUint8Array(uncompressed) && !isArrayBuffer2(uncompressed) && !isBuffer(uncompressed)) {
          throw new TypeError(TYPE_ERROR_MSG);
        }
        var uint8Mode = false;
        var arrayBufferMode = false;
        if (isUint8Array(uncompressed)) {
          uint8Mode = true;
        } else if (isArrayBuffer2(uncompressed)) {
          arrayBufferMode = true;
          uncompressed = new Uint8Array(uncompressed);
        }
        var compressor = new SnappyCompressor(uncompressed);
        var maxLength = compressor.maxCompressedLength();
        var compressed, compressedView;
        var length;
        if (uint8Mode) {
          compressed = new Uint8Array(maxLength);
          length = compressor.compressToBuffer(compressed);
        } else if (arrayBufferMode) {
          compressed = new ArrayBuffer(maxLength);
          compressedView = new Uint8Array(compressed);
          length = compressor.compressToBuffer(compressedView);
        } else {
          compressed = Buffer2.alloc(maxLength);
          length = compressor.compressToBuffer(compressed);
        }
        if (!compressed.slice) {
          var compressedArray = new Uint8Array(Array.prototype.slice.call(compressed, 0, length));
          if (uint8Mode) {
            return compressedArray;
          } else if (arrayBufferMode) {
            return compressedArray.buffer;
          } else {
            throw new Error("Not implemented");
          }
        }
        return compressed.slice(0, length);
      }
      exports.uncompress = uncompress;
      exports.compress = compress;
    }
  });

  // node_modules/brotli-wasm/index.browser.js
  var require_index_browser = __commonJS({
    "node_modules/brotli-wasm/index.browser.js"(exports, module) {
      init_esbuild_shims();
      module.exports = Promise.resolve().then(() => __toESM(require_index_browser()));
      module.exports.default = module.exports;
      module.exports.BrotliWasmType = void 0;
    }
  });

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
      init_esbuild_shims();
      var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof window !== "undefined" && window;
      var __globalThis__ = function() {
        function F() {
          this.fetch = false;
          this.DOMException = __global__.DOMException;
        }
        F.prototype = __global__;
        return new F();
      }();
      (function(globalThis2) {
        var irrelevant = function(exports2) {
          var global2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
          var support = {
            searchParams: "URLSearchParams" in global2,
            iterable: "Symbol" in global2 && "iterator" in Symbol,
            blob: "FileReader" in global2 && "Blob" in global2 && function() {
              try {
                new Blob();
                return true;
              } catch (e2) {
                return false;
              }
            }(),
            formData: "FormData" in global2,
            arrayBuffer: "ArrayBuffer" in global2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name) {
            if (typeof name !== "string") {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
              throw new TypeError('Invalid character in header field name: "' + name + '"');
            }
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers2(headers) {
            this.map = {};
            if (headers instanceof Headers2) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }
          Headers2.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ", " + value : value;
          };
          Headers2.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
          };
          Headers2.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };
          Headers2.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };
          Headers2.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };
          Headers2.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };
          Headers2.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };
          Headers2.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers2.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve2, reject) {
              reader.onload = function() {
                resolve2(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this.bodyUsed = this.bodyUsed;
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  var isConsumed = consumed(this);
                  if (isConsumed) {
                    return isConsumed;
                  }
                  if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                    return Promise.resolve(
                      this._bodyArrayBuffer.buffer.slice(
                        this._bodyArrayBuffer.byteOffset,
                        this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                      )
                    );
                  } else {
                    return Promise.resolve(this._bodyArrayBuffer);
                  }
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode2);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request2(input, options) {
            if (!(this instanceof Request2)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            options = options || {};
            var body = options.body;
            if (input instanceof Request2) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers2(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers2(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
            if (this.method === "GET" || this.method === "HEAD") {
              if (options.cache === "no-store" || options.cache === "no-cache") {
                var reParamSearch = /([?&])_=[^&]*/;
                if (reParamSearch.test(this.url)) {
                  this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                } else {
                  var reQueryString = /\?/;
                  this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                }
              }
            }
          }
          Request2.prototype.clone = function() {
            return new Request2(this, { body: this._bodyInit });
          };
          function decode2(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers2();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split("\r").map(function(header) {
              return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
            }).forEach(function(line) {
              var parts = line.split(":");
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(":").trim();
                headers.append(key, value);
              }
            });
            return headers;
          }
          Body.call(Request2.prototype);
          function Response2(bodyInit, options) {
            if (!(this instanceof Response2)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
            this.headers = new Headers2(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response2.prototype);
          Response2.prototype.clone = function() {
            return new Response2(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers2(this.headers),
              url: this.url
            });
          };
          Response2.error = function() {
            var response = new Response2(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response2.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response2(null, { status, headers: { location: url } });
          };
          exports2.DOMException = global2.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name) {
              this.message = message;
              this.name = name;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch3(input, init2) {
            return new Promise(function(resolve2, reject) {
              var request2 = new Request2(input, init2);
              if (request2.signal && request2.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                setTimeout(function() {
                  resolve2(new Response2(body, options));
                }, 0);
              };
              xhr.onerror = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request failed"));
                }, 0);
              };
              xhr.ontimeout = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request failed"));
                }, 0);
              };
              xhr.onabort = function() {
                setTimeout(function() {
                  reject(new exports2.DOMException("Aborted", "AbortError"));
                }, 0);
              };
              function fixUrl(url) {
                try {
                  return url === "" && global2.location.href ? global2.location.href : url;
                } catch (e2) {
                  return url;
                }
              }
              xhr.open(request2.method, fixUrl(request2.url), true);
              if (request2.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request2.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr) {
                if (support.blob) {
                  xhr.responseType = "blob";
                } else if (support.arrayBuffer && request2.headers.get("Content-Type") && request2.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                  xhr.responseType = "arraybuffer";
                }
              }
              if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers2)) {
                Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                  xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
                });
              } else {
                request2.headers.forEach(function(value, name) {
                  xhr.setRequestHeader(name, value);
                });
              }
              if (request2.signal) {
                request2.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request2.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
            });
          }
          fetch3.polyfill = true;
          if (!global2.fetch) {
            global2.fetch = fetch3;
            global2.Headers = Headers2;
            global2.Request = Request2;
            global2.Response = Response2;
          }
          exports2.Headers = Headers2;
          exports2.Request = Request2;
          exports2.Response = Response2;
          exports2.fetch = fetch3;
          return exports2;
        }({});
      })(__globalThis__);
      __globalThis__.fetch.ponyfill = true;
      delete __globalThis__.fetch.polyfill;
      var ctx = __global__.fetch ? __global__ : __globalThis__;
      exports = ctx.fetch;
      exports.default = ctx.fetch;
      exports.fetch = ctx.fetch;
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;
    }
  });

  // node_modules/fast-xml-parser/src/util.js
  var require_util3 = __commonJS({
    "node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex2) {
        const matches = [];
        let match = regex2.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex2.lastIndex - match[0].length;
          const len = match.length;
          for (let index = 0; index < len; index++) {
            allmatches.push(match[index]);
          }
          matches.push(allmatches);
          match = regex2.exec(string);
        }
        return matches;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v) {
        return typeof v !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a, arrayMode) {
        if (a) {
          const keys = Object.keys(a);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            if (arrayMode === "strict") {
              target[keys[i]] = [a[keys[i]]];
            } else {
              target[keys[i]] = a[keys[i]];
            }
          }
        }
      };
      exports.getValue = function(v) {
        if (exports.isExist(v)) {
          return v;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      init_esbuild_shims();
      var util = require_util3();
      var defaultOptions = {
        allowBooleanAttributes: false,
        //A tag can have attributes without any value
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i = 0; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
            i += 2;
            i = readPI(xmlData, i);
            if (i.err) return i;
          } else if (xmlData[i] === "<") {
            let tagStartPos = i;
            i++;
            if (xmlData[i] === "!") {
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i] === "/") {
                closingTag = true;
                i++;
              }
              let tagName = "";
              for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
                tagName += xmlData[i];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
              }
              const result = readAttributeStr(xmlData, i);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
              }
              let attrStr = result.value;
              i = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid2 = validateAttributeString(attrStr, options);
                if (isValid2 === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject(
                      "InvalidTag",
                      "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                      getLineNumberForPosition(xmlData, tagStartPos)
                    );
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid2 = validateAttributeString(attrStr, options);
                if (isValid2 !== true) {
                  return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid2.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i++; i < xmlData.length; i++) {
                if (xmlData[i] === "<") {
                  if (xmlData[i + 1] === "!") {
                    i++;
                    i = readCommentAndCDATA(xmlData, i);
                    continue;
                  } else if (xmlData[i + 1] === "?") {
                    i = readPI(xmlData, ++i);
                    if (i.err) return i;
                  } else {
                    break;
                  }
                } else if (xmlData[i] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                  i = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                  }
                }
              }
              if (xmlData[i] === "<") {
                i--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i) {
        const start = i;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] == "?" || xmlData[i] == " ") {
            const tagname = xmlData.substr(start, i - start);
            if (i > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
            } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
              i++;
              break;
            } else {
              continue;
            }
          }
        }
        return i;
      }
      function readCommentAndCDATA(xmlData, i) {
        if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
          for (i += 3; i < xmlData.length; i++) {
            if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
          let angleBracketsCount = 1;
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        }
        return i;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i];
            } else if (startChar !== xmlData[i]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i = 0; i < matches.length; i++) {
          if (matches[i][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
          } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
          } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
          }
          const attrName = matches[i][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i) {
        let re = /\d/;
        if (xmlData[i] === "x") {
          i++;
          re = /[\da-fA-F]/;
        }
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === ";")
            return i;
          if (!xmlData[i].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i) {
        i++;
        if (xmlData[i] === ";")
          return -1;
        if (xmlData[i] === "#") {
          i++;
          return validateNumberAmpersand(xmlData, i);
        }
        let count = 0;
        for (; i < xmlData.length; i++, count++) {
          if (xmlData[i].match(/\w/) && count < 20)
            continue;
          if (xmlData[i] === ";")
            break;
          return -1;
        }
        return i;
      }
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          // column number is last line's length + 1, because column numbering starts at 1:
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      init_esbuild_shims();
      var defaultOptions = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        // remove NS from tag name or attribute name if true
        allowBooleanAttributes: false,
        //a tag can have attributes without any value
        //ignoreRootElement : false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        //Trim string values of tag and attributes
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        //nested tags will not be parsed even for errors
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
        // skipEmptyListItem: false
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var XmlNode2 = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__") key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node) {
          if (node.tagname === "__proto__") node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
        }
      };
      module.exports = XmlNode2;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
      init_esbuild_shims();
      var util = require_util3();
      function readDocType(xmlData, i) {
        const entities = {};
        if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
          i = i + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i < xmlData.length; i++) {
            if (xmlData[i] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i)) {
                i += 7;
                [entityName, val, i] = readEntityExp(xmlData, i + 1);
                if (val.indexOf("&") === -1)
                  entities[validateEntityName(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i)) i += 8;
              else if (hasBody && isAttlist(xmlData, i)) i += 8;
              else if (hasBody && isNotation(xmlData, i)) i += 9;
              else if (isComment) comment = true;
              else throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i] === ">") {
              if (comment) {
                if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i };
      }
      function readEntityExp(xmlData, i) {
        let entityName2 = "";
        for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
          entityName2 += xmlData[i];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1) throw new Error("External entites are not supported");
        const startChar = xmlData[i++];
        let val2 = "";
        for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
          val2 += xmlData[i];
        }
        return [entityName2, val2, i];
      }
      function isComment(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-") return true;
        return false;
      }
      function isEntity(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y") return true;
        return false;
      }
      function isElement(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T") return true;
        return false;
      }
      function isAttlist(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T") return true;
        return false;
      }
      function isNotation(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N") return true;
        return false;
      }
      function validateEntityName(name) {
        if (util.isName(name))
          return name;
        else
          throw new Error(`Invalid entity name ${name}`);
      }
      module.exports = readDocType;
    }
  });

  // node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "node_modules/strnum/strnum.js"(exports, module) {
      init_esbuild_shims();
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
        //skipLike: /regex/
      };
      function toNumber2(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string") return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation) return num;
                else return str;
              } else if (eNotation) {
                if (options.eNotation) return num;
                else return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "") return num;
                else if (numStr === numTrimmedByZeros) return num;
                else if (sign && numStr === "-" + numTrimmedByZeros) return num;
                else return str;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr) return num;
                else if (sign + numTrimmedByZeros === numStr) return num;
                else return str;
              }
              if (trimmedStr === numStr) return num;
              else if (trimmedStr === sign + numStr) return num;
              return str;
            }
          } else {
            return str;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".") numStr = "0";
          else if (numStr[0] === ".") numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module.exports = toNumber2;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var util = require_util3();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber2 = require_strnum();
      var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            // "lt" : { regex: /&(lt|#60);/g, val: "<" },
            // "gt" : { regex: /&(gt|#62);/g, val: ">" },
            // "amp" : { regex: /&(amp|#38);/g, val: "&" },
            // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
            // "apos" : { regex: /&(apos|#39);/g, val: "'" },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i = 0; i < entKeys.length; i++) {
          const ent = entKeys[i];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities) val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches = util.getAllMatches(attrStr, attrsRegx);
          const len = matches.length;
          const attrs = {};
          for (let i = 0; i < len; i++) {
            const attrName = this.resolveNameSpace(matches[i][1]);
            let oldVal = matches[i][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__") aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(
                    oldVal,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions
                  );
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i = 0; i < xmlData.length; i++) {
          const ch = xmlData[i];
          if (ch === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              let tagData = readTagExp(xmlData, i, false, "?>");
              if (!tagData) throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i = tagData.closeIndex + 1;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i = endIndex;
            } else if (xmlData.substr(i + 1, 2) === "!D") {
              const result = readDocType(xmlData, i);
              this.docTypeEntities = result.entities;
              i = result.i;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
                if (val2 == void 0) val2 = "";
                currentNode.add(this.options.textNodeName, val2);
              }
              i = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
              let tagName = result.tagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                  if (!result2) throw new Error(`Unexpected end of ${tagName}`);
                  i = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i = closeIndex;
              }
            }
          } else {
            textData += xmlData[i];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0) isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(
            textData,
            currentNode.tagname,
            jPath,
            false,
            currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
            isLeafNode
          );
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary) attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str, i, errMsg) {
        const closingIndex = xmlData.indexOf(str, i);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
        if (!result) return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
          tagExp = tagExp.substr(separatorIndex + 1);
        }
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent
        };
      }
      function readStopNodeData(xmlData, tagName, i) {
        const startIndex = i;
        let openTagCount = 1;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i),
                    i: closeIndex
                  };
                }
              }
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
              i = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true") return true;
          else if (newval === "false") return false;
          else return toNumber2(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module.exports = OrderedObjParser;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      init_esbuild_shims();
      function prettify(node, options) {
        return compress(node, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0) newJpath = property;
          else newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0) text = tagObj[property];
            else text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode) val2[options.textNodeName] = "";
              else val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0) compressedObj[options.textNodeName] = text;
        } else if (text !== void 0) compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@") return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            const atrrName = keys[i];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
      init_esbuild_shims();
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser2 = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        /**
         * Parse XML dats to JS object 
         * @param {string|Buffer} xmlData 
         * @param {boolean|Object} validationOption 
         */
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true) validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
          else return prettify(orderedResult, this.options);
        }
        /**
         * Add Entity which is not by default supported by this library
         * @param {string} key 
         * @param {string} value 
         */
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module.exports = XMLParser2;
    }
  });

  // node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
      init_esbuild_shims();
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const tagName = propName(tagObj);
          let newJPath = "";
          if (jPath.length === 0) newJPath = tagName;
          else newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@") return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module.exports = toXml;
    }
  });

  // node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a) {
          return a;
        },
        attributeValueProcessor: function(attrName, a) {
          return a;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          //it must be on top
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        // transformTagName: false,
        // transformAttributeName: false,
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (typeof jObj[key] === "undefined") {
          } else if (jObj[key] === null) {
            if (key[0] === "?") val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?") val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  listTagVal += this.j2x(item, level + 1).val;
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, "", level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L = Ks.length;
              for (let j = 0; j < L; j++) {
                attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?") return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if (attrStr && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode) closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i = 0; i < this.options.entities.length; i++) {
            const entity = this.options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name) {
        if (name.startsWith(this.options.attributeNamePrefix)) {
          return name.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module.exports = Builder;
    }
  });

  // node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var validator = require_validator();
      var XMLParser2 = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module.exports = {
        XMLParser: XMLParser2,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __read: () => __read,
    __rest: () => __rest,
    __spread: () => __spread,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values
  });
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e2) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t2[p[i]] = s[p[i]];
      }
    return t2;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }
  function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e2;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n]) i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e2) {
      throw e2;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve2, reject) {
          v = o[n](v), settle(resolve2, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve2, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve2({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }
  var extendStatics, __assign;
  var init_tslib_es6 = __esm({
    "node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js"() {
      init_esbuild_shims();
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign3(t2) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
  var require_pureJs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var fromUtf82 = (input) => {
        const bytes = [];
        for (let i = 0, len = input.length; i < len; i++) {
          const value = input.charCodeAt(i);
          if (value < 128) {
            bytes.push(value);
          } else if (value < 2048) {
            bytes.push(value >> 6 | 192, value & 63 | 128);
          } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {
            const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);
            bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
          } else {
            bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
          }
        }
        return Uint8Array.from(bytes);
      };
      exports.fromUtf8 = fromUtf82;
      var toUtf82 = (input) => {
        let decoded = "";
        for (let i = 0, len = input.length; i < len; i++) {
          const byte = input[i];
          if (byte < 128) {
            decoded += String.fromCharCode(byte);
          } else if (192 <= byte && byte < 224) {
            const nextByte = input[++i];
            decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
          } else if (240 <= byte && byte < 365) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
          } else {
            decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);
          }
        }
        return decoded;
      };
      exports.toUtf8 = toUtf82;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
  var require_whatwgEncodingApi = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      function fromUtf82(input) {
        return new TextEncoder().encode(input);
      }
      exports.fromUtf8 = fromUtf82;
      function toUtf82(input) {
        return new TextDecoder("utf-8").decode(input);
      }
      exports.toUtf8 = toUtf82;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
  var require_dist_cjs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var pureJs_1 = require_pureJs();
      var whatwgEncodingApi_1 = require_whatwgEncodingApi();
      var fromUtf82 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
      exports.fromUtf8 = fromUtf82;
      var toUtf82 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
      exports.toUtf8 = toUtf82;
    }
  });

  // node_modules/@aws-crypto/util/build/convertToBuffer.js
  var require_convertToBuffer = __commonJS({
    "node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.convertToBuffer = void 0;
      var util_utf8_browser_1 = require_dist_cjs();
      var fromUtf82 = typeof Buffer2 !== "undefined" && Buffer2.from ? function(input) {
        return Buffer2.from(input, "utf8");
      } : util_utf8_browser_1.fromUtf8;
      function convertToBuffer(data) {
        if (data instanceof Uint8Array)
          return data;
        if (typeof data === "string") {
          return fromUtf82(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      }
      exports.convertToBuffer = convertToBuffer;
    }
  });

  // node_modules/@aws-crypto/util/build/isEmptyData.js
  var require_isEmptyData = __commonJS({
    "node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmptyData = void 0;
      function isEmptyData(data) {
        if (typeof data === "string") {
          return data.length === 0;
        }
        return data.byteLength === 0;
      }
      exports.isEmptyData = isEmptyData;
    }
  });

  // node_modules/@aws-crypto/util/build/numToUint8.js
  var require_numToUint8 = __commonJS({
    "node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.numToUint8 = void 0;
      function numToUint8(num) {
        return new Uint8Array([
          (num & 4278190080) >> 24,
          (num & 16711680) >> 16,
          (num & 65280) >> 8,
          num & 255
        ]);
      }
      exports.numToUint8 = numToUint8;
    }
  });

  // node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
  var require_uint32ArrayFrom = __commonJS({
    "node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = void 0;
      function uint32ArrayFrom(a_lookUpTable) {
        if (!Uint32Array.from) {
          var return_array = new Uint32Array(a_lookUpTable.length);
          var a_index = 0;
          while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
          }
          return return_array;
        }
        return Uint32Array.from(a_lookUpTable);
      }
      exports.uint32ArrayFrom = uint32ArrayFrom;
    }
  });

  // node_modules/@aws-crypto/util/build/index.js
  var require_build = __commonJS({
    "node_modules/@aws-crypto/util/build/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
      var convertToBuffer_1 = require_convertToBuffer();
      Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
        return convertToBuffer_1.convertToBuffer;
      } });
      var isEmptyData_1 = require_isEmptyData();
      Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
        return isEmptyData_1.isEmptyData;
      } });
      var numToUint8_1 = require_numToUint8();
      Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
        return numToUint8_1.numToUint8;
      } });
      var uint32ArrayFrom_1 = require_uint32ArrayFrom();
      Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
        return uint32ArrayFrom_1.uint32ArrayFrom;
      } });
    }
  });

  // node_modules/@aws-crypto/crc32/build/aws_crc32.js
  var require_aws_crc32 = __commonJS({
    "node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwsCrc32 = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var util_1 = require_build();
      var index_1 = require_build2();
      var AwsCrc322 = (
        /** @class */
        function() {
          function AwsCrc323() {
            this.crc32 = new index_1.Crc32();
          }
          AwsCrc323.prototype.update = function(toHash) {
            if ((0, util_1.isEmptyData)(toHash))
              return;
            this.crc32.update((0, util_1.convertToBuffer)(toHash));
          };
          AwsCrc323.prototype.digest = function() {
            return tslib_1.__awaiter(this, void 0, void 0, function() {
              return tslib_1.__generator(this, function(_a) {
                return [2, (0, util_1.numToUint8)(this.crc32.digest())];
              });
            });
          };
          AwsCrc323.prototype.reset = function() {
            this.crc32 = new index_1.Crc32();
          };
          return AwsCrc323;
        }()
      );
      exports.AwsCrc32 = AwsCrc322;
    }
  });

  // node_modules/@aws-crypto/crc32/build/index.js
  var require_build2 = __commonJS({
    "node_modules/@aws-crypto/crc32/build/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var util_1 = require_build();
      function crc32(data) {
        return new Crc32().update(data).digest();
      }
      exports.crc32 = crc32;
      var Crc32 = (
        /** @class */
        function() {
          function Crc322() {
            this.checksum = 4294967295;
          }
          Crc322.prototype.update = function(data) {
            var e_1, _a;
            try {
              for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return this;
          };
          Crc322.prototype.digest = function() {
            return (this.checksum ^ 4294967295) >>> 0;
          };
          return Crc322;
        }()
      );
      exports.Crc32 = Crc32;
      var a_lookUpTable = [
        0,
        1996959894,
        3993919788,
        2567524794,
        124634137,
        1886057615,
        3915621685,
        2657392035,
        249268274,
        2044508324,
        3772115230,
        2547177864,
        162941995,
        2125561021,
        3887607047,
        2428444049,
        498536548,
        1789927666,
        4089016648,
        2227061214,
        450548861,
        1843258603,
        4107580753,
        2211677639,
        325883990,
        1684777152,
        4251122042,
        2321926636,
        335633487,
        1661365465,
        4195302755,
        2366115317,
        997073096,
        1281953886,
        3579855332,
        2724688242,
        1006888145,
        1258607687,
        3524101629,
        2768942443,
        901097722,
        1119000684,
        3686517206,
        2898065728,
        853044451,
        1172266101,
        3705015759,
        2882616665,
        651767980,
        1373503546,
        3369554304,
        3218104598,
        565507253,
        1454621731,
        3485111705,
        3099436303,
        671266974,
        1594198024,
        3322730930,
        2970347812,
        795835527,
        1483230225,
        3244367275,
        3060149565,
        1994146192,
        31158534,
        2563907772,
        4023717930,
        1907459465,
        112637215,
        2680153253,
        3904427059,
        2013776290,
        251722036,
        2517215374,
        3775830040,
        2137656763,
        141376813,
        2439277719,
        3865271297,
        1802195444,
        476864866,
        2238001368,
        4066508878,
        1812370925,
        453092731,
        2181625025,
        4111451223,
        1706088902,
        314042704,
        2344532202,
        4240017532,
        1658658271,
        366619977,
        2362670323,
        4224994405,
        1303535960,
        984961486,
        2747007092,
        3569037538,
        1256170817,
        1037604311,
        2765210733,
        3554079995,
        1131014506,
        879679996,
        2909243462,
        3663771856,
        1141124467,
        855842277,
        2852801631,
        3708648649,
        1342533948,
        654459306,
        3188396048,
        3373015174,
        1466479909,
        544179635,
        3110523913,
        3462522015,
        1591671054,
        702138776,
        2966460450,
        3352799412,
        1504918807,
        783551873,
        3082640443,
        3233442989,
        3988292384,
        2596254646,
        62317068,
        1957810842,
        3939845945,
        2647816111,
        81470997,
        1943803523,
        3814918930,
        2489596804,
        225274430,
        2053790376,
        3826175755,
        2466906013,
        167816743,
        2097651377,
        4027552580,
        2265490386,
        503444072,
        1762050814,
        4150417245,
        2154129355,
        426522225,
        1852507879,
        4275313526,
        2312317920,
        282753626,
        1742555852,
        4189708143,
        2394877945,
        397917763,
        1622183637,
        3604390888,
        2714866558,
        953729732,
        1340076626,
        3518719985,
        2797360999,
        1068828381,
        1219638859,
        3624741850,
        2936675148,
        906185462,
        1090812512,
        3747672003,
        2825379669,
        829329135,
        1181335161,
        3412177804,
        3160834842,
        628085408,
        1382605366,
        3423369109,
        3138078467,
        570562233,
        1426400815,
        3317316542,
        2998733608,
        733239954,
        1555261956,
        3268935591,
        3050360625,
        752459403,
        1541320221,
        2607071920,
        3965973030,
        1969922972,
        40735498,
        2617837225,
        3943577151,
        1913087877,
        83908371,
        2512341634,
        3803740692,
        2075208622,
        213261112,
        2463272603,
        3855990285,
        2094854071,
        198958881,
        2262029012,
        4057260610,
        1759359992,
        534414190,
        2176718541,
        4139329115,
        1873836001,
        414664567,
        2282248934,
        4279200368,
        1711684554,
        285281116,
        2405801727,
        4167216745,
        1634467795,
        376229701,
        2685067896,
        3608007406,
        1308918612,
        956543938,
        2808555105,
        3495958263,
        1231636301,
        1047427035,
        2932959818,
        3654703836,
        1088359270,
        936918e3,
        2847714899,
        3736837829,
        1202900863,
        817233897,
        3183342108,
        3401237130,
        1404277552,
        615818150,
        3134207493,
        3453421203,
        1423857449,
        601450431,
        3009837614,
        3294710456,
        1567103746,
        711928724,
        3020668471,
        3272380065,
        1510334235,
        755167117
      ];
      var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
      var aws_crc32_1 = require_aws_crc32();
      Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
        return aws_crc32_1.AwsCrc32;
      } });
    }
  });

  // node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.es6.js
  var tslib_es6_exports2 = {};
  __export(tslib_es6_exports2, {
    __assign: () => __assign2,
    __asyncDelegator: () => __asyncDelegator2,
    __asyncGenerator: () => __asyncGenerator2,
    __asyncValues: () => __asyncValues2,
    __await: () => __await2,
    __awaiter: () => __awaiter2,
    __classPrivateFieldGet: () => __classPrivateFieldGet2,
    __classPrivateFieldSet: () => __classPrivateFieldSet2,
    __createBinding: () => __createBinding2,
    __decorate: () => __decorate2,
    __exportStar: () => __exportStar2,
    __extends: () => __extends2,
    __generator: () => __generator2,
    __importDefault: () => __importDefault2,
    __importStar: () => __importStar2,
    __makeTemplateObject: () => __makeTemplateObject2,
    __metadata: () => __metadata2,
    __param: () => __param2,
    __read: () => __read2,
    __rest: () => __rest2,
    __spread: () => __spread2,
    __spreadArrays: () => __spreadArrays2,
    __values: () => __values2
  });
  function __extends2(d, b) {
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest2(s, e2) {
    var t2 = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t2[p[i]] = s[p[i]];
      }
    return t2;
  }
  function __decorate2(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param2(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata2(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter2(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator2(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding2(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }
  function __exportStar2(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  function __values2(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read2(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e2;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spread2() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read2(arguments[i]));
    return ar;
  }
  function __spreadArrays2() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __await2(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  }
  function __asyncGenerator2(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n]) i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator2(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e2) {
      throw e2;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues2(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve2, reject) {
          v = o[n](v), settle(resolve2, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve2, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve2({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject2(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar2(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault2(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet2(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet2(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }
  var extendStatics2, __assign2;
  var init_tslib_es62 = __esm({
    "node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.es6.js"() {
      init_esbuild_shims();
      extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      __assign2 = function() {
        __assign2 = Object.assign || function __assign3(t2) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
          }
          return t2;
        };
        return __assign2.apply(this, arguments);
      };
    }
  });

  // node_modules/@aws-crypto/crc32c/build/aws_crc32c.js
  var require_aws_crc32c = __commonJS({
    "node_modules/@aws-crypto/crc32c/build/aws_crc32c.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwsCrc32c = void 0;
      var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
      var util_1 = require_build();
      var index_1 = require_build3();
      var AwsCrc32c2 = (
        /** @class */
        function() {
          function AwsCrc32c3() {
            this.crc32c = new index_1.Crc32c();
          }
          AwsCrc32c3.prototype.update = function(toHash) {
            if ((0, util_1.isEmptyData)(toHash))
              return;
            this.crc32c.update((0, util_1.convertToBuffer)(toHash));
          };
          AwsCrc32c3.prototype.digest = function() {
            return tslib_1.__awaiter(this, void 0, void 0, function() {
              return tslib_1.__generator(this, function(_a) {
                return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
              });
            });
          };
          AwsCrc32c3.prototype.reset = function() {
            this.crc32c = new index_1.Crc32c();
          };
          return AwsCrc32c3;
        }()
      );
      exports.AwsCrc32c = AwsCrc32c2;
    }
  });

  // node_modules/@aws-crypto/crc32c/build/index.js
  var require_build3 = __commonJS({
    "node_modules/@aws-crypto/crc32c/build/index.js"(exports) {
      "use strict";
      init_esbuild_shims();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwsCrc32c = exports.Crc32c = exports.crc32c = void 0;
      var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
      var util_1 = require_build();
      function crc32c(data) {
        return new Crc32c().update(data).digest();
      }
      exports.crc32c = crc32c;
      var Crc32c = (
        /** @class */
        function() {
          function Crc32c2() {
            this.checksum = 4294967295;
          }
          Crc32c2.prototype.update = function(data) {
            var e_1, _a;
            try {
              for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return this;
          };
          Crc32c2.prototype.digest = function() {
            return (this.checksum ^ 4294967295) >>> 0;
          };
          return Crc32c2;
        }()
      );
      exports.Crc32c = Crc32c;
      var a_lookupTable = [
        0,
        4067132163,
        3778769143,
        324072436,
        3348797215,
        904991772,
        648144872,
        3570033899,
        2329499855,
        2024987596,
        1809983544,
        2575936315,
        1296289744,
        3207089363,
        2893594407,
        1578318884,
        274646895,
        3795141740,
        4049975192,
        51262619,
        3619967088,
        632279923,
        922689671,
        3298075524,
        2592579488,
        1760304291,
        2075979607,
        2312596564,
        1562183871,
        2943781820,
        3156637768,
        1313733451,
        549293790,
        3537243613,
        3246849577,
        871202090,
        3878099393,
        357341890,
        102525238,
        4101499445,
        2858735121,
        1477399826,
        1264559846,
        3107202533,
        1845379342,
        2677391885,
        2361733625,
        2125378298,
        820201905,
        3263744690,
        3520608582,
        598981189,
        4151959214,
        85089709,
        373468761,
        3827903834,
        3124367742,
        1213305469,
        1526817161,
        2842354314,
        2107672161,
        2412447074,
        2627466902,
        1861252501,
        1098587580,
        3004210879,
        2688576843,
        1378610760,
        2262928035,
        1955203488,
        1742404180,
        2511436119,
        3416409459,
        969524848,
        714683780,
        3639785095,
        205050476,
        4266873199,
        3976438427,
        526918040,
        1361435347,
        2739821008,
        2954799652,
        1114974503,
        2529119692,
        1691668175,
        2005155131,
        2247081528,
        3690758684,
        697762079,
        986182379,
        3366744552,
        476452099,
        3993867776,
        4250756596,
        255256311,
        1640403810,
        2477592673,
        2164122517,
        1922457750,
        2791048317,
        1412925310,
        1197962378,
        3037525897,
        3944729517,
        427051182,
        170179418,
        4165941337,
        746937522,
        3740196785,
        3451792453,
        1070968646,
        1905808397,
        2213795598,
        2426610938,
        1657317369,
        3053634322,
        1147748369,
        1463399397,
        2773627110,
        4215344322,
        153784257,
        444234805,
        3893493558,
        1021025245,
        3467647198,
        3722505002,
        797665321,
        2197175160,
        1889384571,
        1674398607,
        2443626636,
        1164749927,
        3070701412,
        2757221520,
        1446797203,
        137323447,
        4198817972,
        3910406976,
        461344835,
        3484808360,
        1037989803,
        781091935,
        3705997148,
        2460548119,
        1623424788,
        1939049696,
        2180517859,
        1429367560,
        2807687179,
        3020495871,
        1180866812,
        410100952,
        3927582683,
        4182430767,
        186734380,
        3756733383,
        763408580,
        1053836080,
        3434856499,
        2722870694,
        1344288421,
        1131464017,
        2971354706,
        1708204729,
        2545590714,
        2229949006,
        1988219213,
        680717673,
        3673779818,
        3383336350,
        1002577565,
        4010310262,
        493091189,
        238226049,
        4233660802,
        2987750089,
        1082061258,
        1395524158,
        2705686845,
        1972364758,
        2279892693,
        2494862625,
        1725896226,
        952904198,
        3399985413,
        3656866545,
        731699698,
        4283874585,
        222117402,
        510512622,
        3959836397,
        3280807620,
        837199303,
        582374963,
        3504198960,
        68661723,
        4135334616,
        3844915500,
        390545967,
        1230274059,
        3141532936,
        2825850620,
        1510247935,
        2395924756,
        2091215383,
        1878366691,
        2644384480,
        3553878443,
        565732008,
        854102364,
        3229815391,
        340358836,
        3861050807,
        4117890627,
        119113024,
        1493875044,
        2875275879,
        3090270611,
        1247431312,
        2660249211,
        1828433272,
        2141937292,
        2378227087,
        3811616794,
        291187481,
        34330861,
        4032846830,
        615137029,
        3603020806,
        3314634738,
        939183345,
        1776939221,
        2609017814,
        2295496738,
        2058945313,
        2926798794,
        1545135305,
        1330124605,
        3173225534,
        4084100981,
        17165430,
        307568514,
        3762199681,
        888469610,
        3332340585,
        3587147933,
        665062302,
        2042050490,
        2346497209,
        2559330125,
        1793573966,
        3190661285,
        1279665062,
        1595330642,
        2910671697
      ];
      var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
      var aws_crc32c_1 = require_aws_crc32c();
      Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
        return aws_crc32c_1.AwsCrc32c;
      } });
    }
  });

  // node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_shims();
      module.exports = require_events().EventEmitter;
    }
  });

  // (disabled):node_modules/util/util.js
  var require_util4 = __commonJS({
    "(disabled):node_modules/util/util.js"() {
      init_esbuild_shims();
    }
  });

  // node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list2 = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          })), keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {};
          i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var _require = require_buffer();
      var Buffer6 = _require.Buffer;
      var _require2 = require_util4();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer6.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) ret += s + p.data;
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer6.alloc(0);
            var ret = Buffer6.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer6.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy2 = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose) return;
        if (self2._readableState && !self2._readableState.emitClose) return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream2, err) {
        var rState = stream2._readableState;
        var wState = stream2._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err);
        else stream2.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/state.js
  var require_state2 = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser6 = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      init_esbuild_shims();
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!window.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val2 = window.localStorage[name];
        if (null == val2) return false;
        return String(val2).toLowerCase() === "true";
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = Writable2;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable2.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser6()
      };
      var Stream = require_stream_browser();
      var Buffer6 = require_buffer().Buffer;
      var OurUint8Array = (typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer6.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer6.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy2();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream);
      function nop2() {
      }
      function WritableState(options, stream2, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream2, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable2) return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex = Duplex || require_stream_duplex();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
        }
        Stream.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream2, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream2, er);
        process.nextTick(cb, er);
      }
      function validChunk(stream2, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream2, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer6.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop2;
        if (state.ending) writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer6.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream2, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream2, state, writev2, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev2) stream2._writev(chunk, state.onwrite);
        else stream2._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream2, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe, stream2, state);
          stream2._writableState.errorEmitted = true;
          errorOrDestroy(stream2, er);
        } else {
          cb(er);
          stream2._writableState.errorEmitted = true;
          errorOrDestroy(stream2, er);
          finishMaybe(stream2, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream2, er) {
        var state = stream2._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er) onwriteError(stream2, state, sync, er, cb);
        else {
          var finished = needFinish(state) || stream2.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream2, state);
          }
          if (sync) {
            process.nextTick(afterWrite, stream2, state, finished, cb);
          } else {
            afterWrite(stream2, state, finished, cb);
          }
        }
      }
      function afterWrite(stream2, state, finished, cb) {
        if (!finished) onwriteDrain(stream2, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream2, state);
      }
      function onwriteDrain(stream2, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream2.emit("drain");
        }
      }
      function clearBuffer(stream2, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream2._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer2 = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer2[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer2.allBuffers = allBuffers;
          doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream2, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null) state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending) endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream2, state) {
        stream2._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream2, err);
          }
          state.prefinished = true;
          stream2.emit("prefinish");
          finishMaybe(stream2, state);
        });
      }
      function prefinish(stream2, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream2._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream2, state);
          } else {
            state.prefinished = true;
            stream2.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream2, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream2, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream2.emit("finish");
            if (state.autoDestroy) {
              var rState = stream2._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream2.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream2, state, cb) {
        state.ending = true;
        finishMaybe(stream2, state);
        if (cb) {
          if (state.finished) process.nextTick(cb);
          else stream2.once("finish", cb);
        }
        state.ended = true;
        stream2.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) keys2.push(key);
        return keys2;
      };
      module.exports = Duplex;
      var Readable2 = require_stream_readable();
      var Writable2 = require_stream_writable();
      require_inherits_browser()(Duplex, Readable2);
      {
        keys = objectKeys(Writable2.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false) this.readable = false;
          if (options.writable === false) this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended) return;
        process.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream2 = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream2) {
        return stream2.setHeader && typeof stream2.abort === "function";
      }
      function eos(stream2, opts, callback) {
        if (typeof opts === "function") return eos(stream2, null, opts);
        if (!opts) opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream2.readable;
        var writable = opts.writable || opts.writable !== false && stream2.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream2.writable) onfinish();
        };
        var writableEnded = stream2._writableState && stream2._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream2);
        };
        var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream2);
        };
        var onerror = function onerror2(err) {
          callback.call(stream2, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream2._readableState || !stream2._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream2, err);
          }
          if (writable && !writableEnded) {
            if (!stream2._writableState || !stream2._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream2, err);
          }
        };
        var onrequest = function onrequest2() {
          stream2.req.on("finish", onfinish);
        };
        if (isRequest(stream2)) {
          stream2.on("complete", onfinish);
          stream2.on("abort", onclose);
          if (stream2.req) onrequest();
          else stream2.on("request", onrequest);
        } else if (writable && !stream2._writableState) {
          stream2.on("end", onlegacyfinish);
          stream2.on("close", onlegacyfinish);
        }
        stream2.on("end", onend);
        stream2.on("finish", onfinish);
        if (opts.error !== false) stream2.on("error", onerror);
        stream2.on("close", onclose);
        return function() {
          stream2.removeListener("complete", onfinish);
          stream2.removeListener("abort", onclose);
          stream2.removeListener("request", onrequest);
          if (stream2.req) stream2.req.removeListener("finish", onfinish);
          stream2.removeListener("end", onlegacyfinish);
          stream2.removeListener("close", onlegacyfinish);
          stream2.removeListener("finish", onfinish);
          stream2.removeListener("end", onend);
          stream2.removeListener("error", onerror);
          stream2.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var finished = require_end_of_stream2();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream2,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream2._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream2, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream2.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_shims();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = Readable2;
      var Duplex;
      Readable2.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer6 = require_buffer().Buffer;
      var OurUint8Array = (typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer6.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer6.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util4();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list2();
      var destroyImpl = require_destroy2();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable2, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream2, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable2)) return new Readable2(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer6.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream2._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream2, state);
        } else {
          var er;
          if (!skipChunkCheck) er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream2, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer6.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else addChunk(stream2, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) addChunk(stream2, state, chunk, false);
                else maybeReadMore(stream2, state);
              } else {
                addChunk(stream2, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream2, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream2, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream2.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream2);
        }
        maybeReadMore(stream2, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "") this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n !== n) {
          if (state.flowing && state.length) return state.buffer.head.data.length;
          else return state.length;
        }
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length) return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0) state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream2, state) {
        debug("onEofChunk");
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream2);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream2);
          }
        }
      }
      function emitReadable(stream2) {
        var state = stream2._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_, stream2);
        }
      }
      function emitReadable_(stream2) {
        var state = stream2._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream2.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream2);
      }
      function maybeReadMore(stream2, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_, stream2, state);
        }
      }
      function maybeReadMore_(stream2, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream2.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted) process.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1) return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false) this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream2, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_, stream2, state);
        }
      }
      function resume_(stream2, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream2.read(0);
        }
        state.resumeScheduled = false;
        stream2.emit("resume");
        flow(stream2);
        if (state.flowing && !state.reading) stream2.read(0);
      }
      Readable2.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream2) {
        var state = stream2._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream2.read() !== null) ;
      }
      Readable2.prototype.wrap = function(stream2) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream2.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
          }
          _this.push(null);
        });
        stream2.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream2.pause();
          }
        });
        for (var i in stream2) {
          if (this[i] === void 0 && typeof stream2[i] === "function") {
            this[i] = /* @__PURE__ */ function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream2[method].apply(stream2, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream2.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0) return null;
        var ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.first();
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream2) {
        var state = stream2._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT, state, stream2);
        }
      }
      function endReadableNT(state, stream2) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream2.readable = false;
          stream2.emit("end");
          if (state.autoDestroy) {
            var wState = stream2._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream2.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser();
          }
          return from(Readable2, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) return i;
        }
        return -1;
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = Transform;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream2, er, data) {
        if (er) return stream2.emit("error", er);
        if (data != null)
          stream2.push(data);
        if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream2.push(null);
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      module.exports = PassThrough;
      var Transform = require_stream_transform();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline2 = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_shims();
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err) throw err;
      }
      function isRequest(stream2) {
        return stream2.setHeader && typeof stream2.abort === "function";
      }
      function destroyer(stream2, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream2.on("close", function() {
          closed = true;
        });
        if (eos === void 0) eos = require_end_of_stream2();
        eos(stream2, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true;
          if (isRequest(stream2)) return stream2.abort();
          if (typeof stream2.destroy === "function") return stream2.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop;
        if (typeof streams[streams.length - 1] !== "function") return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream2, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream2, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/readable-stream/readable-browser.js
  var require_readable_browser = __commonJS({
    "node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_shims();
      exports = module.exports = require_stream_readable();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream2();
      exports.pipeline = require_pipeline2();
    }
  });

  // parquet.ts
  var parquet_exports = {};
  __export(parquet_exports, {
    ParquetEnvelopeReader: () => ParquetEnvelopeReader2,
    ParquetEnvelopeWriter: () => ParquetEnvelopeWriter2,
    ParquetFieldBuilder: () => ParquetFieldBuilder,
    ParquetReader: () => ParquetReader2,
    ParquetSchema: () => ParquetSchema2,
    ParquetShredder: () => ParquetShredder,
    ParquetTransformer: () => ParquetTransformer2,
    ParquetWriter: () => ParquetWriter2,
    default: () => parquet_default
  });
  init_esbuild_shims();

  // lib/reader.ts
  init_esbuild_shims();
  var import_node_int64 = __toESM(require_Int64());
  var import_parquet_types4 = __toESM(require_parquet_types());

  // lib/shred.ts
  var shred_exports = {};
  __export(shred_exports, {
    materializeRecords: () => materializeRecords,
    shredRecord: () => shredRecord
  });
  init_esbuild_shims();

  // lib/types.ts
  init_esbuild_shims();
  var bsonSerialize = require_bson().serialize;
  var bsonDeserialize = require_bson().deserialize;
  function getParquetTypeDataObject(type, field) {
    if (type === "DECIMAL") {
      if (field?.typeLength !== void 0 && field?.typeLength !== null) {
        return {
          primitiveType: "FIXED_LEN_BYTE_ARRAY",
          originalType: "DECIMAL",
          typeLength: field.typeLength,
          toPrimitive: toPrimitive_FIXED_LEN_BYTE_ARRAY_DECIMAL
        };
      } else if (field?.precision !== void 0 && field?.precision !== null && field.precision > 18) {
        return {
          primitiveType: "BYTE_ARRAY",
          originalType: "DECIMAL",
          typeLength: field.typeLength,
          toPrimitive: toPrimitive_BYTE_ARRAY_DECIMAL
        };
      } else {
        return {
          primitiveType: "INT64",
          originalType: "DECIMAL",
          toPrimitive: toPrimitive_INT64
        };
      }
    } else {
      return PARQUET_LOGICAL_TYPE_DATA[type];
    }
  }
  var PARQUET_LOGICAL_TYPES = /* @__PURE__ */ new Set([
    "BOOLEAN",
    "INT32",
    "INT64",
    "INT96",
    "FLOAT",
    "DOUBLE",
    "BYTE_ARRAY",
    "FIXED_LEN_BYTE_ARRAY",
    "UTF8",
    "ENUM",
    "TIME_MILLIS",
    "TIME_MICROS",
    "DATE",
    "TIMESTAMP_MILLIS",
    "TIMESTAMP_MICROS",
    "UINT_8",
    "UINT_16",
    "UINT_32",
    "UINT_64",
    "INT_8",
    "INT_16",
    "INT_32",
    "INT_64",
    "DECIMAL",
    "JSON",
    "BSON",
    "INTERVAL",
    "MAP",
    "LIST"
  ]);
  var PARQUET_LOGICAL_TYPE_DATA = {
    BOOLEAN: {
      primitiveType: "BOOLEAN",
      toPrimitive: toPrimitive_BOOLEAN,
      fromPrimitive: fromPrimitive_BOOLEAN
    },
    INT32: {
      primitiveType: "INT32",
      toPrimitive: toPrimitive_INT32
    },
    INT64: {
      primitiveType: "INT64",
      toPrimitive: toPrimitive_INT64
    },
    INT96: {
      primitiveType: "INT96",
      toPrimitive: toPrimitive_INT96
    },
    FLOAT: {
      primitiveType: "FLOAT",
      toPrimitive: toPrimitive_FLOAT
    },
    DOUBLE: {
      primitiveType: "DOUBLE",
      toPrimitive: toPrimitive_DOUBLE
    },
    BYTE_ARRAY: {
      primitiveType: "BYTE_ARRAY",
      toPrimitive: toPrimitive_BYTE_ARRAY
    },
    FIXED_LEN_BYTE_ARRAY: {
      primitiveType: "FIXED_LEN_BYTE_ARRAY",
      toPrimitive: toPrimitive_BYTE_ARRAY
    },
    UTF8: {
      primitiveType: "BYTE_ARRAY",
      originalType: "UTF8",
      toPrimitive: toPrimitive_UTF8,
      fromPrimitive: fromPrimitive_UTF8
    },
    ENUM: {
      primitiveType: "BYTE_ARRAY",
      originalType: "UTF8",
      toPrimitive: toPrimitive_UTF8,
      fromPrimitive: fromPrimitive_UTF8
    },
    TIME_MILLIS: {
      primitiveType: "INT32",
      originalType: "TIME_MILLIS",
      toPrimitive: toPrimitive_TIME_MILLIS
    },
    TIME_MICROS: {
      primitiveType: "INT64",
      originalType: "TIME_MICROS",
      toPrimitive: toPrimitive_TIME_MICROS
    },
    DATE: {
      primitiveType: "INT32",
      originalType: "DATE",
      toPrimitive: toPrimitive_DATE,
      fromPrimitive: fromPrimitive_DATE
    },
    TIMESTAMP_MILLIS: {
      primitiveType: "INT64",
      originalType: "TIMESTAMP_MILLIS",
      toPrimitive: toPrimitive_TIMESTAMP_MILLIS,
      fromPrimitive: fromPrimitive_TIMESTAMP_MILLIS
    },
    TIMESTAMP_MICROS: {
      primitiveType: "INT64",
      originalType: "TIMESTAMP_MICROS",
      toPrimitive: toPrimitive_TIMESTAMP_MICROS,
      fromPrimitive: fromPrimitive_TIMESTAMP_MICROS
    },
    UINT_8: {
      primitiveType: "INT32",
      originalType: "UINT_8",
      toPrimitive: toPrimitive_UINT8
    },
    UINT_16: {
      primitiveType: "INT32",
      originalType: "UINT_16",
      toPrimitive: toPrimitive_UINT16
    },
    UINT_32: {
      primitiveType: "INT32",
      originalType: "UINT_32",
      toPrimitive: toPrimitive_UINT32
    },
    UINT_64: {
      primitiveType: "INT64",
      originalType: "UINT_64",
      toPrimitive: toPrimitive_UINT64
    },
    INT_8: {
      primitiveType: "INT32",
      originalType: "INT_8",
      toPrimitive: toPrimitive_INT8
    },
    INT_16: {
      primitiveType: "INT32",
      originalType: "INT_16",
      toPrimitive: toPrimitive_INT16
    },
    INT_32: {
      primitiveType: "INT32",
      originalType: "INT_32",
      toPrimitive: toPrimitive_INT32
    },
    INT_64: {
      primitiveType: "INT64",
      originalType: "INT_64",
      toPrimitive: toPrimitive_INT64
    },
    JSON: {
      primitiveType: "BYTE_ARRAY",
      originalType: "JSON",
      toPrimitive: toPrimitive_JSON,
      fromPrimitive: fromPrimitive_JSON
    },
    BSON: {
      primitiveType: "BYTE_ARRAY",
      originalType: "BSON",
      toPrimitive: toPrimitive_BSON,
      fromPrimitive: fromPrimitive_BSON
    },
    INTERVAL: {
      primitiveType: "FIXED_LEN_BYTE_ARRAY",
      originalType: "INTERVAL",
      typeLength: 12,
      toPrimitive: toPrimitive_INTERVAL,
      fromPrimitive: fromPrimitive_INTERVAL
    },
    MAP: {
      originalType: "MAP",
      toPrimitive: toPrimitive_MAP
    },
    LIST: {
      originalType: "LIST",
      toPrimitive: toPrimitive_LIST
    }
  };
  function isParquetType(type) {
    return type !== void 0 && PARQUET_LOGICAL_TYPES.has(type);
  }
  function toPrimitive(type, value, field) {
    if (!isParquetType(type)) {
      throw "invalid type: " + type || "undefined";
    }
    return getParquetTypeDataObject(type, field).toPrimitive(value);
  }
  function fromPrimitive(type, value, field) {
    if (!isParquetType(type)) {
      throw "invalid type: " + type || "undefined";
    }
    const typeFromPrimitive = getParquetTypeDataObject(type, field).fromPrimitive;
    if (typeFromPrimitive !== void 0) {
      return typeFromPrimitive(value);
    } else {
      return value;
    }
  }
  function toPrimitive_BOOLEAN(value) {
    return !!value;
  }
  function fromPrimitive_BOOLEAN(value) {
    return !!value;
  }
  function toPrimitive_FLOAT(value) {
    if (typeof value === "string") {
      const v = parseFloat(value);
      return v;
    } else if (typeof value === "number") {
      return value;
    }
    throw "invalid value for FLOAT: " + value;
  }
  function toPrimitive_DOUBLE(value) {
    if (typeof value === "string") {
      const v = parseFloat(value);
      return v;
    } else if (typeof value === "number") {
      return value;
    }
    throw "invalid value for DOUBLE: " + value;
  }
  function toPrimitive_INT8(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(-128, 127, v);
      return v;
    } catch {
      throw "invalid value for INT8: " + value;
    }
  }
  function toPrimitive_UINT8(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(0, 255, v);
      return v;
    } catch {
      throw "invalid value for UINT8: " + value;
    }
  }
  function toPrimitive_INT16(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(-32768, 32767, v);
      return v;
    } catch {
      throw "invalid value for INT16: " + value;
    }
  }
  function toPrimitive_UINT16(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(0, 65535, v);
      return v;
    } catch {
      throw "invalid value for UINT16: " + value;
    }
  }
  function toPrimitive_INT32(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(-2147483648, 2147483647, v);
      return v;
    } catch {
      throw "invalid value for INT32: " + value;
    }
  }
  function toPrimitive_UINT32(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(0, 281474976710655, v);
      return v;
    } catch {
      throw "invalid value for UINT32: " + value;
    }
  }
  var MIN_64 = BigInt("0x8000000000000000") * -1n;
  var MAX_64 = BigInt("0x7fffffffffffffff");
  function toPrimitive_INT64(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(MIN_64, MAX_64, v);
      return v;
    } catch {
      throw "invalid value for INT64: " + value;
    }
  }
  var MAX_U64 = BigInt("0xffffffffffffffff");
  function toPrimitive_UINT64(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(0, MAX_U64, v);
      return v;
    } catch {
      throw "invalid value for UINT64: " + value;
    }
  }
  var MIN_96 = BigInt("0x800000000000000000000000") * -1n;
  var MAX_96 = BigInt("0x7fffffffffffffffffffffff");
  function toPrimitive_INT96(value) {
    try {
      let v = value;
      if (typeof v === "string") v = BigInt(value);
      checkValidValue(MIN_96, MAX_96, v);
      return v;
    } catch {
      throw "invalid value for INT96: " + value;
    }
  }
  function toPrimitive_FIXED_LEN_BYTE_ARRAY_DECIMAL(value) {
    return Buffer2.from(value);
  }
  function toPrimitive_BYTE_ARRAY_DECIMAL(value) {
    return Buffer2.from(value);
  }
  function toPrimitive_MAP(value) {
    return value;
  }
  function toPrimitive_LIST(value) {
    return value;
  }
  function toPrimitive_BYTE_ARRAY(value) {
    return Buffer2.from(value);
  }
  function toPrimitive_UTF8(value) {
    return Buffer2.from(value, "utf8");
  }
  function fromPrimitive_UTF8(value) {
    return value !== void 0 && value !== null ? value.toString() : value;
  }
  function toPrimitive_JSON(value) {
    return Buffer2.from(JSON.stringify(value));
  }
  function fromPrimitive_JSON(value) {
    return JSON.parse(value);
  }
  function toPrimitive_BSON(value) {
    return Buffer2.from(bsonSerialize(value));
  }
  function fromPrimitive_BSON(value) {
    return bsonDeserialize(value);
  }
  function toNumberInternal(typeName, value) {
    let numberValue = 0;
    switch (typeof value) {
      case "string":
        numberValue = parseInt(value, 10);
        break;
      case "number":
        numberValue = value;
        break;
      default:
        throw `${typeName} has an invalid type: ${typeof value}`;
    }
    if (numberValue < 0 || numberValue >= Number.MAX_SAFE_INTEGER) {
      throw `${typeName} value is out of bounds: ${numberValue}`;
    }
    return numberValue;
  }
  function toPrimitive_TIME_MILLIS(value) {
    return toNumberInternal("TIME_MILLIS", value);
  }
  function toPrimitive_TIME_MICROS(value) {
    const v = BigInt(value);
    if (v < 0n) {
      throw "TIME_MICROS value is out of bounds: " + value;
    }
    return v;
  }
  var kMillisPerDay = 864e5;
  function toPrimitive_DATE(value) {
    if (value instanceof Date) {
      return value.getTime() / kMillisPerDay;
    }
    return toNumberInternal("DATE", value);
  }
  function fromPrimitive_DATE(value) {
    return new Date(+value * kMillisPerDay);
  }
  function toPrimitive_TIMESTAMP_MILLIS(value) {
    if (value instanceof Date) {
      return value.getTime();
    }
    return toNumberInternal("TIMESTAMP_MILLIS", value);
  }
  function fromPrimitive_TIMESTAMP_MILLIS(value) {
    return new Date(Number(value));
  }
  function toPrimitive_TIMESTAMP_MICROS(value) {
    if (value instanceof Date) {
      return BigInt(value.getTime()) * 1000n;
    }
    try {
      const v = BigInt(value);
      if (v < 0n) {
        throw "out of bounds";
      }
      return v;
    } catch (e2) {
      throw "TIMESTAMP_MICROS value is out of bounds: " + value;
    }
  }
  function fromPrimitive_TIMESTAMP_MICROS(value) {
    if (typeof value === "bigint") return new Date(Number(value / 1000n));
    return new Date(value / 1e3);
  }
  function toPrimitive_INTERVAL(value) {
    if (!value.months || !value.days || !value.milliseconds) {
      throw "value for INTERVAL must be object { months: ..., days: ..., milliseconds: ... }";
    }
    const buf = Buffer2.alloc(12);
    buf.writeUInt32LE(value.months, 0);
    buf.writeUInt32LE(value.days, 4);
    buf.writeUInt32LE(value.milliseconds, 8);
    return buf;
  }
  function fromPrimitive_INTERVAL(value) {
    const buf = Buffer2.from(value);
    const months = buf.readUInt32LE(0);
    const days = buf.readUInt32LE(4);
    const millis = buf.readUInt32LE(8);
    return { months, days, milliseconds: millis };
  }
  function checkValidValue(lowerRange, upperRange, v) {
    if (v < lowerRange || v > upperRange) {
      throw "invalid value";
    }
  }

  // lib/shred.ts
  var shredRecord = function(schema, record, buffer2) {
    const recordShredded = {};
    for (const field of schema.fieldList) {
      recordShredded[field.path.join(",")] = {
        dlevels: [],
        rlevels: [],
        values: [],
        distinct_values: /* @__PURE__ */ new Set(),
        count: 0
      };
    }
    shredRecordInternal(schema.fields, record, recordShredded, 0, 0);
    if (!("columnData" in buffer2) || !("rowCount" in buffer2)) {
      buffer2.rowCount = 0;
      buffer2.pageRowCount = 0;
      buffer2.columnData = {};
      buffer2.pages = {};
      for (const field of schema.fieldList) {
        const path = field.path.join(",");
        buffer2.columnData[path] = {
          dlevels: [],
          rlevels: [],
          values: [],
          distinct_values: /* @__PURE__ */ new Set(),
          count: 0
        };
        buffer2.pages[path] = [];
      }
    }
    buffer2.rowCount += 1;
    buffer2.pageRowCount += 1;
    for (const field of schema.fieldList) {
      const path = field.path.join(",");
      const record2 = recordShredded[path];
      const column = buffer2.columnData[path];
      for (let i = 0; i < record2.rlevels.length; i++) {
        column.rlevels.push(record2.rlevels[i]);
        column.dlevels.push(record2.dlevels[i]);
        if (record2.values[i] !== void 0) {
          column.values.push(record2.values[i]);
        }
      }
      [...recordShredded[path].distinct_values].forEach((value) => buffer2.columnData[path].distinct_values.add(value));
      buffer2.columnData[path].count += recordShredded[path].count;
    }
  };
  function shredRecordInternal(fields, record, data, rlvl, dlvl) {
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const fieldType = field.originalType || field.primitiveType;
      const path = field.path.join(",");
      let values = [];
      if (record && fieldName in record && record[fieldName] !== void 0 && record[fieldName] !== null) {
        if (Array.isArray(record[fieldName])) {
          values = record[fieldName];
        } else if (ArrayBuffer.isView(record[fieldName])) {
          if (record[fieldName] instanceof Uint8Array) {
            values.push(Buffer2.from(record[fieldName]));
          } else {
            throw Object.prototype.toString.call(record[fieldName]) + " is not supported";
          }
        } else {
          values.push(record[fieldName]);
        }
      }
      if (values.length == 0 && !!record && field.repetitionType === "REQUIRED") {
        throw "missing required field: " + field.name;
      }
      if (values.length > 1 && field.repetitionType !== "REPEATED") {
        throw "too many values for field: " + field.name;
      }
      if (values.length == 0) {
        if (field.isNested && isDefined(field.fields)) {
          shredRecordInternal(field.fields, null, data, rlvl, dlvl);
        } else {
          data[path].rlevels.push(rlvl);
          data[path].dlevels.push(dlvl);
          data[path].count += 1;
        }
        continue;
      }
      for (let i = 0; i < values.length; ++i) {
        const rlvl_i = i === 0 ? rlvl : field.rLevelMax;
        if (field.isNested && isDefined(field.fields)) {
          shredRecordInternal(field.fields, values[i], data, rlvl_i, field.dLevelMax);
        } else {
          data[path].distinct_values.add(values[i]);
          data[path].values.push(toPrimitive(fieldType, values[i], field));
          data[path].rlevels.push(rlvl_i);
          data[path].dlevels.push(field.dLevelMax);
          data[path].count += 1;
        }
      }
    }
  }
  var materializeRecords = function(schema, buffer2, records) {
    if (!records) {
      records = [];
    }
    for (const k in buffer2.columnData) {
      const field = schema.findField(k);
      const fieldBranch = schema.findFieldBranch(k);
      const values = buffer2.columnData[k].values[Symbol.iterator]();
      const rLevels = new Array(field.rLevelMax + 1);
      rLevels.fill(0);
      for (let i = 0; i < buffer2.columnData[k].count; ++i) {
        const dLevel = buffer2.columnData[k].dlevels[i];
        const rLevel = buffer2.columnData[k].rlevels[i];
        rLevels[rLevel]++;
        rLevels.fill(0, rLevel + 1);
        let value = null;
        if (dLevel === field.dLevelMax) {
          value = fromPrimitive(field.originalType || field.primitiveType, values.next().value, field);
        }
        records[rLevels[0] - 1] = records[rLevels[0] - 1] || {};
        materializeRecordField(
          records[rLevels[0] - 1],
          fieldBranch,
          rLevels.slice(1),
          dLevel,
          value
        );
      }
    }
    return records;
  };
  function materializeRecordField(record, branch, rLevels, dLevel, value) {
    const node = branch[0];
    if (dLevel < node.dLevelMax) {
      record[node.name] = value;
      return;
    }
    if (branch.length > 1) {
      if (node.repetitionType === "REPEATED") {
        if (!(node.name in record)) {
          record[node.name] = [];
        }
        const recordValue = record[node.name];
        while (recordValue.length < rLevels[0] + 1) {
          recordValue.push({});
        }
        materializeRecordField(recordValue[rLevels[0]], branch.slice(1), rLevels.slice(1), dLevel, value);
      } else {
        record[node.name] = record[node.name] || {};
        const recordValue = record[node.name];
        materializeRecordField(recordValue, branch.slice(1), rLevels, dLevel, value);
      }
    } else {
      if (node.repetitionType === "REPEATED") {
        if (!(node.name in record)) {
          record[node.name] = [];
        }
        const recordValue = record[node.name];
        while (recordValue.length < rLevels[0] + 1) {
          recordValue.push(null);
        }
        recordValue[rLevels[0]] = value;
      } else {
        record[node.name] = value;
      }
    }
  }
  function isDefined(val2) {
    return val2 !== void 0;
  }

  // lib/util.ts
  init_esbuild_shims();
  var import_thrift = __toESM(require_browser2());

  // node_modules/@zenfs/core/dist/index.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/error.js
  init_esbuild_shims();
  var Errno;
  (function(Errno2) {
    Errno2[Errno2["EPERM"] = 1] = "EPERM";
    Errno2[Errno2["ENOENT"] = 2] = "ENOENT";
    Errno2[Errno2["EINTR"] = 4] = "EINTR";
    Errno2[Errno2["EIO"] = 5] = "EIO";
    Errno2[Errno2["ENXIO"] = 6] = "ENXIO";
    Errno2[Errno2["EBADF"] = 9] = "EBADF";
    Errno2[Errno2["EAGAIN"] = 11] = "EAGAIN";
    Errno2[Errno2["ENOMEM"] = 12] = "ENOMEM";
    Errno2[Errno2["EACCES"] = 13] = "EACCES";
    Errno2[Errno2["EFAULT"] = 14] = "EFAULT";
    Errno2[Errno2["ENOTBLK"] = 15] = "ENOTBLK";
    Errno2[Errno2["EBUSY"] = 16] = "EBUSY";
    Errno2[Errno2["EEXIST"] = 17] = "EEXIST";
    Errno2[Errno2["EXDEV"] = 18] = "EXDEV";
    Errno2[Errno2["ENODEV"] = 19] = "ENODEV";
    Errno2[Errno2["ENOTDIR"] = 20] = "ENOTDIR";
    Errno2[Errno2["EISDIR"] = 21] = "EISDIR";
    Errno2[Errno2["EINVAL"] = 22] = "EINVAL";
    Errno2[Errno2["ENFILE"] = 23] = "ENFILE";
    Errno2[Errno2["EMFILE"] = 24] = "EMFILE";
    Errno2[Errno2["ETXTBSY"] = 26] = "ETXTBSY";
    Errno2[Errno2["EFBIG"] = 27] = "EFBIG";
    Errno2[Errno2["ENOSPC"] = 28] = "ENOSPC";
    Errno2[Errno2["ESPIPE"] = 29] = "ESPIPE";
    Errno2[Errno2["EROFS"] = 30] = "EROFS";
    Errno2[Errno2["EMLINK"] = 31] = "EMLINK";
    Errno2[Errno2["EPIPE"] = 32] = "EPIPE";
    Errno2[Errno2["EDOM"] = 33] = "EDOM";
    Errno2[Errno2["ERANGE"] = 34] = "ERANGE";
    Errno2[Errno2["EDEADLK"] = 35] = "EDEADLK";
    Errno2[Errno2["ENAMETOOLONG"] = 36] = "ENAMETOOLONG";
    Errno2[Errno2["ENOLCK"] = 37] = "ENOLCK";
    Errno2[Errno2["ENOSYS"] = 38] = "ENOSYS";
    Errno2[Errno2["ENOTEMPTY"] = 39] = "ENOTEMPTY";
    Errno2[Errno2["ELOOP"] = 40] = "ELOOP";
    Errno2[Errno2["ENOMSG"] = 42] = "ENOMSG";
    Errno2[Errno2["EBADE"] = 52] = "EBADE";
    Errno2[Errno2["EBADR"] = 53] = "EBADR";
    Errno2[Errno2["EXFULL"] = 54] = "EXFULL";
    Errno2[Errno2["ENOANO"] = 55] = "ENOANO";
    Errno2[Errno2["EBADRQC"] = 56] = "EBADRQC";
    Errno2[Errno2["ENOSTR"] = 60] = "ENOSTR";
    Errno2[Errno2["ENODATA"] = 61] = "ENODATA";
    Errno2[Errno2["ETIME"] = 62] = "ETIME";
    Errno2[Errno2["ENOSR"] = 63] = "ENOSR";
    Errno2[Errno2["ENONET"] = 64] = "ENONET";
    Errno2[Errno2["EREMOTE"] = 66] = "EREMOTE";
    Errno2[Errno2["ENOLINK"] = 67] = "ENOLINK";
    Errno2[Errno2["ECOMM"] = 70] = "ECOMM";
    Errno2[Errno2["EPROTO"] = 71] = "EPROTO";
    Errno2[Errno2["EBADMSG"] = 74] = "EBADMSG";
    Errno2[Errno2["EOVERFLOW"] = 75] = "EOVERFLOW";
    Errno2[Errno2["EBADFD"] = 77] = "EBADFD";
    Errno2[Errno2["ESTRPIPE"] = 86] = "ESTRPIPE";
    Errno2[Errno2["ENOTSOCK"] = 88] = "ENOTSOCK";
    Errno2[Errno2["EDESTADDRREQ"] = 89] = "EDESTADDRREQ";
    Errno2[Errno2["EMSGSIZE"] = 90] = "EMSGSIZE";
    Errno2[Errno2["EPROTOTYPE"] = 91] = "EPROTOTYPE";
    Errno2[Errno2["ENOPROTOOPT"] = 92] = "ENOPROTOOPT";
    Errno2[Errno2["EPROTONOSUPPORT"] = 93] = "EPROTONOSUPPORT";
    Errno2[Errno2["ESOCKTNOSUPPORT"] = 94] = "ESOCKTNOSUPPORT";
    Errno2[Errno2["ENOTSUP"] = 95] = "ENOTSUP";
    Errno2[Errno2["ENETDOWN"] = 100] = "ENETDOWN";
    Errno2[Errno2["ENETUNREACH"] = 101] = "ENETUNREACH";
    Errno2[Errno2["ENETRESET"] = 102] = "ENETRESET";
    Errno2[Errno2["ETIMEDOUT"] = 110] = "ETIMEDOUT";
    Errno2[Errno2["ECONNREFUSED"] = 111] = "ECONNREFUSED";
    Errno2[Errno2["EHOSTDOWN"] = 112] = "EHOSTDOWN";
    Errno2[Errno2["EHOSTUNREACH"] = 113] = "EHOSTUNREACH";
    Errno2[Errno2["EALREADY"] = 114] = "EALREADY";
    Errno2[Errno2["EINPROGRESS"] = 115] = "EINPROGRESS";
    Errno2[Errno2["ESTALE"] = 116] = "ESTALE";
    Errno2[Errno2["EREMOTEIO"] = 121] = "EREMOTEIO";
    Errno2[Errno2["EDQUOT"] = 122] = "EDQUOT";
  })(Errno || (Errno = {}));
  var errorMessages = {
    [Errno.EPERM]: "Operation not permitted",
    [Errno.ENOENT]: "No such file or directory",
    [Errno.EINTR]: "Interrupted system call",
    [Errno.EIO]: "Input/output error",
    [Errno.ENXIO]: "No such device or address",
    [Errno.EBADF]: "Bad file descriptor",
    [Errno.EAGAIN]: "Resource temporarily unavailable",
    [Errno.ENOMEM]: "Cannot allocate memory",
    [Errno.EACCES]: "Permission denied",
    [Errno.EFAULT]: "Bad address",
    [Errno.ENOTBLK]: "Block device required",
    [Errno.EBUSY]: "Resource busy or locked",
    [Errno.EEXIST]: "File exists",
    [Errno.EXDEV]: "Invalid cross-device link",
    [Errno.ENODEV]: "No such device",
    [Errno.ENOTDIR]: "File is not a directory",
    [Errno.EISDIR]: "File is a directory",
    [Errno.EINVAL]: "Invalid argument",
    [Errno.ENFILE]: "Too many open files in system",
    [Errno.EMFILE]: "Too many open files",
    [Errno.ETXTBSY]: "Text file busy",
    [Errno.EFBIG]: "File is too big",
    [Errno.ENOSPC]: "No space left on disk",
    [Errno.ESPIPE]: "Illegal seek",
    [Errno.EROFS]: "Cannot modify a read-only file system",
    [Errno.EMLINK]: "Too many links",
    [Errno.EPIPE]: "Broken pipe",
    [Errno.EDOM]: "Numerical argument out of domain",
    [Errno.ERANGE]: "Numerical result out of range",
    [Errno.EDEADLK]: "Resource deadlock would occur",
    [Errno.ENAMETOOLONG]: "File name too long",
    [Errno.ENOLCK]: "No locks available",
    [Errno.ENOSYS]: "Function not implemented",
    [Errno.ENOTEMPTY]: "Directory is not empty",
    [Errno.ELOOP]: "Too many levels of symbolic links",
    [Errno.ENOMSG]: "No message of desired type",
    [Errno.EBADE]: "Invalid exchange",
    [Errno.EBADR]: "Invalid request descriptor",
    [Errno.EXFULL]: "Exchange full",
    [Errno.ENOANO]: "No anode",
    [Errno.EBADRQC]: "Invalid request code",
    [Errno.ENOSTR]: "Device not a stream",
    [Errno.ENODATA]: "No data available",
    [Errno.ETIME]: "Timer expired",
    [Errno.ENOSR]: "Out of streams resources",
    [Errno.ENONET]: "Machine is not on the network",
    [Errno.EREMOTE]: "Object is remote",
    [Errno.ENOLINK]: "Link has been severed",
    [Errno.ECOMM]: "Communication error on send",
    [Errno.EPROTO]: "Protocol error",
    [Errno.EBADMSG]: "Bad message",
    [Errno.EOVERFLOW]: "Value too large for defined data type",
    [Errno.EBADFD]: "File descriptor in bad state",
    [Errno.ESTRPIPE]: "Streams pipe error",
    [Errno.ENOTSOCK]: "Socket operation on non-socket",
    [Errno.EDESTADDRREQ]: "Destination address required",
    [Errno.EMSGSIZE]: "Message too long",
    [Errno.EPROTOTYPE]: "Protocol wrong type for socket",
    [Errno.ENOPROTOOPT]: "Protocol not available",
    [Errno.EPROTONOSUPPORT]: "Protocol not supported",
    [Errno.ESOCKTNOSUPPORT]: "Socket type not supported",
    [Errno.ENOTSUP]: "Operation is not supported",
    [Errno.ENETDOWN]: "Network is down",
    [Errno.ENETUNREACH]: "Network is unreachable",
    [Errno.ENETRESET]: "Network dropped connection on reset",
    [Errno.ETIMEDOUT]: "Connection timed out",
    [Errno.ECONNREFUSED]: "Connection refused",
    [Errno.EHOSTDOWN]: "Host is down",
    [Errno.EHOSTUNREACH]: "No route to host",
    [Errno.EALREADY]: "Operation already in progress",
    [Errno.EINPROGRESS]: "Operation now in progress",
    [Errno.ESTALE]: "Stale file handle",
    [Errno.EREMOTEIO]: "Remote I/O error",
    [Errno.EDQUOT]: "Disk quota exceeded"
  };
  var ErrnoError = class _ErrnoError extends Error {
    static fromJSON(json) {
      const err = new _ErrnoError(json.errno, json.message, json.path, json.syscall);
      err.code = json.code;
      err.stack = json.stack;
      return err;
    }
    static With(code, path, syscall) {
      return new _ErrnoError(Errno[code], errorMessages[Errno[code]], path, syscall);
    }
    /**
     * Represents a ZenFS error. Passed back to applications after a failed
     * call to the ZenFS API.
     *
     * Error codes mirror those returned by regular Unix file operations, which is
     * what Node returns.
     * @param type The type of the error.
     * @param message A descriptive error message.
     */
    constructor(errno, message = errorMessages[errno], path, syscall = "") {
      super(message);
      this.errno = errno;
      this.path = path;
      this.syscall = syscall;
      this.code = Errno[errno];
      this.message = `${this.code}: ${message}${this.path ? `, '${this.path}'` : ""}`;
    }
    /**
     * @return A friendly error message.
     */
    toString() {
      return this.message;
    }
    toJSON() {
      return {
        errno: this.errno,
        code: this.code,
        path: this.path,
        stack: this.stack,
        message: this.message,
        syscall: this.syscall
      };
    }
    /**
     * The size of the API error in buffer-form in bytes.
     */
    bufferSize() {
      return 4 + JSON.stringify(this.toJSON()).length;
    }
  };

  // node_modules/@zenfs/core/dist/backends/port/fs.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/file.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/emulation/constants.js
  var constants_exports = {};
  __export(constants_exports, {
    COPYFILE_EXCL: () => COPYFILE_EXCL,
    COPYFILE_FICLONE: () => COPYFILE_FICLONE,
    COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
    F_OK: () => F_OK,
    O_APPEND: () => O_APPEND,
    O_CREAT: () => O_CREAT,
    O_DIRECT: () => O_DIRECT,
    O_DIRECTORY: () => O_DIRECTORY,
    O_DSYNC: () => O_DSYNC,
    O_EXCL: () => O_EXCL,
    O_NOATIME: () => O_NOATIME,
    O_NOCTTY: () => O_NOCTTY,
    O_NOFOLLOW: () => O_NOFOLLOW,
    O_NONBLOCK: () => O_NONBLOCK,
    O_RDONLY: () => O_RDONLY,
    O_RDWR: () => O_RDWR,
    O_SYMLINK: () => O_SYMLINK,
    O_SYNC: () => O_SYNC,
    O_TRUNC: () => O_TRUNC,
    O_WRONLY: () => O_WRONLY,
    R_OK: () => R_OK,
    S_IFBLK: () => S_IFBLK,
    S_IFCHR: () => S_IFCHR,
    S_IFDIR: () => S_IFDIR,
    S_IFIFO: () => S_IFIFO,
    S_IFLNK: () => S_IFLNK,
    S_IFMT: () => S_IFMT,
    S_IFREG: () => S_IFREG,
    S_IFSOCK: () => S_IFSOCK,
    S_IRGRP: () => S_IRGRP,
    S_IROTH: () => S_IROTH,
    S_IRUSR: () => S_IRUSR,
    S_IRWXG: () => S_IRWXG,
    S_IRWXO: () => S_IRWXO,
    S_IRWXU: () => S_IRWXU,
    S_ISGID: () => S_ISGID,
    S_ISUID: () => S_ISUID,
    S_ISVTX: () => S_ISVTX,
    S_IWGRP: () => S_IWGRP,
    S_IWOTH: () => S_IWOTH,
    S_IWUSR: () => S_IWUSR,
    S_IXGRP: () => S_IXGRP,
    S_IXOTH: () => S_IXOTH,
    S_IXUSR: () => S_IXUSR,
    UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
    W_OK: () => W_OK,
    X_OK: () => X_OK
  });
  init_esbuild_shims();
  var F_OK = 0;
  var R_OK = 4;
  var W_OK = 2;
  var X_OK = 1;
  var COPYFILE_EXCL = 1;
  var COPYFILE_FICLONE = 2;
  var COPYFILE_FICLONE_FORCE = 4;
  var O_RDONLY = 0;
  var O_WRONLY = 1;
  var O_RDWR = 2;
  var O_CREAT = 64;
  var O_EXCL = 128;
  var O_NOCTTY = 256;
  var O_TRUNC = 512;
  var O_APPEND = 1024;
  var O_DIRECTORY = 65536;
  var O_NOATIME = 262144;
  var O_NOFOLLOW = 131072;
  var O_SYNC = 1052672;
  var O_DSYNC = 4096;
  var O_SYMLINK = 32768;
  var O_DIRECT = 16384;
  var O_NONBLOCK = 2048;
  var S_IFMT = 61440;
  var S_IFSOCK = 49152;
  var S_IFLNK = 40960;
  var S_IFREG = 32768;
  var S_IFBLK = 24576;
  var S_IFDIR = 16384;
  var S_IFCHR = 8192;
  var S_IFIFO = 4096;
  var S_ISUID = 2048;
  var S_ISGID = 1024;
  var S_ISVTX = 512;
  var S_IRWXU = 448;
  var S_IRUSR = 256;
  var S_IWUSR = 128;
  var S_IXUSR = 64;
  var S_IRWXG = 56;
  var S_IRGRP = 32;
  var S_IWGRP = 16;
  var S_IXGRP = 8;
  var S_IRWXO = 7;
  var S_IROTH = 4;
  var S_IWOTH = 2;
  var S_IXOTH = 1;
  var UV_FS_O_FILEMAP = 0;

  // node_modules/@zenfs/core/dist/inode.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/stats.js
  init_esbuild_shims();
  var FileType;
  (function(FileType2) {
    FileType2[FileType2["FILE"] = 32768] = "FILE";
    FileType2[FileType2["DIRECTORY"] = 16384] = "DIRECTORY";
    FileType2[FileType2["SYMLINK"] = 40960] = "SYMLINK";
  })(FileType || (FileType = {}));
  var StatsCommon = class {
    _convert(arg) {
      return this._isBigint ? BigInt(arg) : Number(arg);
    }
    get blocks() {
      return this._convert(Math.ceil(Number(this.size) / 512));
    }
    get atime() {
      return new Date(Number(this.atimeMs));
    }
    set atime(value) {
      this.atimeMs = this._convert(value.getTime());
    }
    get mtime() {
      return new Date(Number(this.mtimeMs));
    }
    set mtime(value) {
      this.mtimeMs = this._convert(value.getTime());
    }
    get ctime() {
      return new Date(Number(this.ctimeMs));
    }
    set ctime(value) {
      this.ctimeMs = this._convert(value.getTime());
    }
    get birthtime() {
      return new Date(Number(this.birthtimeMs));
    }
    set birthtime(value) {
      this.birthtimeMs = this._convert(value.getTime());
    }
    /**
     * Creates a new stats instance from a stats-like object. Can be used to copy stats (note)
     */
    constructor({ atimeMs, mtimeMs, ctimeMs, birthtimeMs, uid, gid, size, mode, ino } = {}) {
      this.dev = this._convert(0);
      this.ino = this._convert(0);
      this.rdev = this._convert(0);
      this.nlink = this._convert(1);
      this.blksize = this._convert(4096);
      this.uid = this._convert(0);
      this.gid = this._convert(0);
      const now = Date.now();
      this.atimeMs = this._convert(atimeMs ?? now);
      this.mtimeMs = this._convert(mtimeMs ?? now);
      this.ctimeMs = this._convert(ctimeMs ?? now);
      this.birthtimeMs = this._convert(birthtimeMs ?? now);
      this.uid = this._convert(uid ?? 0);
      this.gid = this._convert(gid ?? 0);
      this.size = this._convert(size ?? 0);
      this.ino = this._convert(ino ?? 0);
      const itemType = Number(mode) & S_IFMT || FileType.FILE;
      if (mode) {
        this.mode = this._convert(mode);
      } else {
        switch (itemType) {
          case FileType.FILE:
            this.mode = this._convert(420);
            break;
          case FileType.DIRECTORY:
          default:
            this.mode = this._convert(511);
        }
      }
      if ((this.mode & S_IFMT) == 0) {
        this.mode = this.mode | this._convert(itemType);
      }
    }
    /**
     * @returns true if this item is a file.
     */
    isFile() {
      return (this.mode & S_IFMT) === S_IFREG;
    }
    /**
     * @returns True if this item is a directory.
     */
    isDirectory() {
      return (this.mode & S_IFMT) === S_IFDIR;
    }
    /**
     * @returns true if this item is a symbolic link
     */
    isSymbolicLink() {
      return (this.mode & S_IFMT) === S_IFLNK;
    }
    // Currently unsupported
    isSocket() {
      return (this.mode & S_IFMT) === S_IFSOCK;
    }
    isBlockDevice() {
      return (this.mode & S_IFMT) === S_IFBLK;
    }
    isCharacterDevice() {
      return (this.mode & S_IFMT) === S_IFCHR;
    }
    isFIFO() {
      return (this.mode & S_IFMT) === S_IFIFO;
    }
    /**
     * Checks if a given user/group has access to this item
     * @param mode The requested access, combination of W_OK, R_OK, and X_OK
     * @param cred The requesting credentials
     * @returns True if the request has access, false if the request does not
     * @internal
     */
    hasAccess(mode, cred2) {
      if (cred2.euid === 0 || cred2.egid === 0) {
        return true;
      }
      const adjusted = (cred2.uid == this.uid ? S_IRWXU : 0) | (cred2.gid == this.gid ? S_IRWXG : 0) | S_IRWXO;
      return (mode & this.mode & adjusted) == mode;
    }
    /**
     * Convert the current stats object into a credentials object
     * @internal
     */
    cred(uid = Number(this.uid), gid = Number(this.gid)) {
      return {
        uid,
        gid,
        suid: Number(this.uid),
        sgid: Number(this.gid),
        euid: uid,
        egid: gid
      };
    }
    /**
     * Change the mode of the file. We use this helper function to prevent messing
     * up the type of the file, which is encoded in mode.
     * @internal
     */
    chmod(mode) {
      this.mode = this._convert(this.mode & S_IFMT | mode);
    }
    /**
     * Change the owner user/group of the file.
     * This function makes sure it is a valid UID/GID (that is, a 32 unsigned int)
     * @internal
     */
    chown(uid, gid) {
      uid = Number(uid);
      gid = Number(gid);
      if (!isNaN(uid) && 0 <= uid && uid < 2 ** 32) {
        this.uid = this._convert(uid);
      }
      if (!isNaN(gid) && 0 <= gid && gid < 2 ** 32) {
        this.gid = this._convert(gid);
      }
    }
    get atimeNs() {
      return BigInt(this.atimeMs) * 1000n;
    }
    get mtimeNs() {
      return BigInt(this.mtimeMs) * 1000n;
    }
    get ctimeNs() {
      return BigInt(this.ctimeMs) * 1000n;
    }
    get birthtimeNs() {
      return BigInt(this.birthtimeMs) * 1000n;
    }
  };
  var Stats = class extends StatsCommon {
    constructor() {
      super(...arguments);
      this._isBigint = false;
    }
  };
  var BigIntStats = class extends StatsCommon {
    constructor() {
      super(...arguments);
      this._isBigint = true;
    }
  };
  var ZenFsType = 525687744115;
  var StatsFs = class {
    constructor() {
      this.type = 525687744115;
      this.bsize = 4096;
      this.blocks = 0;
      this.bfree = 0;
      this.bavail = 0;
      this.files = size_max;
      this.ffree = size_max;
    }
  };
  var BigIntStatsFs = class {
    constructor() {
      this.type = 0x7a656e6673n;
      this.bsize = 4096n;
      this.blocks = 0n;
      this.bfree = 0n;
      this.bavail = 0n;
      this.files = BigInt(size_max);
      this.ffree = BigInt(size_max);
    }
  };

  // node_modules/@zenfs/core/dist/inode.js
  var size_max = 2 ** 32 - 1;
  var rootIno = 0n;
  function _random() {
    return Math.round(Math.random() * 2 ** 32).toString(16);
  }
  function randomIno() {
    return BigInt("0x" + _random() + _random());
  }
  var Offset;
  (function(Offset2) {
    Offset2[Offset2["ino"] = 0] = "ino";
    Offset2[Offset2["size"] = 8] = "size";
    Offset2[Offset2["mode"] = 12] = "mode";
    Offset2[Offset2["nlink"] = 14] = "nlink";
    Offset2[Offset2["uid"] = 18] = "uid";
    Offset2[Offset2["gid"] = 22] = "gid";
    Offset2[Offset2["atime"] = 26] = "atime";
    Offset2[Offset2["birthtime"] = 34] = "birthtime";
    Offset2[Offset2["mtime"] = 42] = "mtime";
    Offset2[Offset2["ctime"] = 50] = "ctime";
    Offset2[Offset2["end"] = 58] = "end";
  })(Offset || (Offset = {}));
  var Inode = class {
    get data() {
      return new Uint8Array(this.buffer);
    }
    constructor(buffer2) {
      const setDefaults = !buffer2;
      buffer2 ?? (buffer2 = new ArrayBuffer(Offset.end));
      if (buffer2?.byteLength < Offset.end) {
        throw new RangeError(`Can not create an inode from a buffer less than ${Offset.end} bytes`);
      }
      this.view = new DataView(buffer2);
      this.buffer = buffer2;
      if (!setDefaults) {
        return;
      }
      this.ino = randomIno();
      this.nlink = 1;
      this.size = 4096;
      const now = Date.now();
      this.atimeMs = now;
      this.mtimeMs = now;
      this.ctimeMs = now;
      this.birthtimeMs = now;
    }
    get ino() {
      return this.view.getBigUint64(Offset.ino, true);
    }
    set ino(value) {
      this.view.setBigUint64(Offset.ino, value, true);
    }
    get size() {
      return this.view.getUint32(Offset.size, true);
    }
    set size(value) {
      this.view.setUint32(Offset.size, value, true);
    }
    get mode() {
      return this.view.getUint16(Offset.mode, true);
    }
    set mode(value) {
      this.view.setUint16(Offset.mode, value, true);
    }
    get nlink() {
      return this.view.getUint32(Offset.nlink, true);
    }
    set nlink(value) {
      this.view.setUint32(Offset.nlink, value, true);
    }
    get uid() {
      return this.view.getUint32(Offset.uid, true);
    }
    set uid(value) {
      this.view.setUint32(Offset.uid, value, true);
    }
    get gid() {
      return this.view.getUint32(Offset.gid, true);
    }
    set gid(value) {
      this.view.setUint32(Offset.gid, value, true);
    }
    get atimeMs() {
      return this.view.getFloat64(Offset.atime, true);
    }
    set atimeMs(value) {
      this.view.setFloat64(Offset.atime, value, true);
    }
    get birthtimeMs() {
      return this.view.getFloat64(Offset.birthtime, true);
    }
    set birthtimeMs(value) {
      this.view.setFloat64(Offset.birthtime, value, true);
    }
    get mtimeMs() {
      return this.view.getFloat64(Offset.mtime, true);
    }
    set mtimeMs(value) {
      this.view.setFloat64(Offset.mtime, value, true);
    }
    get ctimeMs() {
      return this.view.getFloat64(Offset.ctime, true);
    }
    set ctimeMs(value) {
      this.view.setFloat64(Offset.ctime, value, true);
    }
    /**
     * Handy function that converts the Inode to a Node Stats object.
     */
    toStats() {
      return new Stats(this);
    }
    /**
     * Updates the Inode using information from the stats object. Used by file
     * systems at sync time, e.g.:
     * - Program opens file and gets a File object.
     * - Program mutates file. File object is responsible for maintaining
     *   metadata changes locally -- typically in a Stats object.
     * - Program closes file. File object's metadata changes are synced with the
     *   file system.
     * @return True if any changes have occurred.
     */
    update(stats) {
      let hasChanged = false;
      if (this.size !== stats.size) {
        this.size = stats.size;
        hasChanged = true;
      }
      if (this.mode !== stats.mode) {
        this.mode = stats.mode;
        hasChanged = true;
      }
      if (this.nlink !== stats.nlink) {
        this.nlink = stats.nlink;
        hasChanged = true;
      }
      if (this.uid !== stats.uid) {
        this.uid = stats.uid;
        hasChanged = true;
      }
      if (this.uid !== stats.uid) {
        this.uid = stats.uid;
        hasChanged = true;
      }
      if (this.atimeMs !== stats.atimeMs) {
        this.atimeMs = stats.atimeMs;
        hasChanged = true;
      }
      if (this.mtimeMs !== stats.mtimeMs) {
        this.mtimeMs = stats.mtimeMs;
        hasChanged = true;
      }
      if (this.ctimeMs !== stats.ctimeMs) {
        this.ctimeMs = stats.ctimeMs;
        hasChanged = true;
      }
      return hasChanged;
    }
  };

  // node_modules/@zenfs/core/dist/symbol-dispose.js
  init_esbuild_shims();
  Symbol["dispose"] ?? (Symbol["dispose"] = Symbol("Symbol.dispose"));
  Symbol["asyncDispose"] ?? (Symbol["asyncDispose"] = Symbol("Symbol.asyncDispose"));

  // node_modules/@zenfs/core/dist/file.js
  var validFlags = ["r", "r+", "rs", "rs+", "w", "wx", "w+", "wx+", "a", "ax", "a+", "ax+"];
  function parseFlag(flag) {
    if (typeof flag === "number") {
      return flagToString(flag);
    }
    if (!validFlags.includes(flag)) {
      throw new Error("Invalid flag string: " + flag);
    }
    return flag;
  }
  function flagToString(flag) {
    switch (flag) {
      case O_RDONLY:
        return "r";
      case O_RDONLY | O_SYNC:
        return "rs";
      case O_RDWR:
        return "r+";
      case O_RDWR | O_SYNC:
        return "rs+";
      case O_TRUNC | O_CREAT | O_WRONLY:
        return "w";
      case O_TRUNC | O_CREAT | O_WRONLY | O_EXCL:
        return "wx";
      case O_TRUNC | O_CREAT | O_RDWR:
        return "w+";
      case O_TRUNC | O_CREAT | O_RDWR | O_EXCL:
        return "wx+";
      case O_APPEND | O_CREAT | O_WRONLY:
        return "a";
      case O_APPEND | O_CREAT | O_WRONLY | O_EXCL:
        return "ax";
      case O_APPEND | O_CREAT | O_RDWR:
        return "a+";
      case O_APPEND | O_CREAT | O_RDWR | O_EXCL:
        return "ax+";
      default:
        throw new Error("Invalid flag number: " + flag);
    }
  }
  function flagToMode(flag) {
    let mode = 0;
    mode <<= 1;
    mode += +isReadable(flag);
    mode <<= 1;
    mode += +isWriteable(flag);
    mode <<= 1;
    return mode;
  }
  function isReadable(flag) {
    return flag.indexOf("r") !== -1 || flag.indexOf("+") !== -1;
  }
  function isWriteable(flag) {
    return flag.indexOf("w") !== -1 || flag.indexOf("a") !== -1 || flag.indexOf("+") !== -1;
  }
  function isTruncating(flag) {
    return flag.indexOf("w") !== -1;
  }
  function isAppendable(flag) {
    return flag.indexOf("a") !== -1;
  }
  function isExclusive(flag) {
    return flag.indexOf("x") !== -1;
  }
  var File = class {
    [Symbol.asyncDispose]() {
      return this.close();
    }
    [Symbol.dispose]() {
      return this.closeSync();
    }
    /**
     * Asynchronous `datasync`.
     *
     * Default implementation maps to `sync`.
     */
    datasync() {
      return this.sync();
    }
    /**
     * Synchronous `datasync`.
     *
     * Default implementation maps to `syncSync`.
     */
    datasyncSync() {
      return this.syncSync();
    }
  };
  var PreloadFile = class extends File {
    /**
     * Creates a file with the given path and, optionally, the given contents. Note
     * that, if contents is specified, it will be mutated by the file!
     * @param _mode The mode that the file was opened using.
     *   Dictates permissions and where the file pointer starts.
     * @param stats The stats object for the given file.
     *   PreloadFile will mutate this object. Note that this object must contain
     *   the appropriate mode that the file was opened as.
     * @param buffer A buffer containing the entire
     *   contents of the file. PreloadFile will mutate this buffer. If not
     *   specified, we assume it is a new file.
     */
    constructor(fs, path, flag, stats, _buffer = new Uint8Array(new ArrayBuffer(0, fs.metadata().noResizableBuffers ? {} : { maxByteLength: size_max }))) {
      super();
      this.fs = fs;
      this.path = path;
      this.flag = flag;
      this.stats = stats;
      this._buffer = _buffer;
      this._position = 0;
      this.dirty = false;
      if (this.stats.size == _buffer.byteLength) {
        return;
      }
      if (isReadable(this.flag)) {
        throw new Error(`Size mismatch: buffer length ${_buffer.byteLength}, stats size ${this.stats.size}`);
      }
      this.dirty = true;
    }
    /**
     * Get the underlying buffer for this file. Mutating not recommended and will mess up dirty tracking.
     */
    get buffer() {
      return this._buffer;
    }
    /**
     * Get the current file position.
     *
     * We emulate the following bug mentioned in the Node documentation:
     * > On Linux, positional writes don't work when the file is opened in append
     *   mode. The kernel ignores the position argument and always appends the data
     *   to the end of the file.
     * @return The current file position.
     */
    get position() {
      if (isAppendable(this.flag)) {
        return this.stats.size;
      }
      return this._position;
    }
    /**
     * Set the file position.
     * @param newPos new position
     */
    set position(newPos) {
      this._position = newPos;
    }
    async sync() {
      if (!this.dirty) {
        return;
      }
      await this.fs.sync(this.path, this._buffer, this.stats);
      this.dirty = false;
    }
    syncSync() {
      if (!this.dirty) {
        return;
      }
      this.fs.syncSync(this.path, this._buffer, this.stats);
      this.dirty = false;
    }
    async close() {
      await this.sync();
    }
    closeSync() {
      this.syncSync();
    }
    /**
     * Asynchronous `stat`.
     */
    async stat() {
      return new Stats(this.stats);
    }
    /**
     * Synchronous `stat`.
     */
    statSync() {
      return new Stats(this.stats);
    }
    _truncate(length) {
      this.dirty = true;
      if (!isWriteable(this.flag)) {
        throw new ErrnoError(Errno.EPERM, "File not opened with a writeable mode.");
      }
      this.stats.mtimeMs = Date.now();
      if (length > this._buffer.length) {
        const data = new Uint8Array(length - this._buffer.length);
        this.writeSync(data, 0, data.length, this._buffer.length);
        return;
      }
      this.stats.size = length;
      this._buffer = this._buffer.slice(0, length);
    }
    /**
     * Asynchronous truncate.
     * @param length
     */
    async truncate(length) {
      this._truncate(length);
      await this.sync();
    }
    /**
     * Synchronous truncate.
     * @param length
     */
    truncateSync(length) {
      this._truncate(length);
      this.syncSync();
    }
    _write(buffer2, offset = 0, length = this.stats.size, position = this.position) {
      this.dirty = true;
      if (!isWriteable(this.flag)) {
        throw new ErrnoError(Errno.EPERM, "File not opened with a writeable mode.");
      }
      const end = position + length;
      if (end > this.stats.size) {
        this.stats.size = end;
        if (end > this._buffer.byteLength) {
          if (this._buffer.buffer.resizable && this._buffer.buffer.maxByteLength <= end) {
            this._buffer.buffer.resize(end);
          } else {
            const newBuffer = new Uint8Array(new ArrayBuffer(end, this.fs.metadata().noResizableBuffers ? {} : { maxByteLength: size_max }));
            newBuffer.set(this._buffer);
            this._buffer = newBuffer;
          }
        }
      }
      const slice = buffer2.slice(offset, offset + length);
      this._buffer.set(slice, position);
      this.stats.mtimeMs = Date.now();
      this.position = position + slice.byteLength;
      return slice.byteLength;
    }
    /**
     * Write buffer to the file.
     * Note that it is unsafe to use fs.write multiple times on the same file
     * without waiting for the callback.
     * @param buffer Uint8Array containing the data to write to
     *  the file.
     * @param offset Offset in the buffer to start reading data from.
     * @param length The amount of bytes to write to the file.
     * @param position Offset from the beginning of the file where this
     *   data should be written. If position is null, the data will be written at
     *   the current position.
     */
    async write(buffer2, offset, length, position) {
      const bytesWritten = this._write(buffer2, offset, length, position);
      await this.sync();
      return bytesWritten;
    }
    /**
     * Write buffer to the file.
     * Note that it is unsafe to use fs.writeSync multiple times on the same file
     * without waiting for the callback.
     * @param buffer Uint8Array containing the data to write to
     *  the file.
     * @param offset Offset in the buffer to start reading data from.
     * @param length The amount of bytes to write to the file.
     * @param position Offset from the beginning of the file where this
     *   data should be written. If position is null, the data will be written at
     *   the current position.
     * @returns bytes written
     */
    writeSync(buffer2, offset = 0, length = this.stats.size, position = this.position) {
      const bytesWritten = this._write(buffer2, offset, length, position);
      this.syncSync();
      return bytesWritten;
    }
    _read(buffer2, offset = 0, length = this.stats.size, position) {
      if (!isReadable(this.flag)) {
        throw new ErrnoError(Errno.EPERM, "File not opened with a readable mode.");
      }
      this.dirty = true;
      position ?? (position = this.position);
      let end = position + length;
      if (end > this.stats.size) {
        end = position + Math.max(this.stats.size - position, 0);
      }
      this.stats.atimeMs = Date.now();
      this._position = end;
      const bytesRead = end - position;
      if (bytesRead == 0) {
        return bytesRead;
      }
      new Uint8Array(buffer2.buffer, offset, length).set(this._buffer.slice(position, end));
      return bytesRead;
    }
    /**
     * Read data from the file.
     * @param buffer The buffer that the data will be
     *   written to.
     * @param offset The offset within the buffer where writing will
     *   start.
     * @param length An integer specifying the number of bytes to read.
     * @param position An integer specifying where to begin reading from
     *   in the file. If position is null, data will be read from the current file
     *   position.
     */
    async read(buffer2, offset, length, position) {
      const bytesRead = this._read(buffer2, offset, length, position);
      await this.sync();
      return { bytesRead, buffer: buffer2 };
    }
    /**
     * Read data from the file.
     * @param buffer The buffer that the data will be
     *   written to.
     * @param offset The offset within the buffer where writing will start.
     * @param length An integer specifying the number of bytes to read.
     * @param position An integer specifying where to begin reading from
     *   in the file. If position is null, data will be read from the current file
     *   position.
     * @returns number of bytes written
     */
    readSync(buffer2, offset, length, position) {
      const bytesRead = this._read(buffer2, offset, length, position);
      this.statSync();
      return bytesRead;
    }
    /**
     * Asynchronous `fchmod`.
     * @param mode the mode
     */
    async chmod(mode) {
      this.dirty = true;
      this.stats.chmod(mode);
      await this.sync();
    }
    /**
     * Synchronous `fchmod`.
     * @param mode
     */
    chmodSync(mode) {
      this.dirty = true;
      this.stats.chmod(mode);
      this.syncSync();
    }
    /**
     * Asynchronous `fchown`.
     * @param uid
     * @param gid
     */
    async chown(uid, gid) {
      this.dirty = true;
      this.stats.chown(uid, gid);
      await this.sync();
    }
    /**
     * Synchronous `fchown`.
     * @param uid
     * @param gid
     */
    chownSync(uid, gid) {
      this.dirty = true;
      this.stats.chown(uid, gid);
      this.syncSync();
    }
    async utimes(atime, mtime) {
      this.dirty = true;
      this.stats.atime = atime;
      this.stats.mtime = mtime;
      await this.sync();
    }
    utimesSync(atime, mtime) {
      this.dirty = true;
      this.stats.atime = atime;
      this.stats.mtime = mtime;
      this.syncSync();
    }
    async _setType(type) {
      this.dirty = true;
      this.stats.mode = this.stats.mode & ~S_IFMT | type;
      await this.sync();
    }
    _setTypeSync(type) {
      this.dirty = true;
      this.stats.mode = this.stats.mode & ~S_IFMT | type;
      this.syncSync();
    }
  };
  var NoSyncFile = class extends PreloadFile {
    constructor(fs, path, flag, stats, contents) {
      super(fs, path, flag, stats, contents);
    }
    /**
     * Asynchronous sync. Doesn't do anything, simply calls the cb.
     */
    async sync() {
      return;
    }
    /**
     * Synchronous sync. Doesn't do anything.
     */
    syncSync() {
    }
    /**
     * Asynchronous close. Doesn't do anything, simply calls the cb.
     */
    async close() {
      return;
    }
    /**
     * Synchronous close. Doesn't do anything.
     */
    closeSync() {
    }
  };

  // node_modules/@zenfs/core/dist/filesystem.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/cred.js
  init_esbuild_shims();
  var rootCred = {
    uid: 0,
    gid: 0,
    suid: 0,
    sgid: 0,
    euid: 0,
    egid: 0
  };

  // node_modules/@zenfs/core/dist/emulation/path.js
  init_esbuild_shims();
  var cwd = "/";
  function normalizeString(path, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let char = "\0";
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        char = path[i];
      } else if (char == "/") {
        break;
      } else {
        char = "/";
      }
      if (char == "/") {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.at(-1) !== "." || res.at(-2) !== ".") {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path.slice(lastSlash + 1, i);
          else
            res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (char === "." && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function resolve(...parts) {
    let resolved = "";
    for (const part of [...parts.reverse(), cwd]) {
      if (!part.length) {
        continue;
      }
      resolved = `${part}/${resolved}`;
      if (part.startsWith("/")) {
        break;
      }
    }
    const absolute = resolved.startsWith("/");
    resolved = normalizeString(resolved, !absolute);
    if (absolute) {
      return `/${resolved}`;
    }
    return resolved.length ? resolved : "/";
  }
  function normalize(path) {
    if (!path.length)
      return ".";
    const isAbsolute = path.startsWith("/");
    const trailingSeparator = path.endsWith("/");
    path = normalizeString(path, !isAbsolute);
    if (!path.length) {
      if (isAbsolute)
        return "/";
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator)
      path += "/";
    return isAbsolute ? `/${path}` : path;
  }
  function join(...parts) {
    if (!parts.length)
      return ".";
    const joined = parts.join("/");
    if (!joined?.length)
      return ".";
    return normalize(joined);
  }
  function dirname(path) {
    if (path.length === 0)
      return ".";
    const hasRoot = path[0] === "/";
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path[i] === "/") {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end === 1)
      return "//";
    return path.slice(0, end);
  }
  function basename(path, suffix) {
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return "";
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        if (path[i] === "/") {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (path[i] === suffix[extIdx]) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return path.slice(start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (path[i] === "/") {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path.slice(start, end);
  }
  function parse(path) {
    const isAbsolute = path.startsWith("/");
    const ret = { root: isAbsolute ? "/" : "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0)
      return ret;
    const start = isAbsolute ? 1 : 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      if (path[i] === "/") {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (path[i] === ".") {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start2, end);
      } else {
        ret.name = path.slice(start2, startDot);
        ret.base = path.slice(start2, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = "/";
    return ret;
  }

  // node_modules/@zenfs/core/dist/filesystem.js
  var __addDisposableResource = function(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e2) {
        env.error = env.hasError ? new SuppressedError2(e2, env.error, "An error was suppressed during disposal.") : e2;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async) return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } catch (e2) {
            fail(e2);
          }
        }
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  });
  var FileSystem = class {
    /**
     * Get metadata about the current file system
     */
    metadata() {
      return {
        name: this.constructor.name.toLowerCase(),
        readonly: false,
        totalSpace: 0,
        freeSpace: 0,
        noResizableBuffers: false,
        noAsyncCache: this._disableSync ?? false,
        type: ZenFsType
      };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
    constructor(...args) {
    }
    async ready() {
    }
    /**
     * Test whether or not the given path exists by checking with the file system.
     */
    async exists(path, cred2) {
      try {
        await this.stat(path, cred2);
        return true;
      } catch (e2) {
        return e2.code != "ENOENT";
      }
    }
    /**
     * Test whether or not the given path exists by checking with the file system.
     */
    existsSync(path, cred2) {
      try {
        this.statSync(path, cred2);
        return true;
      } catch (e2) {
        return e2.code != "ENOENT";
      }
    }
  };
  function Async(FS) {
    class AsyncFS extends FS {
      constructor() {
        super(...arguments);
        this._queue = [];
        this._isInitialized = false;
      }
      get _queueRunning() {
        return !!this._queue.length;
      }
      queueDone() {
        return new Promise((resolve2) => {
          const check = () => this._queueRunning ? setTimeout(check) : resolve2();
          check();
        });
      }
      async ready() {
        await super.ready();
        if (this._isInitialized || this._disableSync) {
          return;
        }
        this.checkSync();
        await this._sync.ready();
        try {
          await this.crossCopy("/");
          this._isInitialized = true;
        } catch (e2) {
          this._isInitialized = false;
          throw e2;
        }
      }
      checkSync(path, syscall) {
        if (this._disableSync) {
          throw new ErrnoError(Errno.ENOTSUP, "Sync caching has been disabled for this async file system", path, syscall);
        }
        if (!this._sync) {
          throw new ErrnoError(Errno.ENOTSUP, "No sync cache is attached to this async file system", path, syscall);
        }
      }
      renameSync(oldPath, newPath, cred2) {
        this.checkSync(oldPath, "rename");
        this._sync.renameSync(oldPath, newPath, cred2);
        this.queue("rename", oldPath, newPath, cred2);
      }
      statSync(path, cred2) {
        this.checkSync(path, "stat");
        return this._sync.statSync(path, cred2);
      }
      createFileSync(path, flag, mode, cred2) {
        this.checkSync(path, "createFile");
        this._sync.createFileSync(path, flag, mode, cred2);
        this.queue("createFile", path, flag, mode, cred2);
        return this.openFileSync(path, flag, cred2);
      }
      openFileSync(path, flag, cred2) {
        this.checkSync(path, "openFile");
        const file = this._sync.openFileSync(path, flag, cred2);
        const stats = file.statSync();
        const buffer2 = new Uint8Array(stats.size);
        file.readSync(buffer2);
        return new PreloadFile(this, path, flag, stats, buffer2);
      }
      unlinkSync(path, cred2) {
        this.checkSync(path, "unlinkSync");
        this._sync.unlinkSync(path, cred2);
        this.queue("unlink", path, cred2);
      }
      rmdirSync(path, cred2) {
        this.checkSync(path, "rmdir");
        this._sync.rmdirSync(path, cred2);
        this.queue("rmdir", path, cred2);
      }
      mkdirSync(path, mode, cred2) {
        this.checkSync(path, "mkdir");
        this._sync.mkdirSync(path, mode, cred2);
        this.queue("mkdir", path, mode, cred2);
      }
      readdirSync(path, cred2) {
        this.checkSync(path, "readdir");
        return this._sync.readdirSync(path, cred2);
      }
      linkSync(srcpath, dstpath, cred2) {
        this.checkSync(srcpath, "link");
        this._sync.linkSync(srcpath, dstpath, cred2);
        this.queue("link", srcpath, dstpath, cred2);
      }
      syncSync(path, data, stats) {
        this.checkSync(path, "sync");
        this._sync.syncSync(path, data, stats);
        this.queue("sync", path, data, stats);
      }
      existsSync(path, cred2) {
        this.checkSync(path, "exists");
        return this._sync.existsSync(path, cred2);
      }
      /**
       * @internal
       */
      async crossCopy(path) {
        this.checkSync(path, "crossCopy");
        const stats = await this.stat(path, rootCred);
        if (stats.isDirectory()) {
          if (path !== "/") {
            const stats2 = await this.stat(path, rootCred);
            this._sync.mkdirSync(path, stats2.mode, stats2.cred());
          }
          const files = await this.readdir(path, rootCred);
          for (const file of files) {
            await this.crossCopy(join(path, file));
          }
        } else {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const asyncFile = __addDisposableResource(env_1, await this.openFile(path, parseFlag("r"), rootCred), true);
            const syncFile = __addDisposableResource(env_1, this._sync.createFileSync(path, parseFlag("w"), stats.mode, stats.cred()), false);
            const buffer2 = new Uint8Array(stats.size);
            await asyncFile.read(buffer2);
            syncFile.writeSync(buffer2, 0, stats.size);
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
              await result_1;
          }
        }
      }
      /**
       * @internal
       */
      async _next() {
        if (!this._queueRunning) {
          return;
        }
        const [method, ...args] = this._queue.shift();
        await this[method](...args);
        await this._next();
      }
      /**
       * @internal
       */
      queue(...op) {
        this._queue.push(op);
        this._next();
      }
    }
    return AsyncFS;
  }
  function Readonly(FS) {
    class ReadonlyFS extends FS {
      metadata() {
        return { ...super.metadata(), readonly: true };
      }
      /* eslint-disable @typescript-eslint/no-unused-vars */
      async rename(oldPath, newPath, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      renameSync(oldPath, newPath, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async createFile(path, flag, mode, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      createFileSync(path, flag, mode, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async unlink(path, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      unlinkSync(path, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async rmdir(path, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      rmdirSync(path, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async mkdir(path, mode, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      mkdirSync(path, mode, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async link(srcpath, dstpath, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      linkSync(srcpath, dstpath, cred2) {
        throw new ErrnoError(Errno.EROFS);
      }
      async sync(path, data, stats) {
        throw new ErrnoError(Errno.EROFS);
      }
      syncSync(path, data, stats) {
        throw new ErrnoError(Errno.EROFS);
      }
    }
    return ReadonlyFS;
  }

  // node_modules/@zenfs/core/dist/backends/memory.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/store/fs.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/utils.js
  init_esbuild_shims();
  var setImmediate2 = typeof globalThis.setImmediate == "function" ? globalThis.setImmediate : (cb) => setTimeout(cb, 0);
  function encode(input) {
    if (typeof input != "string") {
      throw new ErrnoError(Errno.EINVAL, "Can not encode a non-string");
    }
    return new Uint8Array(Array.from(input).map((char) => char.charCodeAt(0)));
  }
  function decode(input) {
    if (!(input instanceof Uint8Array)) {
      throw new ErrnoError(Errno.EINVAL, "Can not decode a non-Uint8Array");
    }
    return Array.from(input).map((char) => String.fromCharCode(char)).join("");
  }
  function decodeDirListing(data) {
    return JSON.parse(decode(data), (k, v) => {
      if (k == "") {
        return v;
      }
      return BigInt(v);
    });
  }
  function encodeDirListing(data) {
    return encode(JSON.stringify(data, (k, v) => {
      if (k == "") {
        return v;
      }
      return v.toString();
    }));
  }
  function normalizeMode(mode, def) {
    if (typeof mode == "number") {
      return mode;
    }
    if (typeof mode == "string") {
      const parsed = parseInt(mode, 8);
      if (!isNaN(parsed)) {
        return parsed;
      }
    }
    if (typeof def == "number") {
      return def;
    }
    throw new ErrnoError(Errno.EINVAL, "Invalid mode: " + mode?.toString());
  }
  function normalizeTime(time) {
    if (time instanceof Date) {
      return time;
    }
    if (typeof time == "number") {
      return new Date(time * 1e3);
    }
    if (typeof time == "string") {
      return new Date(time);
    }
    throw new ErrnoError(Errno.EINVAL, "Invalid time.");
  }
  function normalizePath(p) {
    p = p.toString();
    if (p.includes("\0")) {
      throw new ErrnoError(Errno.EINVAL, "Path can not contain null character");
    }
    if (p.length == 0) {
      throw new ErrnoError(Errno.EINVAL, "Path can not be empty");
    }
    return resolve(p.replaceAll(/[/\\]+/g, "/"));
  }
  function normalizeOptions(options, encoding = "utf8", flag, mode = 0) {
    if (typeof options != "object" || options === null) {
      return {
        encoding: typeof options == "string" ? options : encoding ?? null,
        flag,
        mode
      };
    }
    return {
      encoding: typeof options?.encoding == "string" ? options.encoding : encoding ?? null,
      flag: typeof options?.flag == "string" ? options.flag : flag,
      mode: normalizeMode("mode" in options ? options?.mode : null, mode)
    };
  }
  function nop() {
  }

  // node_modules/@zenfs/core/dist/backends/store/fs.js
  var maxInodeAllocTries = 5;
  var StoreFS = class extends FileSystem {
    async ready() {
      if (this._initialized) {
        return;
      }
      await this.checkRoot();
      this._initialized = true;
    }
    constructor(store) {
      super();
      this.store = store;
      this._initialized = false;
    }
    metadata() {
      return {
        ...super.metadata(),
        name: this.store.name
      };
    }
    /**
     * Delete all contents stored in the file system.
     * @deprecated
     */
    async empty() {
      await this.store.clear();
      await this.checkRoot();
    }
    /**
     * Delete all contents stored in the file system.
     * @deprecated
     */
    emptySync() {
      this.store.clearSync();
      this.checkRootSync();
    }
    /**
     * @todo Make rename compatible with the cache.
     */
    async rename(oldPath, newPath, cred2) {
      const tx = this.store.transaction(), oldParent = dirname(oldPath), oldName = basename(oldPath), newParent = dirname(newPath), newName = basename(newPath), oldDirNode = await this.findINode(tx, oldParent), oldDirList = await this.getDirListing(tx, oldDirNode, oldParent);
      if (!oldDirNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", oldPath, "rename");
      }
      if (!oldDirList[oldName]) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
      const nodeId = oldDirList[oldName];
      delete oldDirList[oldName];
      if ((newParent + "/").indexOf(oldPath + "/") === 0) {
        throw new ErrnoError(Errno.EBUSY, oldParent);
      }
      let newDirNode, newDirList;
      if (newParent === oldParent) {
        newDirNode = oldDirNode;
        newDirList = oldDirList;
      } else {
        newDirNode = await this.findINode(tx, newParent);
        newDirList = await this.getDirListing(tx, newDirNode, newParent);
      }
      if (newDirList[newName]) {
        const newNameNode = await this.getINode(tx, newDirList[newName], newPath);
        if (newNameNode.toStats().isFile()) {
          try {
            await tx.remove(newNameNode.ino);
            await tx.remove(newDirList[newName]);
          } catch (e2) {
            await tx.abort();
            throw e2;
          }
        } else {
          throw ErrnoError.With("EPERM", newPath, "rename");
        }
      }
      newDirList[newName] = nodeId;
      try {
        await tx.set(oldDirNode.ino, encodeDirListing(oldDirList));
        await tx.set(newDirNode.ino, encodeDirListing(newDirList));
      } catch (e2) {
        await tx.abort();
        throw e2;
      }
      await tx.commit();
    }
    renameSync(oldPath, newPath, cred2) {
      const tx = this.store.transaction(), oldParent = dirname(oldPath), oldName = basename(oldPath), newParent = dirname(newPath), newName = basename(newPath), oldDirNode = this.findINodeSync(tx, oldParent), oldDirList = this.getDirListingSync(tx, oldDirNode, oldParent);
      if (!oldDirNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", oldPath, "rename");
      }
      if (!oldDirList[oldName]) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
      const ino = oldDirList[oldName];
      delete oldDirList[oldName];
      if ((newParent + "/").indexOf(oldPath + "/") == 0) {
        throw new ErrnoError(Errno.EBUSY, oldParent);
      }
      let newDirNode, newDirList;
      if (newParent === oldParent) {
        newDirNode = oldDirNode;
        newDirList = oldDirList;
      } else {
        newDirNode = this.findINodeSync(tx, newParent);
        newDirList = this.getDirListingSync(tx, newDirNode, newParent);
      }
      if (newDirList[newName]) {
        const newNameNode = this.getINodeSync(tx, newDirList[newName], newPath);
        if (newNameNode.toStats().isFile()) {
          try {
            tx.removeSync(newNameNode.ino);
            tx.removeSync(newDirList[newName]);
          } catch (e2) {
            tx.abortSync();
            throw e2;
          }
        } else {
          throw ErrnoError.With("EPERM", newPath, "rename");
        }
      }
      newDirList[newName] = ino;
      try {
        tx.setSync(oldDirNode.ino, encodeDirListing(oldDirList));
        tx.setSync(newDirNode.ino, encodeDirListing(newDirList));
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
    }
    async stat(path, cred2) {
      const tx = this.store.transaction();
      const inode = await this.findINode(tx, path);
      if (!inode) {
        throw ErrnoError.With("ENOENT", path, "stat");
      }
      const stats = inode.toStats();
      if (!stats.hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "stat");
      }
      return stats;
    }
    statSync(path, cred2) {
      const stats = this.findINodeSync(this.store.transaction(), path).toStats();
      if (!stats.hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "stat");
      }
      return stats;
    }
    async createFile(path, flag, mode, cred2) {
      const data = new Uint8Array(0);
      const file = await this.commitNew(this.store.transaction(), path, FileType.FILE, mode, cred2, data);
      return new PreloadFile(this, path, flag, file.toStats(), data);
    }
    createFileSync(path, flag, mode, cred2) {
      this.commitNewSync(path, FileType.FILE, mode, cred2);
      return this.openFileSync(path, flag, cred2);
    }
    async openFile(path, flag, cred2) {
      const tx = this.store.transaction(), node = await this.findINode(tx, path), data = await tx.get(node.ino);
      if (!node.toStats().hasAccess(flagToMode(flag), cred2)) {
        throw ErrnoError.With("EACCES", path, "openFile");
      }
      if (!data) {
        throw ErrnoError.With("ENOENT", path, "openFile");
      }
      return new PreloadFile(this, path, flag, node.toStats(), data);
    }
    openFileSync(path, flag, cred2) {
      const tx = this.store.transaction(), node = this.findINodeSync(tx, path), data = tx.getSync(node.ino);
      if (!node.toStats().hasAccess(flagToMode(flag), cred2)) {
        throw ErrnoError.With("EACCES", path, "openFile");
      }
      if (!data) {
        throw ErrnoError.With("ENOENT", path, "openFile");
      }
      return new PreloadFile(this, path, flag, node.toStats(), data);
    }
    async unlink(path, cred2) {
      return this.remove(path, false, cred2);
    }
    unlinkSync(path, cred2) {
      this.removeSync(path, false, cred2);
    }
    async rmdir(path, cred2) {
      const list = await this.readdir(path, cred2);
      if (list.length > 0) {
        throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
      }
      await this.remove(path, true, cred2);
    }
    rmdirSync(path, cred2) {
      if (this.readdirSync(path, cred2).length > 0) {
        throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
      } else {
        this.removeSync(path, true, cred2);
      }
    }
    async mkdir(path, mode, cred2) {
      const tx = this.store.transaction(), data = encode("{}");
      await this.commitNew(tx, path, FileType.DIRECTORY, mode, cred2, data);
    }
    mkdirSync(path, mode, cred2) {
      this.commitNewSync(path, FileType.DIRECTORY, mode, cred2, encode("{}"));
    }
    async readdir(path, cred2) {
      const tx = this.store.transaction();
      const node = await this.findINode(tx, path);
      if (!node.toStats().hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "readdur");
      }
      return Object.keys(await this.getDirListing(tx, node, path));
    }
    readdirSync(path, cred2) {
      const tx = this.store.transaction();
      const node = this.findINodeSync(tx, path);
      if (!node.toStats().hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "readdir");
      }
      return Object.keys(this.getDirListingSync(tx, node, path));
    }
    /**
     * Updated the inode and data node at the given path
     * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
     */
    async sync(path, data, stats) {
      const tx = this.store.transaction(), fileInodeId = await this._findINode(tx, dirname(path), basename(path)), fileInode = await this.getINode(tx, fileInodeId, path), inodeChanged = fileInode.update(stats);
      try {
        await tx.set(fileInode.ino, data);
        if (inodeChanged) {
          await tx.set(fileInodeId, fileInode.data);
        }
      } catch (e2) {
        await tx.abort();
        throw e2;
      }
      await tx.commit();
    }
    /**
     * Updated the inode and data node at the given path
     * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
     */
    syncSync(path, data, stats) {
      const tx = this.store.transaction(), fileInodeId = this._findINodeSync(tx, dirname(path), basename(path)), fileInode = this.getINodeSync(tx, fileInodeId, path), inodeChanged = fileInode.update(stats);
      try {
        tx.setSync(fileInode.ino, data);
        if (inodeChanged) {
          tx.setSync(fileInodeId, fileInode.data);
        }
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
    }
    async link(existing, newpath, cred2) {
      const tx = this.store.transaction(), existingDir = dirname(existing), existingDirNode = await this.findINode(tx, existingDir);
      if (!existingDirNode.toStats().hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", existingDir, "link");
      }
      const newDir = dirname(newpath), newDirNode = await this.findINode(tx, newDir), newListing = await this.getDirListing(tx, newDirNode, newDir);
      if (!newDirNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", newDir, "link");
      }
      const ino = await this._findINode(tx, existingDir, basename(existing));
      const node = await this.getINode(tx, ino, existing);
      if (!node.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", newpath, "link");
      }
      node.nlink++;
      newListing[basename(newpath)] = ino;
      try {
        tx.setSync(ino, node.data);
        tx.setSync(newDirNode.ino, encodeDirListing(newListing));
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
    }
    linkSync(existing, newpath, cred2) {
      const tx = this.store.transaction(), existingDir = dirname(existing), existingDirNode = this.findINodeSync(tx, existingDir);
      if (!existingDirNode.toStats().hasAccess(R_OK, cred2)) {
        throw ErrnoError.With("EACCES", existingDir, "link");
      }
      const newDir = dirname(newpath), newDirNode = this.findINodeSync(tx, newDir), newListing = this.getDirListingSync(tx, newDirNode, newDir);
      if (!newDirNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", newDir, "link");
      }
      const ino = this._findINodeSync(tx, existingDir, basename(existing));
      const node = this.getINodeSync(tx, ino, existing);
      if (!node.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", newpath, "link");
      }
      node.nlink++;
      newListing[basename(newpath)] = ino;
      try {
        tx.setSync(ino, node.data);
        tx.setSync(newDirNode.ino, encodeDirListing(newListing));
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
    }
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    async checkRoot() {
      const tx = this.store.transaction();
      if (await tx.get(rootIno)) {
        return;
      }
      const inode = new Inode();
      inode.mode = 511 | FileType.DIRECTORY;
      await tx.set(inode.ino, encode("{}"));
      await tx.set(rootIno, inode.data);
      await tx.commit();
    }
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    checkRootSync() {
      const tx = this.store.transaction();
      if (tx.getSync(rootIno)) {
        return;
      }
      const inode = new Inode();
      inode.mode = 511 | FileType.DIRECTORY;
      tx.setSync(inode.ino, encode("{}"));
      tx.setSync(rootIno, inode.data);
      tx.commitSync();
    }
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     */
    async _findINode(tx, parent, filename, visited = /* @__PURE__ */ new Set()) {
      const currentPath = join(parent, filename);
      if (visited.has(currentPath)) {
        throw new ErrnoError(Errno.EIO, "Infinite loop detected while finding inode", currentPath);
      }
      visited.add(currentPath);
      if (parent == "/" && filename === "") {
        return rootIno;
      }
      const inode = parent == "/" ? await this.getINode(tx, rootIno, parent) : await this.findINode(tx, parent, visited);
      const dirList = await this.getDirListing(tx, inode, parent);
      if (!(filename in dirList)) {
        throw ErrnoError.With("ENOENT", resolve(parent, filename), "_findINode");
      }
      return dirList[filename];
    }
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     * @return string The ID of the file's inode in the file system.
     */
    _findINodeSync(tx, parent, filename, visited = /* @__PURE__ */ new Set()) {
      const currentPath = join(parent, filename);
      if (visited.has(currentPath)) {
        throw new ErrnoError(Errno.EIO, "Infinite loop detected while finding inode", currentPath);
      }
      visited.add(currentPath);
      if (parent == "/" && filename === "") {
        return rootIno;
      }
      const inode = parent == "/" ? this.getINodeSync(tx, rootIno, parent) : this.findINodeSync(tx, parent, visited);
      const dir = this.getDirListingSync(tx, inode, parent);
      if (!(filename in dir)) {
        throw ErrnoError.With("ENOENT", resolve(parent, filename), "_findINode");
      }
      return dir[filename];
    }
    /**
     * Finds the Inode of the given path.
     * @param path The path to look up.
     * @todo memoize/cache
     */
    async findINode(tx, path, visited = /* @__PURE__ */ new Set()) {
      const id = await this._findINode(tx, dirname(path), basename(path), visited);
      return this.getINode(tx, id, path);
    }
    /**
     * Finds the Inode of the given path.
     * @param path The path to look up.
     * @return The Inode of the path p.
     * @todo memoize/cache
     */
    findINodeSync(tx, path, visited = /* @__PURE__ */ new Set()) {
      const ino = this._findINodeSync(tx, dirname(path), basename(path), visited);
      return this.getINodeSync(tx, ino, path);
    }
    /**
     * Given the ID of a node, retrieves the corresponding Inode.
     * @param tx The transaction to use.
     * @param path The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     */
    async getINode(tx, id, path) {
      const data = await tx.get(id);
      if (!data) {
        throw ErrnoError.With("ENOENT", path, "getINode");
      }
      return new Inode(data.buffer);
    }
    /**
     * Given the ID of a node, retrieves the corresponding Inode.
     * @param tx The transaction to use.
     * @param path The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     */
    getINodeSync(tx, id, path) {
      const data = tx.getSync(id);
      if (!data) {
        throw ErrnoError.With("ENOENT", path, "getINode");
      }
      const inode = new Inode(data.buffer);
      return inode;
    }
    /**
     * Given the Inode of a directory, retrieves the corresponding directory
     * listing.
     */
    async getDirListing(tx, inode, path) {
      if (!inode.toStats().isDirectory()) {
        throw ErrnoError.With("ENOTDIR", path, "getDirListing");
      }
      const data = await tx.get(inode.ino);
      if (!data) {
        throw ErrnoError.With("ENOENT", path, "getDirListing");
      }
      return decodeDirListing(data);
    }
    /**
     * Given the Inode of a directory, retrieves the corresponding directory listing.
     */
    getDirListingSync(tx, inode, p) {
      if (!inode.toStats().isDirectory()) {
        throw ErrnoError.With("ENOTDIR", p, "getDirListing");
      }
      const data = tx.getSync(inode.ino);
      if (!data) {
        throw ErrnoError.With("ENOENT", p, "getDirListing");
      }
      return decodeDirListing(data);
    }
    /**
     * Adds a new node under a random ID. Retries before giving up in
     * the exceedingly unlikely chance that we try to reuse a random ino.
     */
    async addNew(tx, data, path) {
      for (let i = 0; i < maxInodeAllocTries; i++) {
        const ino = randomIno();
        if (await tx.get(ino)) {
          continue;
        }
        await tx.set(ino, data);
        return ino;
      }
      throw new ErrnoError(Errno.ENOSPC, "No inode IDs available", path, "addNewNode");
    }
    /**
     * Creates a new node under a random ID. Retries before giving up in
     * the exceedingly unlikely chance that we try to reuse a random ino.
     * @return The ino that the data was stored under.
     */
    addNewSync(tx, data, path) {
      for (let i = 0; i < maxInodeAllocTries; i++) {
        const ino = randomIno();
        if (tx.getSync(ino)) {
          continue;
        }
        tx.setSync(ino, data);
        return ino;
      }
      throw new ErrnoError(Errno.ENOSPC, "No inode IDs available", path, "addNewNode");
    }
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
     * the given mode.
     * Note: This will commit the transaction.
     * @param path The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param cred The UID/GID to create the file with
     * @param data The data to store at the file's data node.
     */
    async commitNew(tx, path, type, mode, cred2, data) {
      const parentPath = dirname(path), parent = await this.findINode(tx, parentPath);
      if (!parent.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "commitNewFile");
      }
      const fname = basename(path), listing = await this.getDirListing(tx, parent, parentPath);
      if (path === "/") {
        throw ErrnoError.With("EEXIST", path, "commitNewFile");
      }
      if (listing[fname]) {
        await tx.abort();
        throw ErrnoError.With("EEXIST", path, "commitNewFile");
      }
      try {
        const inode = new Inode();
        inode.ino = await this.addNew(tx, data, path);
        inode.mode = mode | type;
        inode.uid = cred2.uid;
        inode.gid = cred2.gid;
        inode.size = data.length;
        listing[fname] = await this.addNew(tx, inode.data, path);
        await tx.set(parent.ino, encodeDirListing(listing));
        await tx.commit();
        return inode;
      } catch (e2) {
        tx.abort();
        throw e2;
      }
    }
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with the given mode.
     * Note: This will commit the transaction.
     * @param path The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param data The data to store at the file's data node.
     * @return The Inode for the new file.
     */
    commitNewSync(path, type, mode, cred2, data = new Uint8Array()) {
      const tx = this.store.transaction(), parentPath = dirname(path), parent = this.findINodeSync(tx, parentPath);
      if (!parent.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "commitNewFile");
      }
      const fname = basename(path), listing = this.getDirListingSync(tx, parent, parentPath);
      if (path === "/") {
        throw ErrnoError.With("EEXIST", path, "commitNewFile");
      }
      if (listing[fname]) {
        throw ErrnoError.With("EEXIST", path, "commitNewFile");
      }
      const node = new Inode();
      try {
        node.ino = this.addNewSync(tx, data, path);
        node.size = data.length;
        node.mode = mode | type;
        node.uid = cred2.uid;
        node.gid = cred2.gid;
        listing[fname] = this.addNewSync(tx, node.data, path);
        tx.setSync(parent.ino, encodeDirListing(listing));
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
      return node;
    }
    /**
     * Remove all traces of the given path from the file system.
     * @param path The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    async remove(path, isDir, cred2) {
      const tx = this.store.transaction(), parent = dirname(path), parentNode = await this.findINode(tx, parent), listing = await this.getDirListing(tx, parentNode, parent), fileName = basename(path);
      if (!listing[fileName]) {
        throw ErrnoError.With("ENOENT", path, "removeEntry");
      }
      const fileIno = listing[fileName];
      const fileNode = await this.getINode(tx, fileIno, path);
      if (!fileNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "removeEntry");
      }
      delete listing[fileName];
      if (!isDir && fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("EISDIR", path, "removeEntry");
      }
      if (isDir && !fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("ENOTDIR", path, "removeEntry");
      }
      try {
        await tx.set(parentNode.ino, encodeDirListing(listing));
        if (--fileNode.nlink < 1) {
          await tx.remove(fileNode.ino);
          await tx.remove(fileIno);
        }
      } catch (e2) {
        await tx.abort();
        throw e2;
      }
      await tx.commit();
    }
    /**
     * Remove all traces of the given path from the file system.
     * @param path The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    removeSync(path, isDir, cred2) {
      const tx = this.store.transaction(), parent = dirname(path), parentNode = this.findINodeSync(tx, parent), listing = this.getDirListingSync(tx, parentNode, parent), fileName = basename(path), fileIno = listing[fileName];
      if (!fileIno) {
        throw ErrnoError.With("ENOENT", path, "removeEntry");
      }
      const fileNode = this.getINodeSync(tx, fileIno, path);
      if (!fileNode.toStats().hasAccess(W_OK, cred2)) {
        throw ErrnoError.With("EACCES", path, "removeEntry");
      }
      delete listing[fileName];
      if (!isDir && fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("EISDIR", path, "removeEntry");
      }
      if (isDir && !fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("ENOTDIR", path, "removeEntry");
      }
      try {
        tx.setSync(parentNode.ino, encodeDirListing(listing));
        if (--fileNode.nlink < 1) {
          tx.removeSync(fileNode.ino);
          tx.removeSync(fileIno);
        }
      } catch (e2) {
        tx.abortSync();
        throw e2;
      }
      tx.commitSync();
    }
  };

  // node_modules/@zenfs/core/dist/backends/store/simple.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/store/store.js
  init_esbuild_shims();
  var Transaction = class {
    constructor(store) {
      this.store = store;
      this.aborted = false;
    }
    async [Symbol.asyncDispose]() {
      if (this.aborted) {
        return;
      }
      await this.commit();
    }
    [Symbol.dispose]() {
      if (this.aborted) {
        return;
      }
      this.commitSync();
    }
  };
  var SyncTransaction = class extends Transaction {
    async get(ino) {
      return this.getSync(ino);
    }
    async set(ino, data) {
      return this.setSync(ino, data);
    }
    async remove(ino) {
      return this.removeSync(ino);
    }
    async commit() {
      return this.commitSync();
    }
    async abort() {
      return this.abortSync();
    }
  };

  // node_modules/@zenfs/core/dist/backends/store/simple.js
  var SimpleTransaction = class extends SyncTransaction {
    constructor(store) {
      super(store);
      this.originalData = /* @__PURE__ */ new Map();
      this.modifiedKeys = /* @__PURE__ */ new Set();
    }
    getSync(ino) {
      const val2 = this.store.get(ino);
      this.stashOldValue(ino, val2);
      return val2;
    }
    setSync(ino, data) {
      this.markModified(ino);
      return this.store.set(ino, data);
    }
    removeSync(ino) {
      this.markModified(ino);
      this.store.delete(ino);
    }
    commitSync() {
    }
    abortSync() {
      for (const key of this.modifiedKeys) {
        const value = this.originalData.get(key);
        if (!value) {
          this.store.delete(key);
        } else {
          this.store.set(key, value);
        }
      }
    }
    /**
     * Stashes given key value pair into `originalData` if it doesn't already
     * exist. Allows us to stash values the program is requesting anyway to
     * prevent needless `get` requests if the program modifies the data later
     * on during the transaction.
     */
    stashOldValue(ino, value) {
      if (!this.originalData.has(ino)) {
        this.originalData.set(ino, value);
      }
    }
    /**
     * Marks the given key as modified, and stashes its value if it has not been
     * stashed already.
     */
    markModified(ino) {
      this.modifiedKeys.add(ino);
      if (!this.originalData.has(ino)) {
        this.originalData.set(ino, this.store.get(ino));
      }
    }
  };

  // node_modules/@zenfs/core/dist/backends/memory.js
  var InMemoryStore = class extends Map {
    constructor(name = "tmp") {
      super();
      this.name = name;
    }
    async sync() {
    }
    clearSync() {
      this.clear();
    }
    transaction() {
      return new SimpleTransaction(this);
    }
  };
  var InMemory = {
    name: "InMemory",
    isAvailable() {
      return true;
    },
    options: {
      name: {
        type: "string",
        required: false,
        description: "The name of the store"
      }
    },
    create({ name }) {
      const fs = new StoreFS(new InMemoryStore(name));
      fs.checkRootSync();
      return fs;
    }
  };

  // node_modules/@zenfs/core/dist/backends/port/rpc.js
  init_esbuild_shims();
  function isFileData(value) {
    return typeof value == "object" && value != null && "fd" in value && "path" in value && "position" in value;
  }
  function isMessage(arg) {
    return typeof arg == "object" && arg != null && "_zenfs" in arg && !!arg._zenfs;
  }
  var executors = /* @__PURE__ */ new Map();
  function request(request2, { port, timeout = 1e3, fs } = {}) {
    const stack = new Error().stack.slice("Error:".length);
    if (!port) {
      throw ErrnoError.With("EINVAL");
    }
    return new Promise((resolve2, reject) => {
      const id = Math.random().toString(16).slice(10);
      executors.set(id, { resolve: resolve2, reject, fs });
      port.postMessage({ ...request2, _zenfs: true, id, stack });
      const _ = setTimeout(() => {
        const error = new ErrnoError(Errno.EIO, "RPC Failed");
        error.stack += stack;
        reject(error);
        if (typeof _ == "object")
          _.unref();
      }, timeout);
    });
  }
  function handleResponse(response) {
    if (!isMessage(response)) {
      return;
    }
    const { id, value, error, stack } = response;
    if (!executors.has(id)) {
      const error2 = new ErrnoError(Errno.EIO, "Invalid RPC id:" + id);
      error2.stack += stack;
      throw error2;
    }
    const { resolve: resolve2, reject, fs } = executors.get(id);
    if (error) {
      const e2 = ErrnoError.fromJSON(value);
      e2.stack += stack;
      reject(e2);
      executors.delete(id);
      return;
    }
    if (isFileData(value)) {
      const { fd, path, position } = value;
      const file = new PortFile(fs, fd, path, position);
      resolve2(file);
      executors.delete(id);
      return;
    }
    resolve2(value);
    executors.delete(id);
    return;
  }
  function attach(port, handler) {
    if (!port) {
      throw ErrnoError.With("EINVAL");
    }
    port["on" in port ? "on" : "addEventListener"]("message", (message) => {
      handler("data" in message ? message.data : message);
    });
  }

  // node_modules/@zenfs/core/dist/backends/port/fs.js
  var PortFile = class extends File {
    constructor(fs, fd, path, position) {
      super();
      this.fs = fs;
      this.fd = fd;
      this.path = path;
      this.position = position;
    }
    rpc(method, ...args) {
      return request({
        scope: "file",
        fd: this.fd,
        method,
        args
      }, this.fs.options);
    }
    _throwNoSync(syscall) {
      throw new ErrnoError(Errno.ENOTSUP, "Syncrohnous operations not support on PortFile", this.path, syscall);
    }
    stat() {
      return this.rpc("stat");
    }
    statSync() {
      this._throwNoSync("stat");
    }
    truncate(len) {
      return this.rpc("truncate", len);
    }
    truncateSync() {
      this._throwNoSync("truncate");
    }
    write(buffer2, offset, length, position) {
      return this.rpc("write", buffer2, offset, length, position);
    }
    writeSync() {
      this._throwNoSync("write");
    }
    async read(buffer2, offset, length, position) {
      const result = await this.rpc("read", buffer2, offset, length, position);
      return result;
    }
    readSync() {
      this._throwNoSync("read");
    }
    chown(uid, gid) {
      return this.rpc("chown", uid, gid);
    }
    chownSync() {
      this._throwNoSync("chown");
    }
    chmod(mode) {
      return this.rpc("chmod", mode);
    }
    chmodSync() {
      this._throwNoSync("chmod");
    }
    utimes(atime, mtime) {
      return this.rpc("utimes", atime, mtime);
    }
    utimesSync() {
      this._throwNoSync("utimes");
    }
    _setType(type) {
      return this.rpc("_setType", type);
    }
    _setTypeSync() {
      this._throwNoSync("_setType");
    }
    close() {
      return this.rpc("close");
    }
    closeSync() {
      this._throwNoSync("close");
    }
    sync() {
      return this.rpc("sync");
    }
    syncSync() {
      this._throwNoSync("sync");
    }
  };
  var PortFS = class extends Async(FileSystem) {
    /**
     * Constructs a new PortFS instance that connects with ZenFS running on
     * the specified port.
     */
    constructor(options) {
      super();
      this.options = options;
      this._sync = InMemory.create({ name: "port-tmpfs" });
      this.port = options.port;
      attach(this.port, handleResponse);
    }
    metadata() {
      return {
        ...super.metadata(),
        name: "PortFS"
      };
    }
    rpc(method, ...args) {
      return request({
        scope: "fs",
        method,
        args
      }, { ...this.options, fs: this });
    }
    async ready() {
      await this.rpc("ready");
      await super.ready();
    }
    rename(oldPath, newPath, cred2) {
      return this.rpc("rename", oldPath, newPath, cred2);
    }
    async stat(path, cred2) {
      return new Stats(await this.rpc("stat", path, cred2));
    }
    sync(path, data, stats) {
      return this.rpc("sync", path, data, stats);
    }
    openFile(path, flag, cred2) {
      return this.rpc("openFile", path, flag, cred2);
    }
    createFile(path, flag, mode, cred2) {
      return this.rpc("createFile", path, flag, mode, cred2);
    }
    unlink(path, cred2) {
      return this.rpc("unlink", path, cred2);
    }
    rmdir(path, cred2) {
      return this.rpc("rmdir", path, cred2);
    }
    mkdir(path, mode, cred2) {
      return this.rpc("mkdir", path, mode, cred2);
    }
    readdir(path, cred2) {
      return this.rpc("readdir", path, cred2);
    }
    exists(path, cred2) {
      return this.rpc("exists", path, cred2);
    }
    link(srcpath, dstpath, cred2) {
      return this.rpc("link", srcpath, dstpath, cred2);
    }
  };

  // node_modules/@zenfs/core/dist/backends/fetch.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/index/fs.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/index/index.js
  init_esbuild_shims();

  // node_modules/utilium/dist/index.js
  init_esbuild_shims();

  // node_modules/utilium/dist/misc.js
  init_esbuild_shims();

  // node_modules/utilium/dist/numbers.js
  init_esbuild_shims();

  // node_modules/utilium/dist/objects.js
  init_esbuild_shims();
  function isJSON(str) {
    try {
      JSON.parse(str);
      return true;
    } catch (e2) {
      return false;
    }
  }

  // node_modules/utilium/dist/random.js
  init_esbuild_shims();

  // node_modules/utilium/dist/string.js
  init_esbuild_shims();
  function capitalize(value) {
    return value.at(0).toUpperCase() + value.slice(1);
  }

  // node_modules/utilium/dist/struct.js
  init_esbuild_shims();

  // node_modules/utilium/dist/internal/struct.js
  init_esbuild_shims();
  var init = Symbol("struct_init");
  var metadata = Symbol("struct");

  // node_modules/utilium/dist/internal/primitives.js
  init_esbuild_shims();
  var types = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "float32", "float64"];
  var valids = [...types, ...types.map((t2) => capitalize(t2)), "char"];

  // node_modules/utilium/dist/struct.js
  function member(type, length) {
    return function(target, context) {
      let name = typeof context == "object" ? context.name : context;
      if (typeof name == "symbol") {
        console.warn("Symbol used for struct member name will be coerced to string: " + name.toString());
        name = name.toString();
      }
      if (!name) {
        throw new ReferenceError("Invalid name for struct member");
      }
      if (typeof target != "object") {
        throw new TypeError("Invalid member for struct field");
      }
      if (!("constructor" in target)) {
        throw new TypeError("Invalid member for struct field");
      }
      const struct = target.constructor;
      struct[init] ||= [];
      struct[init].push({ name, type, length });
    };
  }
  function _member(type) {
    function _(targetOrLength, context) {
      if (typeof targetOrLength == "number") {
        return member(type, targetOrLength);
      }
      return member(type)(targetOrLength, context);
    }
    return _;
  }
  var types2 = Object.fromEntries(valids.map((t2) => [t2, _member(t2)]));

  // node_modules/utilium/dist/types.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/index/index.js
  var version = 1;
  var Index = class _Index extends Map {
    constructor() {
      super();
    }
    /**
     * Convience method
     */
    files() {
      const files = /* @__PURE__ */ new Map();
      for (const [path, stats] of this) {
        if (stats.isFile()) {
          files.set(path, stats);
        }
      }
      return files;
    }
    /**
     * Converts the index to JSON
     */
    toJSON() {
      return {
        version,
        entries: Object.fromEntries(this)
      };
    }
    /**
     * Converts the index to a string
     */
    toString() {
      return JSON.stringify(this.toJSON());
    }
    /**
     * Returns the files in the directory `dir`.
     * This is expensive so it is only called once per directory.
     */
    dirEntries(dir) {
      const entries = [];
      for (const entry of this.keys()) {
        if (dirname(entry) == dir) {
          entries.push(basename(entry));
        }
      }
      return entries;
    }
    /**
     * Loads the index from JSON data
     */
    fromJSON(json) {
      if (json.version != version) {
        throw new ErrnoError(Errno.EINVAL, "Index version mismatch");
      }
      this.clear();
      for (const [path, data] of Object.entries(json.entries)) {
        const stats = new Stats(data);
        if (stats.isDirectory()) {
          stats.fileData = encode(JSON.stringify(this.dirEntries(path)));
        }
        this.set(path, stats);
      }
    }
    /**
     * Parses an index from a string
     */
    static parse(data) {
      if (!isJSON(data)) {
        throw new ErrnoError(Errno.EINVAL, "Invalid JSON");
      }
      const json = JSON.parse(data);
      const index = new _Index();
      index.fromJSON(json);
      return index;
    }
  };

  // node_modules/@zenfs/core/dist/backends/index/fs.js
  var IndexFS = class extends Readonly(FileSystem) {
    async ready() {
      await super.ready();
      if (this._isInitialized) {
        return;
      }
      this.index.fromJSON(await this.indexData);
      this._isInitialized = true;
    }
    constructor(indexData) {
      super();
      this.indexData = indexData;
      this.index = new Index();
      this._isInitialized = false;
    }
    async reloadFiles() {
      for (const [path, stats] of this.index.files()) {
        delete stats.fileData;
        stats.fileData = await this.getData(path, stats);
      }
    }
    reloadFilesSync() {
      for (const [path, stats] of this.index.files()) {
        delete stats.fileData;
        stats.fileData = this.getDataSync(path, stats);
      }
    }
    async stat(path) {
      return this.statSync(path);
    }
    statSync(path) {
      if (!this.index.has(path)) {
        throw ErrnoError.With("ENOENT", path, "stat");
      }
      return this.index.get(path);
    }
    async openFile(path, flag, cred2) {
      if (isWriteable(flag)) {
        throw new ErrnoError(Errno.EPERM, path);
      }
      const stats = this.index.get(path);
      if (!stats) {
        throw ErrnoError.With("ENOENT", path, "openFile");
      }
      if (!stats.hasAccess(flagToMode(flag), cred2)) {
        throw ErrnoError.With("EACCES", path, "openFile");
      }
      return new NoSyncFile(this, path, flag, stats, stats.isDirectory() ? stats.fileData : await this.getData(path, stats));
    }
    openFileSync(path, flag, cred2) {
      if (isWriteable(flag)) {
        throw new ErrnoError(Errno.EPERM, path);
      }
      const stats = this.index.get(path);
      if (!stats) {
        throw ErrnoError.With("ENOENT", path, "openFile");
      }
      if (!stats.hasAccess(flagToMode(flag), cred2)) {
        throw ErrnoError.With("EACCES", path, "openFile");
      }
      return new NoSyncFile(this, path, flag, stats, stats.isDirectory() ? stats.fileData : this.getDataSync(path, stats));
    }
    async readdir(path) {
      return this.readdirSync(path);
    }
    readdirSync(path) {
      const stats = this.index.get(path);
      if (!stats) {
        throw ErrnoError.With("ENOENT", path, "readdir");
      }
      if (!stats.isDirectory()) {
        throw ErrnoError.With("ENOTDIR", path, "readdir");
      }
      return JSON.parse(decode(stats.fileData));
    }
  };

  // node_modules/@zenfs/core/dist/backends/locked.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/overlay.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/backends/backend.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/config.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/emulation/index.js
  var emulation_exports = {};
  __export(emulation_exports, {
    BigIntStatsFs: () => BigIntStatsFs,
    Dir: () => Dir,
    Dirent: () => Dirent,
    ReadStream: () => ReadStream,
    Stats: () => Stats,
    StatsFs: () => StatsFs,
    WriteStream: () => WriteStream,
    access: () => access2,
    accessSync: () => accessSync,
    appendFile: () => appendFile2,
    appendFileSync: () => appendFileSync,
    chmod: () => chmod2,
    chmodSync: () => chmodSync,
    chown: () => chown2,
    chownSync: () => chownSync,
    close: () => close,
    closeSync: () => closeSync,
    constants: () => constants_exports,
    copyFile: () => copyFile2,
    copyFileSync: () => copyFileSync,
    cp: () => cp2,
    cpSync: () => cpSync,
    createReadStream: () => createReadStream,
    createWriteStream: () => createWriteStream,
    exists: () => exists2,
    existsSync: () => existsSync,
    fchmod: () => fchmod,
    fchmodSync: () => fchmodSync,
    fchown: () => fchown,
    fchownSync: () => fchownSync,
    fdatasync: () => fdatasync,
    fdatasyncSync: () => fdatasyncSync,
    fstat: () => fstat,
    fstatSync: () => fstatSync,
    fsync: () => fsync,
    fsyncSync: () => fsyncSync,
    ftruncate: () => ftruncate,
    ftruncateSync: () => ftruncateSync,
    futimes: () => futimes,
    futimesSync: () => futimesSync,
    lchmod: () => lchmod2,
    lchmodSync: () => lchmodSync,
    lchown: () => lchown2,
    lchownSync: () => lchownSync,
    link: () => link2,
    linkSync: () => linkSync,
    lopenSync: () => lopenSync,
    lstat: () => lstat2,
    lstatSync: () => lstatSync,
    lutimes: () => lutimes2,
    lutimesSync: () => lutimesSync,
    mkdir: () => mkdir2,
    mkdirSync: () => mkdirSync,
    mkdtemp: () => mkdtemp2,
    mkdtempSync: () => mkdtempSync,
    mount: () => mount,
    mountObject: () => mountObject,
    mounts: () => mounts,
    open: () => open2,
    openAsBlob: () => openAsBlob,
    openSync: () => openSync,
    opendir: () => opendir2,
    opendirSync: () => opendirSync,
    promises: () => promises_exports,
    read: () => read,
    readFile: () => readFile2,
    readFileSync: () => readFileSync,
    readSync: () => readSync,
    readdir: () => readdir2,
    readdirSync: () => readdirSync,
    readlink: () => readlink2,
    readlinkSync: () => readlinkSync,
    readv: () => readv,
    readvSync: () => readvSync,
    realpath: () => realpath2,
    realpathSync: () => realpathSync,
    rename: () => rename2,
    renameSync: () => renameSync,
    rm: () => rm2,
    rmSync: () => rmSync,
    rmdir: () => rmdir2,
    rmdirSync: () => rmdirSync,
    stat: () => stat2,
    statSync: () => statSync,
    statfs: () => statfs2,
    statfsSync: () => statfsSync,
    symlink: () => symlink2,
    symlinkSync: () => symlinkSync,
    truncate: () => truncate2,
    truncateSync: () => truncateSync,
    umount: () => umount,
    unlink: () => unlink2,
    unlinkSync: () => unlinkSync,
    unwatchFile: () => unwatchFile,
    utimes: () => utimes2,
    utimesSync: () => utimesSync,
    watch: () => watch2,
    watchFile: () => watchFile,
    write: () => write,
    writeFile: () => writeFile2,
    writeFileSync: () => writeFileSync,
    writeSync: () => writeSync,
    writev: () => writev,
    writevSync: () => writevSync
  });
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/emulation/async.js
  init_esbuild_shims();
  var import_buffer3 = __toESM(require_buffer(), 1);

  // node_modules/@zenfs/core/dist/emulation/promises.js
  var promises_exports = {};
  __export(promises_exports, {
    FileHandle: () => FileHandle,
    access: () => access,
    appendFile: () => appendFile,
    chmod: () => chmod,
    chown: () => chown,
    constants: () => constants_exports,
    copyFile: () => copyFile,
    cp: () => cp,
    exists: () => exists,
    lchmod: () => lchmod,
    lchown: () => lchown,
    link: () => link,
    lstat: () => lstat,
    lutimes: () => lutimes,
    mkdir: () => mkdir,
    mkdtemp: () => mkdtemp,
    open: () => open,
    opendir: () => opendir,
    readFile: () => readFile,
    readdir: () => readdir,
    readlink: () => readlink,
    realpath: () => realpath,
    rename: () => rename,
    rm: () => rm,
    rmdir: () => rmdir,
    stat: () => stat,
    statfs: () => statfs,
    symlink: () => symlink,
    truncate: () => truncate,
    unlink: () => unlink,
    utimes: () => utimes,
    watch: () => watch,
    writeFile: () => writeFile
  });
  init_esbuild_shims();
  var import_buffer2 = __toESM(require_buffer(), 1);

  // node_modules/@zenfs/core/dist/emulation/dir.js
  init_esbuild_shims();

  // node_modules/@zenfs/core/dist/emulation/sync.js
  init_esbuild_shims();
  var import_buffer = __toESM(require_buffer(), 1);

  // node_modules/@zenfs/core/dist/emulation/shared.js
  init_esbuild_shims();
  var cred = rootCred;
  var fdMap = /* @__PURE__ */ new Map();
  var nextFd = 100;
  function file2fd(file) {
    const fd = nextFd++;
    fdMap.set(fd, file);
    return fd;
  }
  function fd2file(fd) {
    if (!fdMap.has(fd)) {
      throw new ErrnoError(Errno.EBADF);
    }
    return fdMap.get(fd);
  }
  var mounts = /* @__PURE__ */ new Map();
  mount("/", InMemory.create({ name: "root" }));
  function mount(mountPoint, fs) {
    if (mountPoint[0] !== "/") {
      mountPoint = "/" + mountPoint;
    }
    mountPoint = resolve(mountPoint);
    if (mounts.has(mountPoint)) {
      throw new ErrnoError(Errno.EINVAL, "Mount point " + mountPoint + " is already in use.");
    }
    mounts.set(mountPoint, fs);
  }
  function umount(mountPoint) {
    if (mountPoint[0] !== "/") {
      mountPoint = `/${mountPoint}`;
    }
    mountPoint = resolve(mountPoint);
    if (!mounts.has(mountPoint)) {
      throw new ErrnoError(Errno.EINVAL, "Mount point " + mountPoint + " is already unmounted.");
    }
    mounts.delete(mountPoint);
  }
  function resolveMount(path) {
    path = normalizePath(path);
    const sortedMounts = [...mounts].sort((a, b) => a[0].length > b[0].length ? -1 : 1);
    for (const [mountPoint, fs] of sortedMounts) {
      if (mountPoint.length <= path.length && path.startsWith(mountPoint)) {
        path = path.slice(mountPoint.length > 1 ? mountPoint.length : 0);
        if (path === "") {
          path = "/";
        }
        return { fs, path, mountPoint };
      }
    }
    throw new ErrnoError(Errno.EIO, "ZenFS not initialized with a file system");
  }
  function fixPaths(text, paths) {
    for (const [from, to] of Object.entries(paths)) {
      text = text?.replaceAll(from, to);
    }
    return text;
  }
  function fixError(e2, paths) {
    if (typeof e2.stack == "string") {
      e2.stack = fixPaths(e2.stack, paths);
    }
    e2.message = fixPaths(e2.message, paths);
    return e2;
  }
  function mountObject(mounts2) {
    if ("/" in mounts2) {
      umount("/");
    }
    for (const [point, fs] of Object.entries(mounts2)) {
      mount(point, fs);
    }
  }
  function _statfs(fs, bigint) {
    const md = fs.metadata();
    const bs = md.blockSize || 4096;
    return {
      type: (bigint ? BigInt : Number)(md.type),
      bsize: (bigint ? BigInt : Number)(bs),
      ffree: (bigint ? BigInt : Number)(md.freeNodes || size_max),
      files: (bigint ? BigInt : Number)(md.totalNodes || size_max),
      bavail: (bigint ? BigInt : Number)(md.freeSpace / bs),
      bfree: (bigint ? BigInt : Number)(md.freeSpace / bs),
      blocks: (bigint ? BigInt : Number)(md.totalSpace / bs)
    };
  }

  // node_modules/@zenfs/core/dist/emulation/sync.js
  var __addDisposableResource2 = function(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources2 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e2) {
        env.error = env.hasError ? new SuppressedError2(e2, env.error, "An error was suppressed during disposal.") : e2;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async) return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } catch (e2) {
            fail(e2);
          }
        }
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  });
  function renameSync(oldPath, newPath) {
    oldPath = normalizePath(oldPath);
    newPath = normalizePath(newPath);
    const _old = resolveMount(oldPath);
    const _new = resolveMount(newPath);
    const paths = { [_old.path]: oldPath, [_new.path]: newPath };
    try {
      if (_old === _new) {
        return _old.fs.renameSync(_old.path, _new.path, cred);
      }
      writeFileSync(newPath, readFileSync(oldPath));
      unlinkSync(oldPath);
    } catch (e2) {
      throw fixError(e2, paths);
    }
  }
  function existsSync(path) {
    path = normalizePath(path);
    try {
      const { fs, path: resolvedPath2 } = resolveMount(realpathSync(path));
      return fs.existsSync(resolvedPath2, cred);
    } catch (e2) {
      if (e2.errno == Errno.ENOENT) {
        return false;
      }
      throw e2;
    }
  }
  function statSync(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(existsSync(path) ? realpathSync(path) : path);
    try {
      const stats = fs.statSync(resolved, cred);
      return options?.bigint ? new BigIntStats(stats) : stats;
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  function lstatSync(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path);
    try {
      const stats = fs.statSync(resolved, cred);
      return options?.bigint ? new BigIntStats(stats) : stats;
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  function truncateSync(path, len = 0) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const file = __addDisposableResource2(env_1, _openSync(path, "r+"), false);
      len || (len = 0);
      if (len < 0) {
        throw new ErrnoError(Errno.EINVAL);
      }
      file.truncateSync(len);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources2(env_1);
    }
  }
  function unlinkSync(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path);
    try {
      return fs.unlinkSync(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  function _openSync(path, _flag, _mode, resolveSymlinks = true) {
    path = normalizePath(path);
    const mode = normalizeMode(_mode, 420), flag = parseFlag(_flag);
    path = resolveSymlinks && existsSync(path) ? realpathSync(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    if (!fs.existsSync(resolved, cred)) {
      if (!isWriteable(flag) && !isAppendable(flag) || flag == "r+") {
        throw ErrnoError.With("ENOENT", path, "_open");
      }
      const parentStats = fs.statSync(dirname(resolved), cred);
      if (!parentStats.isDirectory()) {
        throw ErrnoError.With("ENOTDIR", dirname(path), "_open");
      }
      return fs.createFileSync(resolved, flag, mode, cred);
    }
    const stats = fs.statSync(resolved, cred);
    if (!stats.hasAccess(mode, cred)) {
      throw ErrnoError.With("EACCES", path, "_open");
    }
    if (isExclusive(flag)) {
      throw ErrnoError.With("EEXIST", path, "_open");
    }
    if (!isTruncating(flag)) {
      return fs.openFileSync(resolved, flag, cred);
    }
    fs.unlinkSync(resolved, cred);
    return fs.createFileSync(resolved, flag, stats.mode, cred);
  }
  function openSync(path, flag, mode = F_OK) {
    return file2fd(_openSync(path, flag, mode, true));
  }
  function lopenSync(path, flag, mode) {
    return file2fd(_openSync(path, flag, mode, false));
  }
  function _readFileSync(fname, flag, resolveSymlinks) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const file = __addDisposableResource2(env_2, _openSync(fname, flag, 420, resolveSymlinks), false);
      const stat3 = file.statSync();
      const data = new Uint8Array(stat3.size);
      file.readSync(data, 0, stat3.size, 0);
      file.closeSync();
      return data;
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources2(env_2);
    }
  }
  function readFileSync(path, _options = {}) {
    const options = normalizeOptions(_options, null, "r", 420);
    const flag = parseFlag(options.flag);
    if (!isReadable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed to readFile must allow for reading.");
    }
    const data = import_buffer.Buffer.from(_readFileSync(typeof path == "number" ? fd2file(path).path : path.toString(), options.flag, true));
    return options.encoding ? data.toString(options.encoding) : data;
  }
  function writeFileSync(path, data, _options = {}) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const options = normalizeOptions(_options, "utf8", "w+", 420);
      const flag = parseFlag(options.flag);
      if (!isWriteable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed to writeFile must allow for writing.");
      }
      if (typeof data != "string" && !options.encoding) {
        throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
      }
      const encodedData = typeof data == "string" ? import_buffer.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      if (!encodedData) {
        throw new ErrnoError(Errno.EINVAL, "Data not specified");
      }
      const file = __addDisposableResource2(env_3, _openSync(typeof path == "number" ? fd2file(path).path : path.toString(), flag, options.mode, true), false);
      file.writeSync(encodedData, 0, encodedData.byteLength, 0);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources2(env_3);
    }
  }
  function appendFileSync(filename, data, _options = {}) {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
      const options = normalizeOptions(_options, "utf8", "a", 420);
      const flag = parseFlag(options.flag);
      if (!isAppendable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
      }
      if (typeof data != "string" && !options.encoding) {
        throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
      }
      const encodedData = typeof data == "string" ? import_buffer.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      const file = __addDisposableResource2(env_4, _openSync(typeof filename == "number" ? fd2file(filename).path : filename.toString(), flag, options.mode, true), false);
      file.writeSync(encodedData, 0, encodedData.byteLength);
    } catch (e_4) {
      env_4.error = e_4;
      env_4.hasError = true;
    } finally {
      __disposeResources2(env_4);
    }
  }
  function fstatSync(fd, options) {
    const stats = fd2file(fd).statSync();
    return options?.bigint ? new BigIntStats(stats) : stats;
  }
  function closeSync(fd) {
    fd2file(fd).closeSync();
    fdMap.delete(fd);
  }
  function ftruncateSync(fd, len = 0) {
    len || (len = 0);
    if (len < 0) {
      throw new ErrnoError(Errno.EINVAL);
    }
    fd2file(fd).truncateSync(len);
  }
  function fsyncSync(fd) {
    fd2file(fd).syncSync();
  }
  function fdatasyncSync(fd) {
    fd2file(fd).datasyncSync();
  }
  function writeSync(fd, data, posOrOff, lenOrEnc, pos) {
    let buffer2, offset, length, position;
    if (typeof data === "string") {
      position = typeof posOrOff === "number" ? posOrOff : null;
      const encoding = typeof lenOrEnc === "string" ? lenOrEnc : "utf8";
      offset = 0;
      buffer2 = import_buffer.Buffer.from(data, encoding);
      length = buffer2.byteLength;
    } else {
      buffer2 = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      offset = posOrOff;
      length = lenOrEnc;
      position = typeof pos === "number" ? pos : null;
    }
    const file = fd2file(fd);
    position ?? (position = file.position);
    return file.writeSync(buffer2, offset, length, position);
  }
  function readSync(fd, buffer2, opts, length, position) {
    const file = fd2file(fd);
    const offset = typeof opts == "object" ? opts.offset : opts;
    if (typeof opts == "object") {
      length = opts.length;
      position = opts.position;
    }
    position = Number(position);
    if (isNaN(position)) {
      position = file.position;
    }
    return file.readSync(buffer2, offset, length, position);
  }
  function fchownSync(fd, uid, gid) {
    fd2file(fd).chownSync(uid, gid);
  }
  function fchmodSync(fd, mode) {
    const numMode = normalizeMode(mode, -1);
    if (numMode < 0) {
      throw new ErrnoError(Errno.EINVAL, `Invalid mode.`);
    }
    fd2file(fd).chmodSync(numMode);
  }
  function futimesSync(fd, atime, mtime) {
    fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
  }
  function rmdirSync(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(existsSync(path) ? realpathSync(path) : path);
    try {
      fs.rmdirSync(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  function mkdirSync(path, options) {
    options = typeof options === "object" ? options : { mode: options };
    const mode = normalizeMode(options?.mode, 511);
    path = normalizePath(path);
    path = existsSync(path) ? realpathSync(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    const errorPaths = { [resolved]: path };
    try {
      if (!options?.recursive) {
        return fs.mkdirSync(resolved, mode, cred);
      }
      const dirs = [];
      for (let dir = resolved, original = path; !fs.existsSync(dir, cred); dir = dirname(dir), original = dirname(original)) {
        dirs.unshift(dir);
        errorPaths[dir] = original;
      }
      for (const dir of dirs) {
        fs.mkdirSync(dir, mode, cred);
      }
      return dirs[0];
    } catch (e2) {
      throw fixError(e2, errorPaths);
    }
  }
  function readdirSync(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(existsSync(path) ? realpathSync(path) : path);
    let entries;
    try {
      entries = fs.readdirSync(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
    for (const mount2 of mounts.keys()) {
      if (!mount2.startsWith(path)) {
        continue;
      }
      const entry = mount2.slice(path.length);
      if (entry.includes("/") || entry.length == 0) {
        continue;
      }
      entries.push(entry);
    }
    return entries.map((entry) => {
      if (typeof options == "object" && options?.withFileTypes) {
        return new Dirent(entry, statSync(join(path.toString(), entry)));
      }
      if (options == "buffer" || typeof options == "object" && options?.encoding == "buffer") {
        return import_buffer.Buffer.from(entry);
      }
      return entry;
    });
  }
  function linkSync(existing, newpath) {
    existing = normalizePath(existing);
    newpath = normalizePath(newpath);
    const { fs, path: resolved } = resolveMount(existing);
    try {
      return fs.linkSync(resolved, newpath, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: existing });
    }
  }
  function symlinkSync(target, path, type = "file") {
    if (!["file", "dir", "junction"].includes(type)) {
      throw new ErrnoError(Errno.EINVAL, "Invalid type: " + type);
    }
    if (existsSync(path)) {
      throw ErrnoError.With("EEXIST", path.toString(), "symlink");
    }
    writeFileSync(path, target.toString());
    const file = _openSync(path, "r+", 420, false);
    file._setTypeSync(FileType.SYMLINK);
  }
  function readlinkSync(path, options) {
    const value = import_buffer.Buffer.from(_readFileSync(path.toString(), "r", false));
    const encoding = typeof options == "object" ? options?.encoding : options;
    if (encoding == "buffer") {
      return value;
    }
    return value.toString(encoding);
  }
  function chownSync(path, uid, gid) {
    const fd = openSync(path, "r+");
    fchownSync(fd, uid, gid);
    closeSync(fd);
  }
  function lchownSync(path, uid, gid) {
    const fd = lopenSync(path, "r+");
    fchownSync(fd, uid, gid);
    closeSync(fd);
  }
  function chmodSync(path, mode) {
    const fd = openSync(path, "r+");
    fchmodSync(fd, mode);
    closeSync(fd);
  }
  function lchmodSync(path, mode) {
    const fd = lopenSync(path, "r+");
    fchmodSync(fd, mode);
    closeSync(fd);
  }
  function utimesSync(path, atime, mtime) {
    const fd = openSync(path, "r+");
    futimesSync(fd, atime, mtime);
    closeSync(fd);
  }
  function lutimesSync(path, atime, mtime) {
    const fd = lopenSync(path, "r+");
    futimesSync(fd, atime, mtime);
    closeSync(fd);
  }
  function realpathSync(path, options) {
    path = normalizePath(path);
    const { base, dir } = parse(path);
    const lpath = join(dir == "/" ? "/" : realpathSync(dir), base);
    const { fs, path: resolvedPath2, mountPoint } = resolveMount(lpath);
    try {
      const stats = fs.statSync(resolvedPath2, cred);
      if (!stats.isSymbolicLink()) {
        return lpath;
      }
      return realpathSync(mountPoint + readlinkSync(lpath));
    } catch (e2) {
      throw fixError(e2, { [resolvedPath2]: lpath });
    }
  }
  function accessSync(path, mode = 384) {
    const stats = statSync(path);
    if (!stats.hasAccess(mode, cred)) {
      throw new ErrnoError(Errno.EACCES);
    }
  }
  function rmSync(path, options) {
    path = normalizePath(path);
    const stats = statSync(path);
    switch (stats.mode & S_IFMT) {
      case S_IFDIR:
        if (options?.recursive) {
          for (const entry of readdirSync(path)) {
            rmSync(join(path, entry));
          }
        }
        rmdirSync(path);
        return;
      case S_IFREG:
      case S_IFLNK:
        unlinkSync(path);
        return;
      case S_IFBLK:
      case S_IFCHR:
      case S_IFIFO:
      case S_IFSOCK:
      default:
        throw new ErrnoError(Errno.EPERM, "File type not supported", path, "rm");
    }
  }
  function mkdtempSync(prefix, options) {
    const encoding = typeof options === "object" ? options?.encoding : options || "utf8";
    const fsName = `${prefix}${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const resolvedPath2 = "/tmp/" + fsName;
    mkdirSync(resolvedPath2);
    return encoding == "buffer" ? import_buffer.Buffer.from(resolvedPath2) : resolvedPath2;
  }
  function copyFileSync(src, dest, flags) {
    src = normalizePath(src);
    dest = normalizePath(dest);
    if (flags && flags & COPYFILE_EXCL && existsSync(dest)) {
      throw new ErrnoError(Errno.EEXIST, "Destination file already exists.", dest, "copyFile");
    }
    writeFileSync(dest, readFileSync(src));
  }
  function readvSync(fd, buffers, position) {
    const file = fd2file(fd);
    let bytesRead = 0;
    for (const buffer2 of buffers) {
      bytesRead += file.readSync(buffer2, 0, buffer2.byteLength, position + bytesRead);
    }
    return bytesRead;
  }
  function writevSync(fd, buffers, position) {
    const file = fd2file(fd);
    let bytesWritten = 0;
    for (const buffer2 of buffers) {
      bytesWritten += file.writeSync(new Uint8Array(buffer2.buffer), 0, buffer2.byteLength, position + bytesWritten);
    }
    return bytesWritten;
  }
  function opendirSync(path, options) {
    path = normalizePath(path);
    return new Dir(path);
  }
  function cpSync(source, destination, opts) {
    source = normalizePath(source);
    destination = normalizePath(destination);
    const srcStats = lstatSync(source);
    if (opts?.errorOnExist && existsSync(destination)) {
      throw new ErrnoError(Errno.EEXIST, "Destination file or directory already exists.", destination, "cp");
    }
    switch (srcStats.mode & S_IFMT) {
      case S_IFDIR:
        if (!opts?.recursive) {
          throw new ErrnoError(Errno.EISDIR, source + " is a directory (not copied)", source, "cp");
        }
        mkdirSync(destination, { recursive: true });
        for (const dirent of readdirSync(source, { withFileTypes: true })) {
          if (opts.filter && !opts.filter(join(source, dirent.name), join(destination, dirent.name))) {
            continue;
          }
          cpSync(join(source, dirent.name), join(destination, dirent.name), opts);
        }
        break;
      case S_IFREG:
      case S_IFLNK:
        copyFileSync(source, destination);
        break;
      case S_IFBLK:
      case S_IFCHR:
      case S_IFIFO:
      case S_IFSOCK:
      default:
        throw new ErrnoError(Errno.EPERM, "File type not supported", source, "rm");
    }
    if (opts?.preserveTimestamps) {
      utimesSync(destination, srcStats.atime, srcStats.mtime);
    }
  }
  function statfsSync(path, options) {
    path = normalizePath(path);
    const { fs } = resolveMount(path);
    return _statfs(fs, options?.bigint);
  }

  // node_modules/@zenfs/core/dist/emulation/dir.js
  var Dirent = class {
    get name() {
      return basename(this.path);
    }
    constructor(path, stats) {
      this.path = path;
      this.stats = stats;
    }
    get parentPath() {
      return this.path;
    }
    isFile() {
      return this.stats.isFile();
    }
    isDirectory() {
      return this.stats.isDirectory();
    }
    isBlockDevice() {
      return this.stats.isBlockDevice();
    }
    isCharacterDevice() {
      return this.stats.isCharacterDevice();
    }
    isSymbolicLink() {
      return this.stats.isSymbolicLink();
    }
    isFIFO() {
      return this.stats.isFIFO();
    }
    isSocket() {
      return this.stats.isSocket();
    }
  };
  var Dir = class {
    checkClosed() {
      if (this.closed) {
        throw new ErrnoError(Errno.EBADF, "Can not use closed Dir");
      }
    }
    constructor(path) {
      this.path = path;
      this.closed = false;
      this._entries = [];
    }
    close(cb) {
      this.closed = true;
      if (!cb) {
        return Promise.resolve();
      }
      cb();
    }
    /**
     * Synchronously close the directory's underlying resource handle.
     * Subsequent reads will result in errors.
     */
    closeSync() {
      this.closed = true;
    }
    async _read() {
      if (!this._entries) {
        this._entries = await readdir(this.path, { withFileTypes: true });
      }
      if (!this._entries.length) {
        return null;
      }
      return this._entries.shift() || null;
    }
    read(cb) {
      if (!cb) {
        return this._read();
      }
      this._read().then((value) => cb(void 0, value));
    }
    /**
     * Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.
     * If there are no more directory entries to read, null will be returned.
     * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
     */
    readSync() {
      if (!this._entries) {
        this._entries = readdirSync(this.path, { withFileTypes: true });
      }
      if (!this._entries.length) {
        return null;
      }
      return this._entries.shift() || null;
    }
    /**
     * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
     */
    [Symbol.asyncIterator]() {
      const _this = this;
      return {
        [Symbol.asyncIterator]: this[Symbol.asyncIterator],
        async next() {
          const value = await _this._read();
          if (value != null) {
            return { done: false, value };
          }
          await _this.close();
          return { done: true, value: void 0 };
        }
      };
    }
  };

  // node_modules/@zenfs/core/dist/emulation/streams.js
  init_esbuild_shims();
  var import_readable_stream = __toESM(require_browser5(), 1);
  var ReadStream = class extends import_readable_stream.Readable {
    close(callback = () => null) {
      try {
        super.destroy();
        super.emit("close");
        callback();
      } catch (err) {
        callback(new ErrnoError(Errno.EIO, err.toString()));
      }
    }
  };
  var WriteStream = class extends import_readable_stream.Writable {
    close(callback = () => null) {
      try {
        super.destroy();
        super.emit("close");
        callback();
      } catch (err) {
        callback(new ErrnoError(Errno.EIO, err.toString()));
      }
    }
  };

  // node_modules/@zenfs/core/dist/emulation/promises.js
  var __addDisposableResource3 = function(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources3 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e2) {
        env.error = env.hasError ? new SuppressedError2(e2, env.error, "An error was suppressed during disposal.") : e2;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async) return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } catch (e2) {
            fail(e2);
          }
        }
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  });
  var FileHandle = class {
    constructor(fdOrFile) {
      const isFile = typeof fdOrFile != "number";
      this.fd = isFile ? file2fd(fdOrFile) : fdOrFile;
      this.file = isFile ? fdOrFile : fd2file(fdOrFile);
    }
    /**
     * Asynchronous fchown(2) - Change ownership of a file.
     */
    chown(uid, gid) {
      return this.file.chown(uid, gid);
    }
    /**
     * Asynchronous fchmod(2) - Change permissions of a file.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    chmod(mode) {
      const numMode = normalizeMode(mode, -1);
      if (numMode < 0) {
        throw new ErrnoError(Errno.EINVAL, "Invalid mode.");
      }
      return this.file.chmod(numMode);
    }
    /**
     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
     */
    datasync() {
      return this.file.datasync();
    }
    /**
     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
     */
    sync() {
      return this.file.sync();
    }
    /**
     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
     * @param len If not specified, defaults to `0`.
     */
    truncate(len) {
      len || (len = 0);
      if (len < 0) {
        throw new ErrnoError(Errno.EINVAL);
      }
      return this.file.truncate(len);
    }
    /**
     * Asynchronously change file timestamps of the file.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    utimes(atime, mtime) {
      return this.file.utimes(normalizeTime(atime), normalizeTime(mtime));
    }
    /**
     * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.
     * The `FileHandle` must have been opened for appending.
     * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
     * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'a'` is used.
     */
    async appendFile(data, _options = {}) {
      const options = normalizeOptions(_options, "utf8", "a", 420);
      const flag = parseFlag(options.flag);
      if (!isAppendable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
      }
      if (typeof data != "string" && !options.encoding) {
        throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
      }
      const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : data;
      await this.file.write(encodedData, 0, encodedData.length);
    }
    /**
     * Asynchronously reads data from the file.
     * The `FileHandle` must have been opened for reading.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset in the buffer at which to start writing.
     * @param length The number of bytes to read.
     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
     */
    read(buffer2, offset, length, position) {
      if (isNaN(+position)) {
        position = this.file.position;
      }
      return this.file.read(buffer2, offset, length, position);
    }
    async readFile(_options) {
      const options = normalizeOptions(_options, null, "r", 292);
      const flag = parseFlag(options.flag);
      if (!isReadable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed must allow for reading.");
      }
      const { size } = await this.stat();
      const { buffer: data } = await this.file.read(new Uint8Array(size), 0, size, 0);
      const buffer2 = import_buffer2.Buffer.from(data);
      return options.encoding ? buffer2.toString(options.encoding) : buffer2;
    }
    /**
     * Returns a `ReadableStream` that may be used to read the files data.
     *
     * An error will be thrown if this method is called more than once or is called after the `FileHandle` is closed
     * or closing.
     *
     * While the `ReadableStream` will read the file to completion, it will not close the `FileHandle` automatically. User code must still call the `fileHandle.close()` method.
     *
     * @since v17.0.0
     * @experimental
     */
    readableWebStream(options = {}) {
      const start = async ({ close: close2, enqueue, error }) => {
        try {
          const chunkSize = 64 * 1024, maxChunks = 1e7;
          let i = 0, position = 0, bytesRead = NaN;
          while (bytesRead > 0) {
            const result = await this.read(new Uint8Array(chunkSize), 0, chunkSize, position);
            if (!result.bytesRead) {
              close2();
              return;
            }
            enqueue(result.buffer.slice(0, result.bytesRead));
            position += result.bytesRead;
            if (++i >= maxChunks) {
              throw new ErrnoError(Errno.EFBIG, "Too many iterations on readable stream", this.file.path, "FileHandle.readableWebStream");
            }
            bytesRead = result.bytesRead;
          }
        } catch (e2) {
          error(e2);
        }
      };
      return new globalThis.ReadableStream({ start, type: options.type });
    }
    readLines(options) {
      throw ErrnoError.With("ENOSYS", this.file.path, "FileHandle.readLines");
    }
    [Symbol.asyncDispose]() {
      return this.close();
    }
    async stat(opts) {
      const stats = await this.file.stat();
      return opts?.bigint ? new BigIntStats(stats) : stats;
    }
    async write(data, posOrOff, lenOrEnc, position) {
      let buffer2, offset, length;
      if (typeof data === "string") {
        position = typeof posOrOff === "number" ? posOrOff : null;
        const encoding = typeof lenOrEnc === "string" ? lenOrEnc : "utf8";
        offset = 0;
        buffer2 = import_buffer2.Buffer.from(data, encoding);
        length = buffer2.length;
      } else {
        buffer2 = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        offset = posOrOff;
        length = lenOrEnc;
        position = typeof position === "number" ? position : null;
      }
      position ?? (position = this.file.position);
      const bytesWritten = await this.file.write(buffer2, offset, length, position);
      return { buffer: buffer2, bytesWritten };
    }
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.
     * The `FileHandle` must have been opened for writing.
     * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
     * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
     * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'w'` is used.
     */
    async writeFile(data, _options = {}) {
      const options = normalizeOptions(_options, "utf8", "w", 420);
      const flag = parseFlag(options.flag);
      if (!isWriteable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed must allow for writing.");
      }
      if (typeof data != "string" && !options.encoding) {
        throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
      }
      const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : data;
      await this.file.write(encodedData, 0, encodedData.length, 0);
    }
    /**
     * Asynchronous close(2) - close a `FileHandle`.
     */
    async close() {
      await this.file.close();
      fdMap.delete(this.fd);
    }
    /**
     * Asynchronous `writev`. Writes from multiple buffers.
     * @param buffers An array of Uint8Array buffers.
     * @param position The position in the file where to begin writing.
     * @returns The number of bytes written.
     */
    async writev(buffers, position) {
      let bytesWritten = 0;
      for (const buffer2 of buffers) {
        bytesWritten += (await this.write(buffer2, 0, buffer2.length, position + bytesWritten)).bytesWritten;
      }
      return { bytesWritten, buffers };
    }
    /**
     * Asynchronous `readv`. Reads into multiple buffers.
     * @param buffers An array of Uint8Array buffers.
     * @param position The position in the file where to begin reading.
     * @returns The number of bytes read.
     */
    async readv(buffers, position) {
      let bytesRead = 0;
      for (const buffer2 of buffers) {
        bytesRead += (await this.read(buffer2, 0, buffer2.byteLength, position + bytesRead)).bytesRead;
      }
      return { bytesRead, buffers };
    }
    /**
     * Creates a `ReadStream` for reading from the file.
     *
     * @param options Options for the readable stream
     * @returns A `ReadStream` object.
     */
    createReadStream(options) {
      const stream2 = new ReadStream({
        highWaterMark: options?.highWaterMark || 64 * 1024,
        encoding: options.encoding,
        read: async (size) => {
          try {
            const result = await this.read(new Uint8Array(size), 0, size, this.file.position);
            stream2.push(!result.bytesRead ? null : result.buffer.slice(0, result.bytesRead));
            this.file.position += result.bytesRead;
          } catch (error) {
            stream2.destroy(error);
          }
        }
      });
      stream2.path = this.file.path;
      return stream2;
    }
    /**
     * Creates a `WriteStream` for writing to the file.
     *
     * @param options Options for the writeable stream.
     * @returns A `WriteStream` object
     */
    createWriteStream(options) {
      const streamOptions = {
        highWaterMark: options?.highWaterMark,
        encoding: options?.encoding,
        write: async (chunk, encoding, callback) => {
          try {
            const { bytesWritten } = await this.write(chunk, null, encoding);
            callback(bytesWritten == chunk.length ? null : new Error("Failed to write full chunk"));
          } catch (error) {
            callback(error);
          }
        }
      };
      const stream2 = new WriteStream(streamOptions);
      stream2.path = this.file.path;
      return stream2;
    }
  };
  async function rename(oldPath, newPath) {
    oldPath = normalizePath(oldPath);
    newPath = normalizePath(newPath);
    const src = resolveMount(oldPath);
    const dst = resolveMount(newPath);
    try {
      if (src.mountPoint == dst.mountPoint) {
        await src.fs.rename(src.path, dst.path, cred);
        return;
      }
      await writeFile(newPath, await readFile(oldPath));
      await unlink(oldPath);
    } catch (e2) {
      throw fixError(e2, { [src.path]: oldPath, [dst.path]: newPath });
    }
  }
  async function exists(path) {
    try {
      const { fs, path: resolved } = resolveMount(await realpath(path));
      return await fs.exists(resolved, cred);
    } catch (e2) {
      if (e2 instanceof ErrnoError && e2.code == "ENOENT") {
        return false;
      }
      throw e2;
    }
  }
  async function stat(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(await exists(path) ? await realpath(path) : path);
    try {
      const stats = await fs.stat(resolved, cred);
      return options?.bigint ? new BigIntStats(stats) : stats;
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  async function lstat(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path);
    try {
      const stats = await fs.stat(resolved, cred);
      return options?.bigint ? new BigIntStats(stats) : stats;
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  async function truncate(path, len = 0) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_1, await open(path, "r+"), true);
      await handle.truncate(len);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      const result_1 = __disposeResources3(env_1);
      if (result_1)
        await result_1;
    }
  }
  async function unlink(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path);
    try {
      await fs.unlink(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  async function _open(path, _flag, _mode = 420, resolveSymlinks) {
    path = normalizePath(path);
    const mode = normalizeMode(_mode, 420), flag = parseFlag(_flag);
    path = resolveSymlinks && await exists(path) ? await realpath(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    if (!await fs.exists(resolved, cred)) {
      if (!isWriteable(flag) && !isAppendable(flag) || flag == "r+") {
        throw ErrnoError.With("ENOENT", path, "_open");
      }
      const parentStats = await fs.stat(dirname(resolved), cred);
      if (parentStats && !parentStats.isDirectory()) {
        throw ErrnoError.With("ENOTDIR", dirname(path), "_open");
      }
      return new FileHandle(await fs.createFile(resolved, flag, mode, cred));
    }
    if (isExclusive(flag)) {
      throw ErrnoError.With("EEXIST", path, "_open");
    }
    if (!isTruncating(flag)) {
      return new FileHandle(await fs.openFile(resolved, flag, cred));
    }
    const file = await fs.openFile(resolved, flag, cred);
    await file.truncate(0);
    await file.sync();
    return new FileHandle(file);
  }
  async function open(path, flag = "r", mode = 420) {
    return await _open(path, flag, mode, true);
  }
  async function readFile(path, _options) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const options = normalizeOptions(_options, null, "r", 420);
      const handle = __addDisposableResource3(env_2, typeof path == "object" && "fd" in path ? path : await open(path, options.flag, options.mode), true);
      return await handle.readFile(options);
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      const result_2 = __disposeResources3(env_2);
      if (result_2)
        await result_2;
    }
  }
  async function writeFile(path, data, _options) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const options = normalizeOptions(_options, "utf8", "w+", 420);
      const handle = __addDisposableResource3(env_3, path instanceof FileHandle ? path : await open(path.toString(), options.flag, options.mode), true);
      const _data = typeof data == "string" ? data : data;
      if (typeof _data != "string" && !(_data instanceof Uint8Array)) {
        throw new ErrnoError(Errno.EINVAL, "Iterables and streams not supported", handle.file.path, "writeFile");
      }
      await handle.writeFile(_data, options);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      const result_3 = __disposeResources3(env_3);
      if (result_3)
        await result_3;
    }
  }
  async function appendFile(path, data, _options) {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
      const options = normalizeOptions(_options, "utf8", "a", 420);
      const flag = parseFlag(options.flag);
      if (!isAppendable(flag)) {
        throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
      }
      if (typeof data != "string" && !options.encoding) {
        throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
      }
      const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      const handle = __addDisposableResource3(env_4, typeof path == "object" && "fd" in path ? path : await open(path, options.flag, options.mode), true);
      await handle.appendFile(encodedData, options);
    } catch (e_4) {
      env_4.error = e_4;
      env_4.hasError = true;
    } finally {
      const result_4 = __disposeResources3(env_4);
      if (result_4)
        await result_4;
    }
  }
  async function rmdir(path) {
    path = normalizePath(path);
    path = await exists(path) ? await realpath(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    try {
      await fs.rmdir(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
  }
  async function mkdir(path, options) {
    options = typeof options === "object" ? options : { mode: options };
    const mode = normalizeMode(options?.mode, 511);
    path = normalizePath(path);
    path = await exists(path) ? await realpath(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    const errorPaths = { [resolved]: path };
    try {
      if (!options?.recursive) {
        await fs.mkdir(resolved, mode, cred);
      }
      const dirs = [];
      for (let dir = resolved, origDir = path; !await fs.exists(dir, cred); dir = dirname(dir), origDir = dirname(origDir)) {
        dirs.unshift(dir);
        errorPaths[dir] = origDir;
      }
      for (const dir of dirs) {
        await fs.mkdir(dir, mode, cred);
      }
      return dirs[0];
    } catch (e2) {
      throw fixError(e2, errorPaths);
    }
  }
  async function readdir(path, options) {
    path = normalizePath(path);
    path = await exists(path) ? await realpath(path) : path;
    const { fs, path: resolved } = resolveMount(path);
    let entries;
    try {
      entries = await fs.readdir(resolved, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: path });
    }
    for (const point of mounts.keys()) {
      if (point.startsWith(path)) {
        const entry = point.slice(path.length);
        if (entry.includes("/") || entry.length == 0) {
          continue;
        }
        entries.push(entry);
      }
    }
    const values = [];
    for (const entry of entries) {
      values.push(typeof options == "object" && options?.withFileTypes ? new Dirent(entry, await stat(join(path, entry))) : entry);
    }
    return values;
  }
  async function link(existing, newpath) {
    existing = normalizePath(existing);
    newpath = normalizePath(newpath);
    const { fs, path: resolved } = resolveMount(newpath);
    try {
      return await fs.link(existing, newpath, cred);
    } catch (e2) {
      throw fixError(e2, { [resolved]: newpath });
    }
  }
  async function symlink(target, path, type = "file") {
    if (!["file", "dir", "junction"].includes(type)) {
      throw new ErrnoError(Errno.EINVAL, "Invalid symlink type: " + type);
    }
    if (await exists(path)) {
      throw ErrnoError.With("EEXIST", path.toString(), "symlink");
    }
    await writeFile(path, target.toString());
    const handle = await _open(path, "r+", 420, false);
    await handle.file._setType(FileType.SYMLINK);
  }
  async function readlink(path, options) {
    const env_5 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_5, await _open(normalizePath(path), "r", 420, false), true);
      const value = await handle.readFile();
      const encoding = typeof options == "object" ? options?.encoding : options;
      return encoding == "buffer" ? value : value.toString(encoding);
    } catch (e_5) {
      env_5.error = e_5;
      env_5.hasError = true;
    } finally {
      const result_5 = __disposeResources3(env_5);
      if (result_5)
        await result_5;
    }
  }
  async function chown(path, uid, gid) {
    const env_6 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_6, await open(path, "r+"), true);
      await handle.chown(uid, gid);
    } catch (e_6) {
      env_6.error = e_6;
      env_6.hasError = true;
    } finally {
      const result_6 = __disposeResources3(env_6);
      if (result_6)
        await result_6;
    }
  }
  async function lchown(path, uid, gid) {
    const env_7 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_7, await _open(path, "r+", 420, false), true);
      await handle.chown(uid, gid);
    } catch (e_7) {
      env_7.error = e_7;
      env_7.hasError = true;
    } finally {
      const result_7 = __disposeResources3(env_7);
      if (result_7)
        await result_7;
    }
  }
  async function chmod(path, mode) {
    const env_8 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_8, await open(path, "r+"), true);
      await handle.chmod(mode);
    } catch (e_8) {
      env_8.error = e_8;
      env_8.hasError = true;
    } finally {
      const result_8 = __disposeResources3(env_8);
      if (result_8)
        await result_8;
    }
  }
  async function lchmod(path, mode) {
    const env_9 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_9, await _open(path, "r+", 420, false), true);
      await handle.chmod(mode);
    } catch (e_9) {
      env_9.error = e_9;
      env_9.hasError = true;
    } finally {
      const result_9 = __disposeResources3(env_9);
      if (result_9)
        await result_9;
    }
  }
  async function utimes(path, atime, mtime) {
    const env_10 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_10, await open(path, "r+"), true);
      await handle.utimes(atime, mtime);
    } catch (e_10) {
      env_10.error = e_10;
      env_10.hasError = true;
    } finally {
      const result_10 = __disposeResources3(env_10);
      if (result_10)
        await result_10;
    }
  }
  async function lutimes(path, atime, mtime) {
    const env_11 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_11, await _open(path, "r+", 420, false), true);
      await handle.utimes(new Date(atime), new Date(mtime));
    } catch (e_11) {
      env_11.error = e_11;
      env_11.hasError = true;
    } finally {
      const result_11 = __disposeResources3(env_11);
      if (result_11)
        await result_11;
    }
  }
  async function realpath(path, options) {
    path = normalizePath(path);
    const { base, dir } = parse(path);
    const lpath = join(dir == "/" ? "/" : await realpath(dir), base);
    const { fs, path: resolvedPath2, mountPoint } = resolveMount(lpath);
    try {
      const stats = await fs.stat(resolvedPath2, cred);
      if (!stats.isSymbolicLink()) {
        return lpath;
      }
      return realpath(mountPoint + await readlink(lpath));
    } catch (e2) {
      throw fixError(e2, { [resolvedPath2]: lpath });
    }
  }
  function watch(filename, options = {}) {
    throw ErrnoError.With("ENOSYS", filename.toString(), "watch");
  }
  async function access(path, mode = F_OK) {
    const stats = await stat(path);
    if (!stats.hasAccess(mode, cred)) {
      throw new ErrnoError(Errno.EACCES);
    }
  }
  async function rm(path, options) {
    path = normalizePath(path);
    const stats = await stat(path);
    switch (stats.mode & S_IFMT) {
      case S_IFDIR:
        if (options?.recursive) {
          for (const entry of await readdir(path)) {
            await rm(join(path, entry));
          }
        }
        await rmdir(path);
        return;
      case S_IFREG:
      case S_IFLNK:
        await unlink(path);
        return;
      case S_IFBLK:
      case S_IFCHR:
      case S_IFIFO:
      case S_IFSOCK:
      default:
        throw new ErrnoError(Errno.EPERM, "File type not supported", path, "rm");
    }
  }
  async function mkdtemp(prefix, options) {
    const encoding = typeof options === "object" ? options?.encoding : options || "utf8";
    const fsName = `${prefix}${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const resolvedPath2 = "/tmp/" + fsName;
    await mkdir(resolvedPath2);
    return encoding == "buffer" ? import_buffer2.Buffer.from(resolvedPath2) : resolvedPath2;
  }
  async function copyFile(src, dest, mode) {
    src = normalizePath(src);
    dest = normalizePath(dest);
    if (mode && mode & COPYFILE_EXCL && await exists(dest)) {
      throw new ErrnoError(Errno.EEXIST, "Destination file already exists.", dest, "copyFile");
    }
    await writeFile(dest, await readFile(src));
  }
  async function opendir(path, options) {
    path = normalizePath(path);
    return new Dir(path);
  }
  async function cp(source, destination, opts) {
    source = normalizePath(source);
    destination = normalizePath(destination);
    const srcStats = await lstat(source);
    if (opts?.errorOnExist && await exists(destination)) {
      throw new ErrnoError(Errno.EEXIST, "Destination file or directory already exists.", destination, "cp");
    }
    switch (srcStats.mode & S_IFMT) {
      case S_IFDIR:
        if (!opts?.recursive) {
          throw new ErrnoError(Errno.EISDIR, source + " is a directory (not copied)", source, "cp");
        }
        await mkdir(destination, { recursive: true });
        for (const dirent of await readdir(source, { withFileTypes: true })) {
          if (opts.filter && !opts.filter(join(source, dirent.name), join(destination, dirent.name))) {
            continue;
          }
          await cp(join(source, dirent.name), join(destination, dirent.name), opts);
        }
        break;
      case S_IFREG:
      case S_IFLNK:
        await copyFile(source, destination);
        break;
      case S_IFBLK:
      case S_IFCHR:
      case S_IFIFO:
      case S_IFSOCK:
      default:
        throw new ErrnoError(Errno.EPERM, "File type not supported", source, "rm");
    }
    if (opts?.preserveTimestamps) {
      await utimes(destination, srcStats.atime, srcStats.mtime);
    }
  }
  async function statfs(path, opts) {
    path = normalizePath(path);
    const { fs } = resolveMount(path);
    return _statfs(fs, opts?.bigint);
  }

  // node_modules/@zenfs/core/dist/emulation/async.js
  function rename2(oldPath, newPath, cb = nop) {
    rename(oldPath, newPath).then(() => cb()).catch(cb);
  }
  function exists2(path, cb = nop) {
    exists(path).then(cb).catch(() => cb(false));
  }
  function stat2(path, options, callback = nop) {
    callback = typeof options == "function" ? options : callback;
    stat(path, typeof options != "function" ? options : {}).then((stats) => callback(void 0, stats)).catch(callback);
  }
  function lstat2(path, options, callback = nop) {
    callback = typeof options == "function" ? options : callback;
    lstat(path, typeof options != "function" ? options : {}).then((stats) => callback(void 0, stats)).catch(callback);
  }
  function truncate2(path, cbLen = 0, cb = nop) {
    cb = typeof cbLen === "function" ? cbLen : cb;
    const len = typeof cbLen === "number" ? cbLen : 0;
    truncate(path, len).then(() => cb()).catch(cb);
  }
  function unlink2(path, cb = nop) {
    unlink(path).then(() => cb()).catch(cb);
  }
  function open2(path, flag, cbMode, cb = nop) {
    const mode = normalizeMode(cbMode, 420);
    cb = typeof cbMode === "function" ? cbMode : cb;
    open(path, flag, mode).then((handle) => cb(void 0, handle.fd)).catch(cb);
  }
  function readFile2(filename, options, cb = nop) {
    cb = typeof options === "function" ? options : cb;
    readFile(filename, typeof options === "function" ? null : options).then((data) => cb(void 0, data)).catch(cb);
  }
  function writeFile2(filename, data, cbEncOpts, cb = nop) {
    cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
    writeFile(filename, data, typeof cbEncOpts != "function" ? cbEncOpts : null).then(() => cb(void 0)).catch(cb);
  }
  function appendFile2(filename, data, cbEncOpts, cb = nop) {
    cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
    appendFile(filename, data, typeof cbEncOpts === "function" ? null : cbEncOpts).then(() => cb()).catch(cb);
  }
  function fstat(fd, options, cb = nop) {
    cb = typeof options == "function" ? options : cb;
    fd2file(fd).stat().then((stats) => cb(void 0, typeof options == "object" && options?.bigint ? new BigIntStats(stats) : stats)).catch(cb);
  }
  function close(fd, cb = nop) {
    new FileHandle(fd).close().then(() => cb()).catch(cb);
  }
  function ftruncate(fd, lenOrCB, cb = nop) {
    const length = typeof lenOrCB === "number" ? lenOrCB : 0;
    cb = typeof lenOrCB === "function" ? lenOrCB : cb;
    const file = fd2file(fd);
    if (length < 0) {
      throw new ErrnoError(Errno.EINVAL);
    }
    file.truncate(length).then(() => cb()).catch(cb);
  }
  function fsync(fd, cb = nop) {
    fd2file(fd).sync().then(() => cb()).catch(cb);
  }
  function fdatasync(fd, cb = nop) {
    fd2file(fd).datasync().then(() => cb()).catch(cb);
  }
  function write(fd, data, cbPosOff, cbLenEnc, cbPos, cb = nop) {
    let buffer2, offset, length, position, encoding;
    const handle = new FileHandle(fd);
    if (typeof data === "string") {
      encoding = "utf8";
      switch (typeof cbPosOff) {
        case "function":
          cb = cbPosOff;
          break;
        case "number":
          position = cbPosOff;
          encoding = typeof cbLenEnc === "string" ? cbLenEnc : "utf8";
          cb = typeof cbPos === "function" ? cbPos : cb;
          break;
        default:
          cb = typeof cbLenEnc === "function" ? cbLenEnc : typeof cbPos === "function" ? cbPos : cb;
          cb(new ErrnoError(Errno.EINVAL, "Invalid arguments."));
          return;
      }
      buffer2 = import_buffer3.Buffer.from(data);
      offset = 0;
      length = buffer2.length;
      const _cb = cb;
      handle.write(buffer2, offset, length, position).then(({ bytesWritten }) => _cb(void 0, bytesWritten, buffer2.toString(encoding))).catch(_cb);
    } else {
      buffer2 = import_buffer3.Buffer.from(data.buffer);
      offset = cbPosOff;
      length = cbLenEnc;
      position = typeof cbPos === "number" ? cbPos : null;
      const _cb = typeof cbPos === "function" ? cbPos : cb;
      handle.write(buffer2, offset, length, position).then(({ bytesWritten }) => _cb(void 0, bytesWritten, buffer2)).catch(_cb);
    }
  }
  function read(fd, buffer2, offset, length, position, cb = nop) {
    new FileHandle(fd).read(buffer2, offset, length, position).then(({ bytesRead, buffer: buffer3 }) => cb(void 0, bytesRead, buffer3)).catch(cb);
  }
  function fchown(fd, uid, gid, cb = nop) {
    new FileHandle(fd).chown(uid, gid).then(() => cb()).catch(cb);
  }
  function fchmod(fd, mode, cb) {
    new FileHandle(fd).chmod(mode).then(() => cb()).catch(cb);
  }
  function futimes(fd, atime, mtime, cb = nop) {
    new FileHandle(fd).utimes(atime, mtime).then(() => cb()).catch(cb);
  }
  function rmdir2(path, cb = nop) {
    rmdir(path).then(() => cb()).catch(cb);
  }
  function mkdir2(path, mode, cb = nop) {
    mkdir(path, mode).then(() => cb()).catch(cb);
  }
  function readdir2(path, _options, cb = nop) {
    cb = typeof _options == "function" ? _options : cb;
    const options = typeof _options != "function" ? _options : {};
    readdir(path, options).then((entries) => cb(void 0, entries)).catch(cb);
  }
  function link2(existing, newpath, cb = nop) {
    link(existing, newpath).then(() => cb()).catch(cb);
  }
  function symlink2(target, path, typeOrCB, cb = nop) {
    const type = typeof typeOrCB === "string" ? typeOrCB : "file";
    cb = typeof typeOrCB === "function" ? typeOrCB : cb;
    symlink(target, path, type).then(() => cb()).catch(cb);
  }
  function readlink2(path, options, callback = nop) {
    callback = typeof options == "function" ? options : callback;
    readlink(path).then((result) => callback(void 0, result)).catch(callback);
  }
  function chown2(path, uid, gid, cb = nop) {
    chown(path, uid, gid).then(() => cb()).catch(cb);
  }
  function lchown2(path, uid, gid, cb = nop) {
    lchown(path, uid, gid).then(() => cb()).catch(cb);
  }
  function chmod2(path, mode, cb = nop) {
    chmod(path, mode).then(() => cb()).catch(cb);
  }
  function lchmod2(path, mode, cb = nop) {
    lchmod(path, mode).then(() => cb()).catch(cb);
  }
  function utimes2(path, atime, mtime, cb = nop) {
    utimes(path, atime, mtime).then(() => cb()).catch(cb);
  }
  function lutimes2(path, atime, mtime, cb = nop) {
    lutimes(path, atime, mtime).then(() => cb()).catch(cb);
  }
  function realpath2(path, arg2, cb = nop) {
    cb = typeof arg2 === "function" ? arg2 : cb;
    realpath(path, typeof arg2 === "function" ? null : arg2).then((result) => cb(void 0, result)).catch(cb);
  }
  function access2(path, cbMode, cb = nop) {
    const mode = typeof cbMode === "number" ? cbMode : R_OK;
    cb = typeof cbMode === "function" ? cbMode : cb;
    access(path, typeof cbMode === "function" ? null : cbMode).then(() => cb()).catch(cb);
  }
  function watchFile(path, optsListener, listener = nop) {
    throw ErrnoError.With("ENOSYS", path.toString(), "watchFile");
  }
  function unwatchFile(path, listener = nop) {
    throw ErrnoError.With("ENOSYS", path.toString(), "unwatchFile");
  }
  function watch2(path, options, listener = nop) {
    throw ErrnoError.With("ENOSYS", path.toString(), "watch");
  }
  function createReadStream(path, _options) {
    const options = typeof _options == "object" ? _options : { encoding: _options };
    let handle;
    const stream2 = new ReadStream({
      highWaterMark: options.highWaterMark || 64 * 1024,
      encoding: options.encoding || "utf8",
      async read(size) {
        try {
          handle || (handle = await open(path, "r", options?.mode));
          const result = await handle.read(new Uint8Array(size), 0, size, handle.file.position);
          stream2.push(!result.bytesRead ? null : result.buffer.slice(0, result.bytesRead));
          handle.file.position += result.bytesRead;
          if (!result.bytesRead) {
            await handle.close();
          }
        } catch (error) {
          await handle?.close();
          stream2.destroy(error);
        }
      },
      destroy(error, callback) {
        handle?.close().then(() => callback(error)).catch(callback);
      }
    });
    stream2.path = path.toString();
    return stream2;
  }
  function createWriteStream(path, _options) {
    const options = typeof _options == "object" ? _options : { encoding: _options };
    let handle;
    const stream2 = new WriteStream({
      highWaterMark: options?.highWaterMark,
      async write(chunk, encoding, callback) {
        try {
          handle || (handle = await open(path, "w", options?.mode || 438));
          await handle.write(chunk, 0, encoding);
          callback(void 0);
        } catch (error) {
          await handle?.close();
          callback(error);
        }
      },
      destroy(error, callback) {
        callback(error);
        handle?.close().then(() => callback(error)).catch(callback);
      },
      final(callback) {
        handle?.close().then(() => callback()).catch(callback);
      }
    });
    stream2.path = path.toString();
    return stream2;
  }
  function rm2(path, options, callback = nop) {
    callback = typeof options === "function" ? options : callback;
    rm(path, typeof options === "function" ? void 0 : options).then(() => callback(void 0)).catch(callback);
  }
  function mkdtemp2(prefix, options, callback = nop) {
    callback = typeof options === "function" ? options : callback;
    mkdtemp(prefix, typeof options != "function" ? options : null).then((result) => callback(void 0, result)).catch(callback);
  }
  function copyFile2(src, dest, flags, callback = nop) {
    callback = typeof flags === "function" ? flags : callback;
    copyFile(src, dest, typeof flags === "function" ? void 0 : flags).then(() => callback(void 0)).catch(callback);
  }
  function readv(fd, buffers, position, cb = nop) {
    cb = typeof position === "function" ? position : cb;
    new FileHandle(fd).readv(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesRead }) => cb(void 0, bytesRead, buffers2)).catch(cb);
  }
  function writev(fd, buffers, position, cb = nop) {
    cb = typeof position === "function" ? position : cb;
    new FileHandle(fd).writev(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesWritten }) => cb(void 0, bytesWritten, buffers2)).catch(cb);
  }
  function opendir2(path, options, cb = nop) {
    cb = typeof options === "function" ? options : cb;
    opendir(path, typeof options === "function" ? void 0 : options).then((result) => cb(void 0, result)).catch(cb);
  }
  function cp2(source, destination, opts, callback = nop) {
    callback = typeof opts === "function" ? opts : callback;
    cp(source, destination, typeof opts === "function" ? void 0 : opts).then(() => callback(void 0)).catch(callback);
  }
  function statfs2(path, options, callback = nop) {
    callback = typeof options === "function" ? options : callback;
    statfs(path, typeof options === "function" ? void 0 : options).then((result) => callback(void 0, result)).catch(callback);
  }
  async function openAsBlob(path, options) {
    const handle = await open(path.toString(), "r");
    const buffer2 = await handle.readFile();
    await handle.close();
    return new Blob([buffer2], options);
  }

  // node_modules/@zenfs/core/dist/index.js
  var dist_default = emulation_exports;

  // lib/util.ts
  var parquet_thrift = __toESM(require_parquet_types());
  var import_thrift2 = __toESM(require_browser2());
  var fixedTFramedTransport = class extends import_thrift.default.TFramedTransport {
    inBuf;
    readPos;
    constructor(inBuf) {
      super(inBuf);
      this.inBuf = inBuf;
      this.readPos = 0;
    }
  };
  var getterSetter = (index) => ({
    get: function() {
      return this[index];
    },
    set: function(value) {
      return this[index] = value;
    }
  });
  Object.defineProperty(parquet_thrift.PageLocation.prototype, "offset", getterSetter(0));
  Object.defineProperty(parquet_thrift.PageLocation.prototype, "compressed_page_size", getterSetter(1));
  Object.defineProperty(parquet_thrift.PageLocation.prototype, "first_row_index", getterSetter(2));
  var serializeThrift = function(obj) {
    const output = [];
    const callBack = function(buf) {
      output.push(buf);
    };
    const transport = new import_thrift.default.TBufferedTransport(void 0, callBack);
    const protocol = new import_thrift.default.TCompactProtocol(transport);
    obj.write(protocol);
    transport.flush();
    return Buffer2.concat(output);
  };
  var decodeThrift = function(obj, buf, offset) {
    if (!offset) {
      offset = 0;
    }
    const transport = new fixedTFramedTransport(buf);
    transport.readPos = offset;
    const protocol = new import_thrift.default.TCompactProtocol(transport);
    obj.read(protocol);
    return transport.readPos - offset;
  };
  var getBitWidth = function(val2) {
    if (val2 === 0) {
      return 0;
    } else {
      return Math.ceil(Math.log2(val2 + 1));
    }
  };
  var getThriftEnum = function(klass, value) {
    for (const k in klass) {
      if (klass[k] === value) {
        return k;
      }
    }
    throw "Invalid ENUM value";
  };
  var fopen = function(filePath) {
    return new Promise((resolve2, reject) => {
      dist_default.open(filePath, "r", (err, fd) => {
        if (err) {
          reject(err);
        } else {
          resolve2(fd);
        }
      });
    });
  };
  var fstat2 = function(filePath) {
    return new Promise((resolve2, reject) => {
      dist_default.stat(filePath, (err, stat3) => {
        if (err) {
          reject(err);
        } else {
          resolve2(stat3);
        }
      });
    });
  };
  var fread = function(fd, position, length) {
    const buffer2 = Buffer2.alloc(length);
    return new Promise((resolve2, reject) => {
      dist_default.read(fd, buffer2, 0, length, position, (err, bytesRead, buf) => {
        if (err || bytesRead != length) {
          reject(err || Error("read failed"));
        } else {
          resolve2(buf);
        }
      });
    });
  };
  var fclose = function(fd) {
    return new Promise((resolve2, reject) => {
      dist_default.close(fd, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve2(err);
        }
      });
    });
  };
  var oswrite = function(os, buf) {
    return new Promise((resolve2, reject) => {
      os.write(buf, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve2(err);
        }
      });
    });
  };
  var osend = function(os) {
    return new Promise((resolve2, reject) => {
      os.end((err) => {
        if (err) {
          reject(err);
        } else {
          resolve2(err);
        }
      });
    });
  };
  var osopen = function(path, opts) {
    return new Promise((resolve2, reject) => {
      const outputStream = dist_default.createWriteStream(path, opts);
      outputStream.on("open", function(_fd) {
        resolve2(outputStream);
      });
      outputStream.on("error", function(err) {
        reject(err);
      });
    });
  };
  var fieldIndexOf = function(arr, elem) {
    for (let j = 0; j < arr.length; ++j) {
      if (arr[j].length !== elem.length) {
        continue;
      }
      let m = true;
      for (let i = 0; i < elem.length; ++i) {
        if (arr[j][i] !== elem[i]) {
          m = false;
          break;
        }
      }
      if (m) {
        return j;
      }
    }
    return -1;
  };
  var cloneInteger = (int) => {
    return new import_thrift2.Int64(int.valueOf());
  };

  // lib/schema.ts
  init_esbuild_shims();

  // lib/codec/index.ts
  var codec_exports = {};
  __export(codec_exports, {
    PLAIN: () => plain_exports,
    PLAIN_DICTIONARY: () => plain_dictionary_exports,
    RLE: () => rle_exports,
    RLE_DICTIONARY: () => plain_dictionary_exports
  });
  init_esbuild_shims();

  // lib/codec/plain.ts
  var plain_exports = {};
  __export(plain_exports, {
    decodeValues: () => decodeValues,
    encodeValues: () => encodeValues
  });
  init_esbuild_shims();
  var import_int53 = __toESM(require_int53());
  function encodeValues_BOOLEAN(values) {
    const buf = Buffer2.alloc(Math.ceil(values.length / 8));
    buf.fill(0);
    for (let i = 0; i < values.length; ++i) {
      if (values[i]) {
        buf[Math.floor(i / 8)] |= 1 << i % 8;
      }
    }
    return buf;
  }
  function decodeValues_BOOLEAN(cursor, count) {
    const values = [];
    for (let i = 0; i < count; ++i) {
      const b = cursor.buffer[cursor.offset + Math.floor(i / 8)];
      values.push((b & 1 << i % 8) > 0);
    }
    cursor.offset += Math.ceil(count / 8);
    return values;
  }
  function encodeValues_INT32(values, opts) {
    const isDecimal = opts?.originalType === "DECIMAL" || opts?.column?.originalType === "DECIMAL";
    const scale = opts?.scale || 0;
    const buf = Buffer2.alloc(4 * values.length);
    for (let i = 0; i < values.length; i++) {
      if (isDecimal) {
        buf.writeInt32LE(values[i] * Math.pow(10, scale), i * 4);
      } else {
        buf.writeInt32LE(values[i], i * 4);
      }
    }
    return buf;
  }
  function decodeValues_INT32(cursor, count, opts) {
    let values = [];
    const name = opts.name || opts.column?.name || void 0;
    try {
      if (opts.originalType === "DECIMAL") {
        values = decodeValues_DECIMAL(cursor, count, opts);
      } else {
        for (let i = 0; i < count; ++i) {
          values.push(cursor.buffer.readInt32LE(cursor.offset));
          cursor.offset += 4;
        }
      }
    } catch (e2) {
      console.log(`Error thrown for column: ${name}`);
      throw e2;
    }
    return values;
  }
  function encodeValues_INT64(values, opts) {
    const isDecimal = opts?.originalType === "DECIMAL" || opts?.column?.originalType === "DECIMAL";
    const scale = opts?.scale || 0;
    const buf = Buffer2.alloc(8 * values.length);
    for (let i = 0; i < values.length; i++) {
      if (isDecimal) {
        buf.writeBigInt64LE(BigInt(Math.floor(values[i] * Math.pow(10, scale))), i * 8);
      } else {
        buf.writeBigInt64LE(BigInt(values[i]), i * 8);
      }
    }
    return buf;
  }
  function decodeValues_INT64(cursor, count, opts) {
    let values = [];
    const name = opts.name || opts.column?.name || void 0;
    try {
      if (opts.originalType === "DECIMAL" || opts.column?.originalType === "DECIMAL") {
        const columnOptions = opts.column?.originalType ? opts.column : opts;
        values = decodeValues_DECIMAL(cursor, count, columnOptions);
      } else {
        for (let i = 0; i < count; ++i) {
          values.push(cursor.buffer.readBigInt64LE(cursor.offset));
          cursor.offset += 8;
        }
      }
    } catch (e2) {
      console.log(`Error thrown for column: ${name}`);
      throw e2;
    }
    return values;
  }
  function decodeValues_DECIMAL(cursor, count, opts) {
    const precision = opts.precision;
    const scale = opts.scale || 0;
    const name = opts.name || void 0;
    if (!precision) {
      throw `missing option: precision (required for DECIMAL) for column: ${name}`;
    }
    const values = [];
    let offset = 4;
    let bufferFunction = (offset2) => cursor.buffer.readInt32LE(offset2);
    if (precision > 9) {
      offset = 8;
      bufferFunction = (offset2) => cursor.buffer.readBigInt64LE(offset2);
    }
    for (let i = 0; i < count; ++i) {
      const bufferSize = cursor.size || 0;
      if (bufferSize === 0 || cursor.offset < bufferSize) {
        const fullValue = bufferFunction(cursor.offset);
        const valueWithDecimalApplied = Number(fullValue) / Math.pow(10, scale);
        values.push(valueWithDecimalApplied);
        cursor.offset += offset;
      }
    }
    return values;
  }
  function encodeValues_INT96(values) {
    const buf = Buffer2.alloc(12 * values.length);
    for (let i = 0; i < values.length; i++) {
      if (values[i] >= 0) {
        import_int53.default.writeInt64LE(values[i], buf, i * 12);
        buf.writeUInt32LE(0, i * 12 + 8);
      } else {
        import_int53.default.writeInt64LE(~-values[i] + 1, buf, i * 12);
        buf.writeUInt32LE(4294967295, i * 12 + 8);
      }
    }
    return buf;
  }
  function decodeValues_INT96(cursor, count) {
    const values = [];
    for (let i = 0; i < count; ++i) {
      const low = import_int53.default.readInt64LE(cursor.buffer, cursor.offset);
      const high = cursor.buffer.readUInt32LE(cursor.offset + 8);
      if (high === 4294967295) {
        values.push(~-low + 1);
      } else {
        values.push(low);
      }
      cursor.offset += 12;
    }
    return values;
  }
  function encodeValues_FLOAT(values) {
    const buf = Buffer2.alloc(4 * values.length);
    for (let i = 0; i < values.length; i++) {
      buf.writeFloatLE(values[i], i * 4);
    }
    return buf;
  }
  function decodeValues_FLOAT(cursor, count) {
    const values = [];
    for (let i = 0; i < count; ++i) {
      values.push(cursor.buffer.readFloatLE(cursor.offset));
      cursor.offset += 4;
    }
    return values;
  }
  function encodeValues_DOUBLE(values) {
    const buf = Buffer2.alloc(8 * values.length);
    for (let i = 0; i < values.length; i++) {
      buf.writeDoubleLE(values[i], i * 8);
    }
    return buf;
  }
  function decodeValues_DOUBLE(cursor, count) {
    const values = [];
    for (let i = 0; i < count; ++i) {
      values.push(cursor.buffer.readDoubleLE(cursor.offset));
      cursor.offset += 8;
    }
    return values;
  }
  function encodeValues_BYTE_ARRAY(values) {
    let buf_len = 0;
    const returnedValues = [];
    for (let i = 0; i < values.length; i++) {
      returnedValues[i] = Buffer2.from(values[i]);
      buf_len += 4 + returnedValues[i].length;
    }
    const buf = Buffer2.alloc(buf_len);
    let buf_pos = 0;
    for (let i = 0; i < returnedValues.length; i++) {
      buf.writeUInt32LE(returnedValues[i].length, buf_pos);
      returnedValues[i].copy(buf, buf_pos + 4);
      buf_pos += 4 + returnedValues[i].length;
    }
    return buf;
  }
  function decodeValues_BYTE_ARRAY(cursor, count) {
    const values = [];
    for (let i = 0; i < count; ++i) {
      const len = cursor.buffer.readUInt32LE(cursor.offset);
      cursor.offset += 4;
      values.push(cursor.buffer.subarray(cursor.offset, cursor.offset + len));
      cursor.offset += len;
    }
    return values;
  }
  function encodeValues_FIXED_LEN_BYTE_ARRAY(values, opts) {
    if (!opts.typeLength) {
      throw "missing option: typeLength (required for FIXED_LEN_BYTE_ARRAY)";
    }
    const returnedValues = [];
    for (let i = 0; i < values.length; i++) {
      returnedValues[i] = Buffer2.from(values[i]);
      if (returnedValues[i].length !== opts.typeLength) {
        throw "invalid value for FIXED_LEN_BYTE_ARRAY: " + returnedValues[i];
      }
    }
    return Buffer2.concat(returnedValues);
  }
  function decodeValues_FIXED_LEN_BYTE_ARRAY(cursor, count, opts) {
    const values = [];
    const typeLength = opts.typeLength ?? (opts.column ? opts.column.typeLength : void 0);
    if (!typeLength) {
      throw "missing option: typeLength (required for FIXED_LEN_BYTE_ARRAY)";
    }
    for (let i = 0; i < count; ++i) {
      values.push(cursor.buffer.subarray(cursor.offset, cursor.offset + typeLength));
      cursor.offset += typeLength;
    }
    return values;
  }
  var encodeValues = function(type, values, opts) {
    switch (type) {
      case "BOOLEAN":
        return encodeValues_BOOLEAN(values);
      case "INT32":
        return encodeValues_INT32(values, opts);
      case "INT64":
        return encodeValues_INT64(values, opts);
      case "INT96":
        return encodeValues_INT96(values);
      case "FLOAT":
        return encodeValues_FLOAT(values);
      case "DOUBLE":
        return encodeValues_DOUBLE(values);
      case "BYTE_ARRAY":
        return encodeValues_BYTE_ARRAY(values);
      case "FIXED_LEN_BYTE_ARRAY":
        return encodeValues_FIXED_LEN_BYTE_ARRAY(values, opts);
      default:
        throw "unsupported type: " + type;
    }
  };
  var decodeValues = function(type, cursor, count, opts) {
    switch (type) {
      case "BOOLEAN":
        return decodeValues_BOOLEAN(cursor, count);
      case "INT32":
        return decodeValues_INT32(cursor, count, opts);
      case "INT64":
        return decodeValues_INT64(cursor, count, opts);
      case "INT96":
        return decodeValues_INT96(cursor, count);
      case "FLOAT":
        return decodeValues_FLOAT(cursor, count);
      case "DOUBLE":
        return decodeValues_DOUBLE(cursor, count);
      case "BYTE_ARRAY":
        return decodeValues_BYTE_ARRAY(cursor, count);
      case "FIXED_LEN_BYTE_ARRAY":
        return decodeValues_FIXED_LEN_BYTE_ARRAY(cursor, count, opts);
      default:
        throw "unsupported type: " + type;
    }
  };

  // lib/codec/rle.ts
  var rle_exports = {};
  __export(rle_exports, {
    decodeValues: () => decodeValues2,
    encodeValues: () => encodeValues2
  });
  init_esbuild_shims();
  var import_varint = __toESM(require_varint());
  function encodeRunBitpacked(values, opts) {
    for (let i = 0; i < values.length % 8; i++) {
      values.push(0);
    }
    const buf = Buffer2.alloc(Math.ceil(opts.bitWidth * (values.length / 8)));
    for (let b = 0; b < opts.bitWidth * values.length; ++b) {
      if ((values[Math.floor(b / opts.bitWidth)] & 1 << b % opts.bitWidth) > 0) {
        buf[Math.floor(b / 8)] |= 1 << b % 8;
      }
    }
    return Buffer2.concat([Buffer2.from(import_varint.default.encode(values.length / 8 << 1 | 1)), buf]);
  }
  function encodeRunRepeated(value, count, opts) {
    const buf = Buffer2.alloc(Math.ceil(opts.bitWidth / 8));
    let remainingValue = value;
    for (let i = 0; i < buf.length; ++i) {
      buf.writeUInt8(remainingValue & 255, i);
      remainingValue = remainingValue >> 8;
    }
    return Buffer2.concat([Buffer2.from(import_varint.default.encode(count << 1)), buf]);
  }
  function unknownToParsedInt(value) {
    if (typeof value === "string") {
      return parseInt(value, 10);
    } else {
      return value;
    }
  }
  var encodeValues2 = function(type, values, opts) {
    if (!("bitWidth" in opts)) {
      throw "bitWidth is required";
    }
    switch (type) {
      case "BOOLEAN":
      case "INT32":
      case "INT64":
        values = values.map((x) => unknownToParsedInt(x));
        break;
      default:
        throw "unsupported type: " + type;
    }
    let buf = Buffer2.alloc(0);
    let run = [];
    let repeats = 0;
    for (let i = 0; i < values.length; i++) {
      if (repeats === 0 && run.length % 8 === 0 && values[i] === values[i + 1]) {
        if (run.length) {
          buf = Buffer2.concat([buf, encodeRunBitpacked(run, opts)]);
          run = [];
        }
        repeats = 1;
      } else if (repeats > 0 && values[i] === values[i - 1]) {
        repeats += 1;
      } else {
        if (repeats) {
          buf = Buffer2.concat([buf, encodeRunRepeated(values[i - 1], repeats, opts)]);
          repeats = 0;
        }
        run.push(values[i]);
      }
    }
    if (repeats) {
      buf = Buffer2.concat([buf, encodeRunRepeated(values[values.length - 1], repeats, opts)]);
    } else if (run.length) {
      buf = Buffer2.concat([buf, encodeRunBitpacked(run, opts)]);
    }
    if (opts.disableEnvelope) {
      return buf;
    }
    const envelope = Buffer2.alloc(buf.length + 4);
    envelope.writeUInt32LE(buf.length);
    buf.copy(envelope, 4);
    return envelope;
  };
  function decodeRunBitpacked(cursor, count, opts) {
    if (count % 8 !== 0) {
      throw "must be a multiple of 8";
    }
    const values = new Array(count).fill(0);
    for (let b = 0; b < opts.bitWidth * count; ++b) {
      if (cursor.buffer[cursor.offset + Math.floor(b / 8)] & 1 << b % 8) {
        values[Math.floor(b / opts.bitWidth)] |= 1 << b % opts.bitWidth;
      }
    }
    cursor.offset += opts.bitWidth * (count / 8);
    return values;
  }
  function decodeRunRepeated(cursor, count, opts) {
    const bytesNeededForFixedBitWidth = Math.ceil(opts.bitWidth / 8);
    let value = 0;
    for (let i = 0; i < bytesNeededForFixedBitWidth; ++i) {
      const byte = cursor.buffer[cursor.offset];
      value += byte << i * 8;
      cursor.offset += 1;
    }
    return new Array(count).fill(value);
  }
  var decodeValues2 = function(_, cursor, count, opts) {
    if (!("bitWidth" in opts)) {
      throw "bitWidth is required";
    }
    if (!opts.disableEnvelope) {
      cursor.offset += 4;
    }
    let values = [];
    let res;
    while (values.length < count) {
      const header = import_varint.default.decode(cursor.buffer, cursor.offset);
      cursor.offset += import_varint.default.encodingLength(header);
      if (header & 1) {
        res = decodeRunBitpacked(cursor, (header >> 1) * 8, opts);
      } else {
        res = decodeRunRepeated(cursor, header >> 1, opts);
      }
      for (let i = 0; i < res.length; i++) {
        values.push(res[i]);
      }
    }
    values = values.slice(0, count);
    if (values.length !== count) {
      throw "invalid RLE encoding";
    }
    return values;
  };

  // lib/codec/plain_dictionary.ts
  var plain_dictionary_exports = {};
  __export(plain_dictionary_exports, {
    decodeValues: () => decodeValues3
  });
  init_esbuild_shims();
  var decodeValues3 = function(type, cursor, count, opts) {
    const bitWidth = cursor.buffer.subarray(cursor.offset, cursor.offset + 1).readInt8(0);
    cursor.offset += 1;
    return decodeValues2(type, cursor, count, Object.assign({}, opts, { disableEnvelope: true, bitWidth }));
  };

  // lib/browser/compression.ts
  init_esbuild_shims();
  var import_snappyjs = __toESM(require_snappyjs());
  var import_brotli_wasm = __toESM(require_index_browser());
  var PARQUET_COMPRESSION_METHODS = {
    UNCOMPRESSED: {
      deflate: deflate_identity,
      inflate: inflate_identity
    },
    GZIP: {
      deflate: deflate_gzip,
      inflate: inflate_gzip
    },
    SNAPPY: {
      deflate: deflate_snappy,
      inflate: inflate_snappy
    },
    BROTLI: {
      deflate: deflate_brotli,
      inflate: inflate_brotli
    }
  };
  async function deflate(method, value) {
    if (!(method in PARQUET_COMPRESSION_METHODS)) {
      throw "invalid compression method: " + method;
    }
    return PARQUET_COMPRESSION_METHODS[method].deflate(value);
  }
  function deflate_identity(value) {
    return buffer_from_result(value);
  }
  async function deflate_gzip(value) {
    const cs = new CompressionStream("gzip");
    const pipedCs = new Response(value).body?.pipeThrough(cs);
    return buffer_from_result(await new Response(pipedCs).arrayBuffer());
  }
  function deflate_snappy(value) {
    const compressedValue = import_snappyjs.default.compress(value);
    return buffer_from_result(compressedValue);
  }
  async function deflate_brotli(value) {
    const brotli = await import_brotli_wasm.default;
    return buffer_from_result(brotli.compress(value));
  }
  async function inflate(method, value) {
    if (!(method in PARQUET_COMPRESSION_METHODS)) {
      throw "invalid compression method: " + method;
    }
    return await PARQUET_COMPRESSION_METHODS[method].inflate(value);
  }
  async function inflate_identity(value) {
    return buffer_from_result(value);
  }
  async function inflate_gzip(value) {
    const ds = new DecompressionStream("gzip");
    const pipedDs = new Response(value).body?.pipeThrough(ds);
    return buffer_from_result(await new Response(pipedDs).arrayBuffer());
  }
  function inflate_snappy(value) {
    const uncompressedValue = import_snappyjs.default.uncompress(value);
    return buffer_from_result(uncompressedValue);
  }
  async function inflate_brotli(value) {
    const brotli = await import_brotli_wasm.default;
    return buffer_from_result(brotli.decompress(value));
  }
  function buffer_from_result(result) {
    if (Buffer2.isBuffer(result)) {
      return result;
    } else {
      return Buffer2.from(result);
    }
  }

  // lib/jsonSchema.ts
  init_esbuild_shims();

  // lib/fields.ts
  var fields_exports = {};
  __export(fields_exports, {
    createBooleanField: () => createBooleanField,
    createDecimalField: () => createDecimalField,
    createDoubleField: () => createDoubleField,
    createFloatField: () => createFloatField,
    createIntField: () => createIntField,
    createListField: () => createListField,
    createStringField: () => createStringField,
    createStructField: () => createStructField,
    createStructListField: () => createStructListField,
    createTimestampField: () => createTimestampField
  });
  init_esbuild_shims();
  function createStringField(optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: "UTF8" };
  }
  function createBooleanField(optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: "BOOLEAN" };
  }
  function createIntField(size, optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: `INT${size}` };
  }
  function createFloatField(optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: "FLOAT" };
  }
  function createDoubleField(optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: "DOUBLE" };
  }
  function createDecimalField(precision, optional = true, fieldOptions = {}) {
    return { ...fieldOptions, precision, optional, type: "FLOAT" };
  }
  function createTimestampField(optional = true, fieldOptions = {}) {
    return { ...fieldOptions, optional, type: "TIMESTAMP_MILLIS" };
  }
  function createStructField(fields, optional = true) {
    return {
      optional,
      fields
    };
  }
  function createStructListField(fields, optional = true) {
    return {
      type: "LIST",
      optional,
      fields: {
        list: {
          repeated: true,
          fields: {
            element: {
              fields
            }
          }
        }
      }
    };
  }
  function createListField(type, optional = true, elementOptions = { optional: true }) {
    return {
      type: "LIST",
      optional,
      fields: {
        list: {
          repeated: true,
          fields: {
            element: {
              optional: true,
              ...elementOptions,
              type
            }
          }
        }
      }
    };
  }

  // lib/jsonSchema.ts
  var isJsonSchemaSupported = (js) => {
    const unsupportedFields = [
      "$ref",
      "multipleOf",
      "allOf",
      "anyOf",
      "oneOf",
      "not",
      "additionalItems",
      "enum",
      "extends"
    ];
    for (const field in unsupportedFields) {
      if (!(js[field] === void 0 || js[field] === false)) {
        return false;
      }
    }
    return true;
  };
  var UnsupportedJsonSchemaError = class extends Error {
    constructor(msg) {
      const message = `Unsupported JSON schema: ${msg}`;
      super(message);
      this.name = "UnsupportedJsonSchemaError";
    }
  };
  var isJsonSchemaRequired = (jsonSchema) => (field) => {
    switch (jsonSchema.required) {
      case true:
        return true;
      case void 0:
      case false:
        return false;
    }
    return jsonSchema.required.includes(field);
  };
  var fromJsonSchemaArray = (fieldValue, optionalFieldList) => {
    if (!fieldValue.items || !fieldValue.items.type) {
      throw new UnsupportedJsonSchemaError("Array field with no values found.");
    }
    switch (fieldValue.items.type) {
      case "string":
        if (fieldValue.items.format && fieldValue.items.format == "date-time") {
          return createListField("TIMESTAMP_MILLIS", optionalFieldList);
        }
        return createListField("UTF8", optionalFieldList);
      case "integer":
        return createListField("INT64", optionalFieldList);
      case "number":
        return createListField("DOUBLE", optionalFieldList);
      case "boolean":
        return createListField("BOOLEAN", optionalFieldList);
      case "object":
        return createStructListField(fromJsonSchema(fieldValue.items), optionalFieldList);
      default:
        throw new UnsupportedJsonSchemaError(`Array field type ${JSON.stringify(fieldValue.items)} is unsupported.`);
    }
  };
  var fromJsonSchemaField = (jsonSchema) => (fieldName, fieldValue) => {
    if (!isJsonSchemaSupported(fieldValue)) {
      throw new UnsupportedJsonSchemaError(`Field: ${fieldName} has an unsupported schema`);
    }
    const optional = !isJsonSchemaRequired(jsonSchema)(fieldName);
    switch (fieldValue.type) {
      case "string":
        if (fieldValue.format && fieldValue.format == "date-time") {
          return createTimestampField(optional);
        }
        return createStringField(optional);
      case "integer":
        return createIntField(64, optional);
      case "number":
        return createDoubleField(optional);
      case "boolean":
        return createBooleanField(optional);
      case "array":
        return fromJsonSchemaArray(fieldValue, optional);
      case "object":
        return createStructField(fromJsonSchema(fieldValue), optional);
      default:
        throw new UnsupportedJsonSchemaError(
          `Unable to convert "${fieldName}" with JSON Schema type "${fieldValue.type}" to a Parquet Schema.`
        );
    }
  };
  var fromJsonSchema = (jsonSchema) => {
    if (!isJsonSchemaSupported(jsonSchema)) {
      throw new UnsupportedJsonSchemaError("Unsupported fields found");
    }
    const schema = {};
    const fromField = fromJsonSchemaField(jsonSchema);
    for (const [fieldName, fieldValue] of Object.entries(jsonSchema.properties || {})) {
      schema[fieldName] = fromField(fieldName, fieldValue);
    }
    return schema;
  };

  // lib/schema.ts
  var ParquetSchema = class _ParquetSchema {
    schema;
    fields;
    fieldList;
    /**
     * Create a new schema from JSON Schema (json-schema.org)
     */
    static fromJsonSchema(jsonSchema) {
      const schema = fromJsonSchema(jsonSchema);
      return new _ParquetSchema(schema);
    }
    /**
     * Create a new schema from a JSON schema definition
     */
    constructor(schema) {
      this.schema = schema;
      this.fields = buildFields(schema);
      this.fieldList = listFields(this.fields);
    }
    /**
     * Retrieve a field definition
     */
    findField(path) {
      if (typeof path === "string") {
        path = path.split(",");
      } else {
        path = path.slice(0);
      }
      let n = this.fields;
      for (; path.length > 1; path.shift()) {
        const fields = n[path[0]]?.fields;
        if (isDefined2(fields)) {
          n = fields;
        }
      }
      return n[path[0]];
    }
    /**
     * Retrieve a field definition and all the field's ancestors
     */
    findFieldBranch(path) {
      if (typeof path === "string") {
        path = path.split(",");
      }
      const branch = [];
      let n = this.fields;
      for (; path.length > 0; path.shift()) {
        branch.push(n[path[0]]);
        const fields = n[path[0]].fields;
        if (path.length > 1 && isDefined2(fields)) {
          n = fields;
        }
      }
      return branch;
    }
  };
  function buildFields(schema, rLevelParentMax, dLevelParentMax, path) {
    if (!rLevelParentMax) {
      rLevelParentMax = 0;
    }
    if (!dLevelParentMax) {
      dLevelParentMax = 0;
    }
    if (!path) {
      path = [];
    }
    const fieldList = {};
    let fieldErrors = [];
    for (const name in schema) {
      const opts = schema[name];
      const required = !opts.optional;
      const repeated = !!opts.repeated;
      let rLevelMax = rLevelParentMax;
      let dLevelMax = dLevelParentMax;
      let repetitionType = "REQUIRED";
      if (!required) {
        repetitionType = "OPTIONAL";
        ++dLevelMax;
      }
      if (repeated) {
        repetitionType = "REPEATED";
        ++rLevelMax;
        if (required) {
          ++dLevelMax;
        }
      }
      if (opts.fields) {
        fieldList[name] = {
          name,
          path: path.concat(name),
          repetitionType,
          rLevelMax,
          dLevelMax,
          isNested: true,
          statistics: opts.statistics,
          fieldCount: Object.keys(opts.fields).length,
          fields: buildFields(opts.fields, rLevelMax, dLevelMax, path.concat(name))
        };
        if (opts.type == "LIST" || opts.type == "MAP") fieldList[name].originalType = opts.type;
        continue;
      }
      let nameWithPath = `${name}` || "missing name";
      if (path && path.length > 0) {
        nameWithPath = `${path}.${nameWithPath}`;
      }
      const typeDef = opts.type ? getParquetTypeDataObject(opts.type, opts) : void 0;
      if (!typeDef) {
        fieldErrors.push(`Invalid parquet type: ${opts.type || "missing type"}, for Column: ${nameWithPath}`);
        continue;
      }
      if (!opts.encoding) {
        opts.encoding = "PLAIN";
      }
      if (!(opts.encoding in codec_exports)) {
        fieldErrors.push(`Unsupported parquet encoding: ${opts.encoding}, for Column: ${nameWithPath}`);
      }
      if (!opts.compression) {
        opts.compression = "UNCOMPRESSED";
      }
      if (!(opts.compression in PARQUET_COMPRESSION_METHODS)) {
        fieldErrors.push(`Unsupported compression method: ${opts.compression}, for Column: ${nameWithPath}`);
      }
      if (typeDef.originalType === "DECIMAL") {
        if (typeof opts.scale === "undefined") opts.scale = 0;
        fieldErrors = fieldErrors.concat(
          errorsForDecimalOpts(typeDef.originalType, typeDef.primitiveType, opts, nameWithPath)
        );
      }
      fieldList[name] = {
        name,
        primitiveType: typeDef.primitiveType,
        originalType: typeDef.originalType,
        path: path.concat([name]),
        repetitionType,
        encoding: opts.encoding,
        statistics: opts.statistics,
        compression: opts.compression,
        precision: opts.precision,
        scale: opts.scale,
        typeLength: opts.typeLength || typeDef.typeLength,
        rLevelMax,
        dLevelMax
      };
    }
    if (fieldErrors.length > 0) {
      throw fieldErrors.reduce((accumulator, currentVal) => accumulator + "\n" + currentVal);
    }
    return fieldList;
  }
  function listFields(fields) {
    let list = [];
    for (const k in fields) {
      list.push(fields[k]);
      const nestedFields = fields[k].fields;
      if (fields[k].isNested && isDefined2(nestedFields)) {
        list = list.concat(listFields(nestedFields));
      }
    }
    return list;
  }
  function isDefined2(val2) {
    return val2 !== void 0;
  }
  function errorsForDecimalOpts(type, primitiveType, opts, columnName) {
    const fieldErrors = [];
    if (opts.precision === void 0 || opts.precision < 1) {
      fieldErrors.push(
        `invalid schema for type: ${type}, for Column: ${columnName}, precision is required and must be be greater than 0`
      );
    } else if (!Number.isInteger(opts.precision)) {
      fieldErrors.push(`invalid schema for type: ${type}, for Column: ${columnName}, precision must be an integer`);
    } else if (primitiveType === "INT64" && opts.precision > 18) {
      fieldErrors.push(
        `invalid schema for type: ${type} and primitive type: ${primitiveType} for Column: ${columnName}, can not handle precision over 18`
      );
    }
    if (typeof opts.scale === "undefined" || opts.scale < 0) {
      fieldErrors.push(
        `invalid schema for type: ${type}, for Column: ${columnName}, scale is required to be 0 or greater`
      );
    } else if (!Number.isInteger(opts.scale)) {
      fieldErrors.push(`invalid schema for type: ${type}, for Column: ${columnName}, scale must be an integer`);
    } else if (opts.precision !== void 0 && opts.scale > opts.precision) {
      fieldErrors.push(
        `invalid schema or precision for type: ${type}, for Column: ${columnName}, precision must be greater than or equal to scale`
      );
    }
    return fieldErrors;
  }

  // lib/bufferReader.ts
  init_esbuild_shims();
  var BufferReader = class {
    maxSpan;
    maxLength;
    queueWait;
    scheduled;
    queue;
    envelopeReader;
    constructor(envelopeReader, options) {
      options = options || {};
      this.envelopeReader = envelopeReader;
      this.maxSpan = options.maxSpan || 1e5;
      this.maxLength = options.maxLength || 1e7;
      this.queueWait = options.queueWait || 5;
      this.scheduled = void 0;
      this.queue = [];
    }
    read(offset, length) {
      if (!this.scheduled) {
        this.scheduled = true;
        setTimeout(() => {
          this.scheduled = false;
          this.processQueue();
        }, this.queueWait);
      }
      return new Promise((resolve2, reject) => {
        this.queue.push({ offset, length, resolve: resolve2, reject });
      });
    }
    async processQueue() {
      const queue = this.queue;
      if (!queue.length) return;
      this.queue = [];
      queue.sort((a, b) => a.offset - b.offset);
      let subqueue = [];
      const readSubqueue = async () => {
        if (!subqueue.length) {
          return;
        }
        const processQueue = subqueue;
        subqueue = [];
        const lastElement = processQueue[processQueue.length - 1];
        const start = processQueue[0].offset;
        const finish = lastElement.offset + lastElement.length;
        const buffer2 = await this.envelopeReader.readFn(start, finish - start);
        processQueue.forEach(async (d) => {
          d.resolve(buffer2.subarray(d.offset - start, d.offset + d.length - start));
        });
      };
      queue.forEach((d, i) => {
        const prev = queue[i - 1];
        if (!prev || d.offset - (prev.offset + prev.length) < this.maxSpan) {
          subqueue.push(d);
          if (d.offset + d.length - subqueue[0].offset > this.maxLength) {
            readSubqueue();
          }
        } else {
          readSubqueue();
          subqueue = [d];
        }
      });
      readSubqueue();
    }
  };

  // lib/bloomFilterIO/bloomFilterReader.ts
  var bloomFilterReader_exports = {};
  __export(bloomFilterReader_exports, {
    getBloomFiltersFor: () => getBloomFiltersFor,
    parseBloomFilterOffsets: () => parseBloomFilterOffsets,
    siftAllByteOffsets: () => siftAllByteOffsets
  });
  init_esbuild_shims();
  var import_parquet_types2 = __toESM(require_parquet_types());

  // lib/bloom/sbbf.ts
  init_esbuild_shims();
  var import_parquet_types = __toESM(require_parquet_types());

  // node_modules/long/index.js
  init_esbuild_shims();
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e2) {
  }
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long.fromString = fromString;
  function fromValue(val2, unsigned) {
    if (typeof val2 === "number")
      return fromNumber(val2, unsigned);
    if (typeof val2 === "string")
      return fromString(val2, unsigned);
    return fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
  }
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE = fromInt(1);
  Long.ONE = ONE;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val2 = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val2 & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  var long_default = Long;

  // lib/bloom/xxhasher.ts
  init_esbuild_shims();

  // node_modules/xxhash-wasm/esm/xxhash-wasm.js
  init_esbuild_shims();
  var t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 48, 8, 96, 3, 127, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 96, 2, 127, 127, 0, 96, 2, 127, 126, 0, 96, 1, 127, 1, 127, 96, 1, 127, 1, 126, 96, 3, 127, 127, 126, 1, 126, 96, 3, 126, 127, 127, 1, 126, 3, 11, 10, 1, 1, 2, 0, 4, 6, 7, 3, 0, 5, 5, 3, 1, 0, 1, 7, 85, 9, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 6, 105, 110, 105, 116, 51, 50, 0, 2, 8, 117, 112, 100, 97, 116, 101, 51, 50, 0, 3, 8, 100, 105, 103, 101, 115, 116, 51, 50, 0, 4, 5, 120, 120, 104, 54, 52, 0, 5, 6, 105, 110, 105, 116, 54, 52, 0, 7, 8, 117, 112, 100, 97, 116, 101, 54, 52, 0, 8, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 9, 10, 211, 23, 10, 242, 1, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 3, 32, 2, 65, 247, 148, 175, 175, 120, 106, 33, 4, 32, 2, 65, 177, 243, 221, 241, 121, 107, 33, 5, 3, 64, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 3, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 4, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 2, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 5, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 0, 65, 4, 106, 34, 0, 32, 6, 77, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 3, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 32, 1, 106, 32, 0, 32, 1, 65, 15, 113, 16, 1, 11, 146, 1, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 4, 106, 32, 2, 75, 69, 4, 64, 32, 1, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 32, 0, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 0, 32, 1, 65, 4, 106, 33, 1, 12, 1, 11, 11, 3, 64, 32, 1, 32, 2, 79, 69, 4, 64, 32, 1, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 32, 0, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 65, 15, 118, 32, 0, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 32, 0, 65, 13, 118, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 32, 0, 65, 16, 118, 115, 11, 63, 0, 32, 0, 65, 8, 106, 32, 1, 65, 168, 136, 141, 161, 2, 106, 54, 2, 0, 32, 0, 65, 12, 106, 32, 1, 65, 247, 148, 175, 175, 120, 106, 54, 2, 0, 32, 0, 65, 16, 106, 32, 1, 54, 2, 0, 32, 0, 65, 20, 106, 32, 1, 65, 177, 243, 221, 241, 121, 107, 54, 2, 0, 11, 211, 4, 1, 6, 127, 32, 1, 32, 2, 106, 33, 6, 32, 0, 65, 24, 106, 33, 5, 32, 0, 65, 40, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 40, 2, 0, 32, 2, 106, 54, 2, 0, 32, 0, 65, 4, 106, 34, 4, 32, 4, 40, 2, 0, 32, 2, 65, 16, 79, 32, 0, 40, 2, 0, 65, 16, 79, 114, 114, 54, 2, 0, 32, 2, 32, 3, 106, 65, 16, 73, 4, 64, 32, 3, 32, 5, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 5, 106, 32, 1, 65, 16, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 40, 2, 0, 32, 5, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 12, 106, 34, 3, 40, 2, 0, 32, 5, 65, 4, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 16, 106, 34, 3, 40, 2, 0, 32, 5, 65, 8, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 20, 106, 34, 3, 40, 2, 0, 32, 5, 65, 12, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 40, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 32, 6, 65, 16, 107, 77, 4, 64, 32, 6, 65, 16, 107, 33, 8, 32, 0, 65, 8, 106, 40, 2, 0, 33, 2, 32, 0, 65, 12, 106, 40, 2, 0, 33, 3, 32, 0, 65, 16, 106, 40, 2, 0, 33, 4, 32, 0, 65, 20, 106, 40, 2, 0, 33, 7, 3, 64, 32, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 2, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 3, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 4, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 7, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 7, 32, 1, 65, 4, 106, 34, 1, 32, 8, 77, 13, 0, 11, 32, 0, 65, 8, 106, 32, 2, 54, 2, 0, 32, 0, 65, 12, 106, 32, 3, 54, 2, 0, 32, 0, 65, 16, 106, 32, 4, 54, 2, 0, 32, 0, 65, 20, 106, 32, 7, 54, 2, 0, 11, 32, 1, 32, 6, 73, 4, 64, 32, 5, 32, 1, 32, 6, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 1, 54, 2, 0, 11, 11, 97, 1, 1, 127, 32, 0, 65, 16, 106, 40, 2, 0, 33, 1, 32, 0, 65, 4, 106, 40, 2, 0, 4, 127, 32, 1, 65, 12, 119, 32, 0, 65, 20, 106, 40, 2, 0, 65, 18, 119, 106, 32, 0, 65, 12, 106, 40, 2, 0, 65, 7, 119, 106, 32, 0, 65, 8, 106, 40, 2, 0, 65, 1, 119, 106, 5, 32, 1, 65, 177, 207, 217, 178, 1, 106, 11, 32, 0, 40, 2, 0, 106, 32, 0, 65, 24, 106, 32, 0, 65, 40, 106, 40, 2, 0, 16, 1, 11, 157, 4, 2, 1, 127, 3, 126, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 32, 79, 4, 126, 32, 3, 65, 32, 107, 33, 3, 32, 2, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 124, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 33, 4, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 33, 5, 32, 2, 66, 0, 124, 33, 6, 32, 2, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 125, 33, 2, 3, 64, 32, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 4, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 5, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 6, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 2, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 0, 65, 8, 106, 34, 0, 32, 3, 77, 13, 0, 11, 32, 6, 66, 12, 137, 32, 2, 66, 18, 137, 124, 32, 5, 66, 7, 137, 124, 32, 4, 66, 1, 137, 124, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 6, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 32, 0, 32, 1, 65, 31, 113, 16, 6, 11, 137, 2, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 8, 106, 32, 2, 77, 4, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 33, 0, 32, 1, 65, 8, 106, 33, 1, 12, 1, 11, 11, 32, 1, 65, 4, 106, 32, 2, 77, 4, 64, 32, 1, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 0, 32, 1, 65, 4, 106, 33, 1, 11, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 1, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 32, 0, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 33, 136, 32, 0, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 0, 32, 0, 66, 29, 136, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 0, 32, 0, 66, 32, 136, 133, 11, 88, 0, 32, 0, 65, 8, 106, 32, 1, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 124, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 55, 3, 0, 32, 0, 65, 16, 106, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 55, 3, 0, 32, 0, 65, 24, 106, 32, 1, 55, 3, 0, 32, 0, 65, 32, 106, 32, 1, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 125, 55, 3, 0, 11, 132, 5, 2, 3, 127, 4, 126, 32, 1, 32, 2, 106, 33, 5, 32, 0, 65, 40, 106, 33, 4, 32, 0, 65, 200, 0, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 41, 3, 0, 32, 2, 173, 124, 55, 3, 0, 32, 2, 32, 3, 106, 65, 32, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 32, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 41, 3, 0, 32, 4, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 34, 3, 41, 3, 0, 32, 4, 65, 8, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 24, 106, 34, 3, 41, 3, 0, 32, 4, 65, 16, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 32, 106, 34, 3, 41, 3, 0, 32, 4, 65, 24, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 200, 0, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 65, 32, 106, 32, 5, 77, 4, 64, 32, 5, 65, 32, 107, 33, 2, 32, 0, 65, 8, 106, 41, 3, 0, 33, 6, 32, 0, 65, 16, 106, 41, 3, 0, 33, 7, 32, 0, 65, 24, 106, 41, 3, 0, 33, 8, 32, 0, 65, 32, 106, 41, 3, 0, 33, 9, 3, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 6, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 7, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 7, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 8, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 8, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 9, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 9, 32, 1, 65, 8, 106, 34, 1, 32, 2, 77, 13, 0, 11, 32, 0, 65, 8, 106, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 32, 7, 55, 3, 0, 32, 0, 65, 24, 106, 32, 8, 55, 3, 0, 32, 0, 65, 32, 106, 32, 9, 55, 3, 0, 11, 32, 1, 32, 5, 73, 4, 64, 32, 4, 32, 1, 32, 5, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 1, 54, 2, 0, 11, 11, 200, 2, 1, 5, 126, 32, 0, 65, 24, 106, 41, 3, 0, 33, 1, 32, 0, 41, 3, 0, 34, 2, 66, 32, 90, 4, 126, 32, 0, 65, 8, 106, 41, 3, 0, 34, 3, 66, 1, 137, 32, 0, 65, 16, 106, 41, 3, 0, 34, 4, 66, 7, 137, 124, 32, 1, 66, 12, 137, 32, 0, 65, 32, 106, 41, 3, 0, 34, 5, 66, 18, 137, 124, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 5, 32, 1, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 2, 124, 32, 0, 65, 40, 106, 32, 2, 66, 31, 131, 167, 16, 6, 11]);
  async function e() {
    const { instance: { exports: { mem: e2, xxh32: n, xxh64: r, init32: i, update32: o, digest32: h, init64: s, update64: u, digest64: g } } } = await WebAssembly.instantiate(t);
    let a = new Uint8Array(e2.buffer);
    function c(t2, n2) {
      if (e2.buffer.byteLength < t2 + n2) {
        const r2 = Math.ceil((t2 + n2 - e2.buffer.byteLength) / 65536);
        e2.grow(r2), a = new Uint8Array(e2.buffer);
      }
    }
    function l(t2, e3, n2, r2, i2, o2) {
      c(t2);
      const h2 = new Uint8Array(t2);
      return a.set(h2), n2(0, e3), h2.set(a.slice(0, t2)), { update(e4) {
        let n3;
        return a.set(h2), "string" == typeof e4 ? (c(3 * e4.length, t2), n3 = b.encodeInto(e4, a.subarray(t2)).written) : (c(e4.byteLength, t2), a.set(e4, t2), n3 = e4.byteLength), r2(0, t2, n3), h2.set(a.slice(0, t2)), this;
      }, digest: () => (a.set(h2), o2(i2(0))) };
    }
    function d(t2) {
      return t2 >>> 0;
    }
    const f = 2n ** 64n - 1n;
    function y(t2) {
      return t2 & f;
    }
    const b = new TextEncoder(), w = 0n;
    function p(t2) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return c(3 * t2.length, 0), d(n(0, b.encodeInto(t2, a).written, e3));
    }
    function v(t2) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : w;
      return c(3 * t2.length, 0), y(r(0, b.encodeInto(t2, a).written, e3));
    }
    return { h32: p, h32ToString(t2) {
      return p(t2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0).toString(16).padStart(8, "0");
    }, h32Raw(t2) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return c(t2.byteLength, 0), a.set(t2), d(n(0, t2.byteLength, e3));
    }, create32() {
      return l(48, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, i, o, h, d);
    }, h64: v, h64ToString(t2) {
      return v(t2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : w).toString(16).padStart(16, "0");
    }, h64Raw(t2) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : w;
      return c(t2.byteLength, 0), a.set(t2), y(r(0, t2.byteLength, e3));
    }, create64() {
      return l(88, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w, s, u, g, y);
    } };
  }

  // lib/bloom/xxhasher.ts
  var XxHasher = class _XxHasher {
    static h64 = e().then((x) => x.h64ToString);
    async hashIt(value) {
      return (await _XxHasher.h64)(value);
    }
    /**
     * @function hash64
     * @description creates a hash for certain data types. All data is converted using toString()
     * prior to hashing.
     * @return the 64 big XXHash as a hex-encoded string.
     * @param value, must be of type string, Buffer, Uint8Array, Long, boolean, number, or bigint
     */
    async hash64(value) {
      if (typeof value === "string") return this.hashIt(value);
      if (value instanceof Buffer2 || value instanceof Uint8Array || value instanceof long_default || typeof value === "boolean" || typeof value === "number" || typeof value === "bigint") {
        return this.hashIt(value.toString());
      }
      throw new Error("unsupported type: " + value);
    }
  };

  // lib/bloom/sbbf.ts
  var SplitBlockBloomFilter = class _SplitBlockBloomFilter {
    static salt = [
      1203114875,
      1150766481,
      2284105051,
      2729912477,
      1884591559,
      770785867,
      2667333959,
      1550580529
    ];
    // How many bits are in a single block:
    // - Blocks are UInt32 arrays
    // - There are 8 UInt32 words in each block.
    static WORDS_PER_BLOCK = 8;
    static WORD_SIZE = 32;
    static BITS_PER_BLOCK = _SplitBlockBloomFilter.WORDS_PER_BLOCK * _SplitBlockBloomFilter.WORD_SIZE;
    // Default number of blocks in a Split Block Bloom filter (SBBF)
    static NUMBER_OF_BLOCKS = 32;
    // The lower bound of SBBF size in bytes.
    // Currently this is 1024
    static LOWER_BOUND_BYTES = _SplitBlockBloomFilter.NUMBER_OF_BLOCKS * _SplitBlockBloomFilter.BITS_PER_BLOCK / 8;
    // The upper bound of SBBF size, set to default row group size in bytes.
    // Note that the subsquent requirements for an effective bloom filter on a row group this size would mean this
    // is unacceptably large for a lightweight client application.
    static UPPER_BOUND_BYTES = 128 * 1024 * 1024;
    static DEFAULT_FALSE_POSITIVE_RATE = 1e-3;
    static DEFAULT_DISTINCT_VALUES = 128 * 1024;
    /**
     * @function initBlock
     * @description initializes a single block
     */
    static initBlock() {
      return Uint32Array.from(Array(_SplitBlockBloomFilter.WORDS_PER_BLOCK).fill(0));
    }
    /**
     * @function from
     * @description initialize a SplitBlockBloomFilter for a single column row group
     * from the provided Buffer
     * @param buffer a NodeJs Buffer containing bloom filter data for a row group.
     */
    static from(buffer2, _rowCount) {
      if (buffer2.length === 0) {
        throw new Error("buffer is empty");
      }
      const chunkSize = _SplitBlockBloomFilter.WORDS_PER_BLOCK;
      const uint32sFromBuf = new Uint32Array(buffer2.buffer);
      const result = [];
      const length = uint32sFromBuf.length;
      for (let index = 0; index < length; index += chunkSize) {
        result.push(uint32sFromBuf.subarray(index, index + chunkSize));
      }
      const sb = new _SplitBlockBloomFilter();
      sb.splitBlockFilter = result;
      sb.numBlocks = result.length;
      sb.numDistinctValues = 0;
      sb.desiredFalsePositiveRate = 0;
      return sb;
    }
    /**
     * @function getBlockIndex: get a block index to insert a hash value for
     * @param h the hash from which to derive a block index (?)
     * @param z the number of blocks in the filter
     *
     * @return a number from 0 to z-1, inclusive
     */
    static getBlockIndex(h, z) {
      const zLong = long_default.fromNumber(z, true);
      const hTopBits = long_default.fromNumber(h.getHighBitsUnsigned(), true);
      return hTopBits.mul(zLong).shiftRightUnsigned(32).getLowBitsUnsigned();
    }
    /**
     * @function optimalNumOfBlocks
     *
     * @description Calculate optimal number of blocks, according to the number of distinct
     * values and false positive probability.  Using a Bloom filter calculator, the upper bound is
     * far too large for client applications. Sourced from:
     * https://github.com/apache/parquet-mr/blob/5608695f5777de1eb0899d9075ec9411cfdf31d3/parquet-column/src/main/java/org/apache/parquet/column/values/bloomfilter/BlockSplitBloomFilter.java#L285
     *
     * @param numDistinct The number of distinct values.
     * @param falsePositiveRate The false positive rate, a number between 0 and 1 exclusive
     *
     * @return number: number of bits of given n and p.
     */
    static optimalNumOfBlocks(numDistinct, falsePositiveRate) {
      let m = -8 * numDistinct / Math.log(1 - Math.pow(falsePositiveRate, 1 / 8));
      m = m + _SplitBlockBloomFilter.NUMBER_OF_BLOCKS - 1 & ~_SplitBlockBloomFilter.NUMBER_OF_BLOCKS;
      const upperShiftL3 = _SplitBlockBloomFilter.UPPER_BOUND_BYTES << 3;
      if (m > upperShiftL3 || m < 0) {
        m = upperShiftL3;
      }
      m = m + _SplitBlockBloomFilter.BITS_PER_BLOCK - 1 & ~_SplitBlockBloomFilter.BITS_PER_BLOCK;
      const lowerBoundShiftL3 = _SplitBlockBloomFilter.LOWER_BOUND_BYTES << 3;
      if (m < lowerBoundShiftL3) {
        m = lowerBoundShiftL3;
      }
      return Math.ceil(m / this.BITS_PER_BLOCK);
    }
    /**
     * @function mask
     * @description generate a mask block for a bloom filter block
     * @param hashValue: the hash value to generate the mask from
     * @private
     *
     * @return mask Block
     */
    static mask(hashValue) {
      const result = _SplitBlockBloomFilter.initBlock();
      for (let i = 0; i < result.length; i++) {
        const y = hashValue.getLowBitsUnsigned() * _SplitBlockBloomFilter.salt[i];
        result[i] = result[i] | 1 << (y >>> 27);
      }
      return result;
    }
    /**
     * @function blockInsert
     * @description insert a hash into a Bloom filter Block
     * @param b: the block to flip a bit for: is changed
     * @param hashValue: the hash value to insert into b
     * @private
     *
     * @return void
     */
    static blockInsert(b, hashValue) {
      const masked = this.mask(hashValue);
      for (let i = 0; i < masked.length; i++) {
        for (let j = 0; j < this.WORD_SIZE; j++) {
          const isSet = masked[i] & 2 ** j;
          if (isSet) {
            b[i] = b[i] | 2 ** j;
          }
        }
      }
    }
    /**
     * @function blockCheck
     * @description check if a hashValue exists for this filter
     * @param b: the block to check for inclusion
     * @param hashValue: the hash to check for  should be long
     * @private
     *
     * @return true if hashed item is __probably__ in the data set represented by this filter
     * @return false if it is __definitely not__ in the data set.
     */
    static blockCheck(b, hashValue) {
      const masked = this.mask(hashValue);
      for (let i = 0; i < masked.length; i++) {
        for (let j = 0; j < this.WORD_SIZE; j++) {
          const isSet = masked[i] & 2 ** j;
          if (isSet) {
            const match = b[i] & 2 ** j;
            if (!match) {
              return false;
            }
          }
        }
      }
      return true;
    }
    /**
     * Instance
     */
    splitBlockFilter = [];
    desiredFalsePositiveRate = _SplitBlockBloomFilter.DEFAULT_FALSE_POSITIVE_RATE;
    numBlocks = 0;
    numDistinctValues = _SplitBlockBloomFilter.DEFAULT_DISTINCT_VALUES;
    hashStrategy = new import_parquet_types.default.BloomFilterHash(new import_parquet_types.default.XxHash());
    hasher = new XxHasher();
    isInitialized() {
      return this.splitBlockFilter.length > 0;
    }
    getFalsePositiveRate() {
      return this.desiredFalsePositiveRate;
    }
    getNumDistinct() {
      return this.numDistinctValues;
    }
    getNumFilterBlocks() {
      return this.splitBlockFilter.length;
    }
    getFilter() {
      return this.splitBlockFilter;
    }
    /**
     * @function  optNumFilterBytes
     * @description return the actual number of filter bytes set; if the option to numBytes
     *     was called, this value will be returned. If the options for preferred FPR
     *     and/or numDistinct were called, this function returns the calculated value.
     */
    getNumFilterBytes() {
      return this.numBlocks * _SplitBlockBloomFilter.BITS_PER_BLOCK >>> 3;
    }
    /**
     * @function setOptionFalsePositiveRate
     * @description set the desired false positive percentage for this Bloom filter.
     *     defaults to SplitBlockBLoomFilter.DEFAULT_FALSE_POSITIVE_RATE
     *     This function does nothing if the filter has already been allocated.
     * @param proportion: number, between 0.0 and 1.0, exclusive
     */
    setOptionFalsePositiveRate(proportion) {
      if (this.isInitialized()) {
        console.error("filter already initialized. options may no longer be changed.");
        return this;
      }
      if (proportion <= 0 || proportion >= 1) {
        console.error("falsePositiveProbability. Must be < 1.0 and > 0.0");
        return this;
      }
      this.desiredFalsePositiveRate = proportion;
      return this;
    }
    /**
     *  @function setOptionNumDistinct
     *  @description set the number of expected distinct values for the filter.
     *     this should generally be <= to the row group size. Defaults to
     *     SplitBlockBloomFilter.UPPER_BOUND_BYTES
     *     This function does nothing if the filter has already been allocated.
     * @param numDistinct
     */
    setOptionNumDistinct(numDistinct) {
      if (this.isInitialized()) {
        console.error("filter already initialized. options may no longer be changed.");
        return this;
      }
      if (numDistinct <= 0 || numDistinct > _SplitBlockBloomFilter.UPPER_BOUND_BYTES) {
        console.error(`invalid numDistinct. Must be > 0 and < ${_SplitBlockBloomFilter.UPPER_BOUND_BYTES}`);
        return this;
      }
      this.numDistinctValues = numDistinct;
      return this;
    }
    /**
     * @function nextPwr2
     * @description return the next highest power of 2 above v
     *     see  https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
     *     NOTE: cannot use values > 2**31. We are not expecting these values internally,
     *     so this works as intended.
     */
    static nextPwr2(v) {
      v--;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      v++;
      return v;
    }
    /**
     * @function setOptionNumFilterBytes
     * @description set the bytes for this Bloom filter. Set this if you don't want an
     *     optimal value calculated for you.  Rounds up to nearest power of 2
     *     This function does nothing if the filter has already been allocated.
     * @param numBytes: number, the desired bit size.
     */
    setOptionNumFilterBytes(numBytes) {
      if (this.isInitialized()) {
        console.error("filter already initialized. options may no longer be changed.");
        return this;
      }
      if (numBytes < _SplitBlockBloomFilter.LOWER_BOUND_BYTES || numBytes > _SplitBlockBloomFilter.UPPER_BOUND_BYTES) {
        console.error(
          `invalid numBits. Must be > ${_SplitBlockBloomFilter.LOWER_BOUND_BYTES} and < ${_SplitBlockBloomFilter.UPPER_BOUND_BYTES}`
        );
        return this;
      }
      this.numBlocks = _SplitBlockBloomFilter.nextPwr2(numBytes) * 8 / _SplitBlockBloomFilter.BITS_PER_BLOCK;
      return this;
    }
    /**
     * @function initFilter
     * @description initialize the Bloom filter using the options previously provided.
     *     If numBlocks has not been calculated and set via setOptionNumBytes, we calculate
     *     the optimal filter size based on number of distinct values and
     *     percent false positive rate. See setOptionNumDistinct and setOptionFalsePositiveRate
     *
     *     Repeated calls to init do nothing to avoid multiple memory allocations or
     *     accidental loss of filters.
     * @return void
     */
    init() {
      if (this.isInitialized()) {
        console.error("filter already initialized.");
        return this;
      }
      if (!Object.prototype.hasOwnProperty.call(this.hashStrategy, "XXHASH")) {
        throw new Error("unsupported hash strategy");
      }
      if (this.numBlocks === 0) {
        this.numBlocks = _SplitBlockBloomFilter.optimalNumOfBlocks(this.numDistinctValues, this.desiredFalsePositiveRate) >>> 3;
      }
      this.splitBlockFilter = Array(this.numBlocks).fill(_SplitBlockBloomFilter.initBlock());
      return this;
    }
    async hash(value) {
      if (!Object.prototype.hasOwnProperty.call(this.hashStrategy, "XXHASH")) {
        throw new Error("unsupported hash strategy");
      }
      const hashed = await this.hasher.hash64(value);
      return long_default.fromString(hashed, true, 16);
    }
    insertHash(hashValue) {
      if (!hashValue.unsigned) throw new Error("hashValue must be an unsigned Long");
      if (!this.isInitialized()) throw new Error("filter has not been initialized. call init() first");
      const i = _SplitBlockBloomFilter.getBlockIndex(hashValue, this.splitBlockFilter.length);
      _SplitBlockBloomFilter.blockInsert(this.splitBlockFilter[i], hashValue);
    }
    /**
     * @function insert
     * @description add a hash value to this filter
     * @param value: an unsigned Long, the value to add. If not a string, will be JSON.stringified
     * @return void
     */
    async insert(value) {
      if (!this.isInitialized()) throw new Error("filter has not been initialized. call init() first");
      this.insertHash(await this.hash(value));
    }
    checkHash(hashValue) {
      if (!hashValue.unsigned) throw new Error("hashValue must be an unsigned Long");
      if (!this.isInitialized()) throw new Error("filter has not been initialized");
      const i = _SplitBlockBloomFilter.getBlockIndex(hashValue, this.splitBlockFilter.length);
      return _SplitBlockBloomFilter.blockCheck(this.splitBlockFilter[i], hashValue);
    }
    /**
     * @function check
     * @description check if a hashValue exists for this filter
     * @param value: the value to check for. If not a string, will be JSON.stringified
     * @return true if hashed item is found in the data set represented by this filter
     * @return false if it is __definitely not__ in the data set.
     */
    async check(value) {
      if (!this.isInitialized()) throw new Error("filter has not been initialized");
      return this.checkHash(await this.hash(value));
    }
  };
  var sbbf_default = SplitBlockBloomFilter;

  // lib/bloomFilterIO/bloomFilterReader.ts
  var filterColumnChunksWithBloomFilters = (columnChunkDataCollection) => {
    return columnChunkDataCollection.filter((columnChunk) => {
      return columnChunk.column.meta_data?.bloom_filter_offset;
    });
  };
  var toInteger = (buffer2) => {
    const integer = parseInt(buffer2.toString("hex"), 16);
    if (integer >= Number.MAX_VALUE) {
      throw Error("Number exceeds Number.MAX_VALUE: Godspeed");
    }
    return integer;
  };
  var parseBloomFilterOffsets = (ColumnChunkDataCollection) => {
    return ColumnChunkDataCollection.map(({ rowGroupIndex, column }) => {
      const { bloom_filter_offset: bloomOffset, path_in_schema: pathInSchema } = column.meta_data || {};
      return {
        offsetBytes: toInteger(bloomOffset.buffer),
        columnName: pathInSchema.join(","),
        rowGroupIndex
      };
    });
  };
  var getBloomFilterHeader = async (offsetBytes, envelopeReader) => {
    const headerByteSizeEstimate = 200;
    let bloomFilterHeaderData;
    try {
      bloomFilterHeaderData = await envelopeReader.read(offsetBytes, headerByteSizeEstimate);
    } catch (e2) {
      if (typeof e2 === "string") throw new Error(e2);
      else throw e2;
    }
    const bloomFilterHeader = new import_parquet_types2.default.BloomFilterHeader();
    const sizeOfBloomFilterHeader = decodeThrift(bloomFilterHeader, bloomFilterHeaderData);
    return {
      bloomFilterHeader,
      sizeOfBloomFilterHeader
    };
  };
  var readFilterData = async (offsetBytes, envelopeReader) => {
    const { bloomFilterHeader, sizeOfBloomFilterHeader } = await getBloomFilterHeader(offsetBytes, envelopeReader);
    const { numBytes: filterByteSize } = bloomFilterHeader;
    try {
      const filterBlocksOffset = offsetBytes + sizeOfBloomFilterHeader;
      const buffer2 = await envelopeReader.read(filterBlocksOffset, filterByteSize);
      return buffer2;
    } catch (e2) {
      if (typeof e2 === "string") throw new Error(e2);
      else throw e2;
    }
  };
  var readFilterDataFrom = (offsets, envelopeReader) => {
    return Promise.all(offsets.map((offset) => readFilterData(offset, envelopeReader)));
  };
  var siftAllByteOffsets = (columnChunkDataCollection) => {
    return parseBloomFilterOffsets(filterColumnChunksWithBloomFilters(columnChunkDataCollection));
  };
  var getBloomFiltersFor = async (paths, envelopeReader) => {
    const columnChunkDataCollection = envelopeReader.getAllColumnChunkDataFor(paths);
    const bloomFilterOffsetData = siftAllByteOffsets(columnChunkDataCollection);
    const offsetByteValues = bloomFilterOffsetData.map(({ offsetBytes }) => offsetBytes);
    const filterBlocksBuffers = await readFilterDataFrom(offsetByteValues, envelopeReader);
    return filterBlocksBuffers.map((buffer2, index) => {
      const { columnName, rowGroupIndex } = bloomFilterOffsetData[index];
      return {
        sbbf: sbbf_default.from(buffer2),
        columnName,
        rowGroupIndex
      };
    });
  };

  // lib/reader.ts
  var import_cross_fetch = __toESM(require_browser_ponyfill());

  // lib/declare.ts
  init_esbuild_shims();
  var import_parquet_types3 = __toESM(require_parquet_types());
  var NewPageHeader = class extends import_parquet_types3.default.PageHeader {
    offset;
    headerSize;
  };

  // node_modules/@smithy/protocol-http/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/extensions/index.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/Field.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/abort.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/auth/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/auth/auth.js
  init_esbuild_shims();
  var HttpAuthLocation;
  (function(HttpAuthLocation2) {
    HttpAuthLocation2["HEADER"] = "header";
    HttpAuthLocation2["QUERY"] = "query";
  })(HttpAuthLocation || (HttpAuthLocation = {}));

  // node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
  init_esbuild_shims();
  var HttpApiKeyAuthLocation;
  (function(HttpApiKeyAuthLocation2) {
    HttpApiKeyAuthLocation2["HEADER"] = "header";
    HttpApiKeyAuthLocation2["QUERY"] = "query";
  })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

  // node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/auth/HttpSigner.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/checksum.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/client.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/command.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/connection/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/connection/config.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/connection/manager.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/connection/pool.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/crypto.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/encode.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoint.js
  init_esbuild_shims();
  var EndpointURLScheme;
  (function(EndpointURLScheme2) {
    EndpointURLScheme2["HTTP"] = "http";
    EndpointURLScheme2["HTTPS"] = "https";
  })(EndpointURLScheme || (EndpointURLScheme = {}));

  // node_modules/@smithy/types/dist-es/endpoints/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoints/shared.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/eventStream.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/extensions/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/extensions/checksum.js
  init_esbuild_shims();
  var AlgorithmId;
  (function(AlgorithmId2) {
    AlgorithmId2["MD5"] = "md5";
    AlgorithmId2["CRC32"] = "crc32";
    AlgorithmId2["CRC32C"] = "crc32c";
    AlgorithmId2["SHA1"] = "sha1";
    AlgorithmId2["SHA256"] = "sha256";
  })(AlgorithmId || (AlgorithmId = {}));

  // node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/http.js
  init_esbuild_shims();
  var FieldPosition;
  (function(FieldPosition2) {
    FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
    FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
  })(FieldPosition || (FieldPosition = {}));

  // node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/identity/index.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/identity/identity.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/logger.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/middleware.js
  init_esbuild_shims();
  var SMITHY_CONTEXT_KEY = "__smithy_context";

  // node_modules/@smithy/types/dist-es/pagination.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/profile.js
  init_esbuild_shims();
  var IniSectionType;
  (function(IniSectionType2) {
    IniSectionType2["PROFILE"] = "profile";
    IniSectionType2["SSO_SESSION"] = "sso-session";
    IniSectionType2["SERVICES"] = "services";
  })(IniSectionType || (IniSectionType = {}));

  // node_modules/@smithy/types/dist-es/response.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/retry.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/serde.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/shapes.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/signature.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/stream.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/transfer.js
  init_esbuild_shims();
  var RequestHandlerProtocol;
  (function(RequestHandlerProtocol2) {
    RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
  })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

  // node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/transform/no-undefined.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/transform/type-transform.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/uri.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/util.js
  init_esbuild_shims();

  // node_modules/@smithy/types/dist-es/waiter.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/Fields.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/httpHandler.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/httpRequest.js
  init_esbuild_shims();
  var HttpRequest = class _HttpRequest {
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static isInstance(request2) {
      if (!request2)
        return false;
      const req = request2;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      const cloned = new _HttpRequest({
        ...this,
        headers: { ...this.headers }
      });
      if (cloned.query)
        cloned.query = cloneQuery(cloned.query);
      return cloned;
    }
  };
  function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }

  // node_modules/@smithy/protocol-http/dist-es/httpResponse.js
  init_esbuild_shims();
  var HttpResponse = class {
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response) {
      if (!response)
        return false;
      const resp = response;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  };

  // node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
  init_esbuild_shims();

  // node_modules/@smithy/protocol-http/dist-es/types.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/client.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-stack/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
  init_esbuild_shims();
  var getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  };
  var getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  };
  var constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = /* @__PURE__ */ new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const removeByReference = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const cloneTo = (toStack) => {
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      toStack.identifyOnResolve?.(stack.identifyOnResolve());
      return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === void 0) {
            if (debug) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    };
    const stack = {
      add: (middleware, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  };
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };

  // node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
  init_esbuild_shims();

  // node_modules/@smithy/util-stream/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
  init_esbuild_shims();

  // node_modules/@smithy/util-stream/dist-es/blob/transforms.js
  init_esbuild_shims();

  // node_modules/@smithy/util-base64/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
  init_esbuild_shims();

  // node_modules/@smithy/util-base64/dist-es/constants.browser.js
  init_esbuild_shims();
  var alphabetByEncoding = {};
  var alphabetByValue = new Array(64);
  for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
    const char = String.fromCharCode(i + start);
    alphabetByEncoding[char] = i;
    alphabetByValue[i] = char;
  }
  for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
    const char = String.fromCharCode(i + start);
    const index = i + 26;
    alphabetByEncoding[char] = index;
    alphabetByValue[index] = char;
  }
  for (let i = 0; i < 10; i++) {
    alphabetByEncoding[i.toString(10)] = i + 52;
    const char = i.toString(10);
    const index = i + 52;
    alphabetByEncoding[char] = index;
    alphabetByValue[index] = char;
  }
  alphabetByEncoding["+"] = 62;
  alphabetByValue[62] = "+";
  alphabetByEncoding["/"] = 63;
  alphabetByValue[63] = "/";
  var bitsPerLetter = 6;
  var bitsPerByte = 8;
  var maxLetterValue = 63;

  // node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
  var fromBase64 = (input) => {
    let totalByteLength = input.length / 4 * 3;
    if (input.slice(-2) === "==") {
      totalByteLength -= 2;
    } else if (input.slice(-1) === "=") {
      totalByteLength--;
    }
    const out = new ArrayBuffer(totalByteLength);
    const dataView = new DataView(out);
    for (let i = 0; i < input.length; i += 4) {
      let bits = 0;
      let bitLength = 0;
      for (let j = i, limit = i + 3; j <= limit; j++) {
        if (input[j] !== "=") {
          if (!(input[j] in alphabetByEncoding)) {
            throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
          }
          bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;
          bitLength += bitsPerLetter;
        } else {
          bits >>= bitsPerLetter;
        }
      }
      const chunkOffset = i / 4 * 3;
      bits >>= bitLength % bitsPerByte;
      const byteLength = Math.floor(bitLength / bitsPerByte);
      for (let k = 0; k < byteLength; k++) {
        const offset = (byteLength - k - 1) * bitsPerByte;
        dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);
      }
    }
    return new Uint8Array(out);
  };

  // node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
  init_esbuild_shims();

  // node_modules/@smithy/util-utf8/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
  init_esbuild_shims();
  var fromUtf8 = (input) => new TextEncoder().encode(input);

  // node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
  init_esbuild_shims();
  var toUint8Array = (data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  };

  // node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
  init_esbuild_shims();
  var toUtf8 = (input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return new TextDecoder("utf-8").decode(input);
  };

  // node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
  function toBase64(_input) {
    let input;
    if (typeof _input === "string") {
      input = fromUtf8(_input);
    } else {
      input = _input;
    }
    const isArrayLike = typeof input === "object" && typeof input.length === "number";
    const isUint8Array = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
    if (!isArrayLike && !isUint8Array) {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    let str = "";
    for (let i = 0; i < input.length; i += 3) {
      let bits = 0;
      let bitLength = 0;
      for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
        bits |= input[j] << (limit - j - 1) * bitsPerByte;
        bitLength += bitsPerByte;
      }
      const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
      bits <<= bitClusterCount * bitsPerLetter - bitLength;
      for (let k = 1; k <= bitClusterCount; k++) {
        const offset = (bitClusterCount - k) * bitsPerLetter;
        str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
      }
      str += "==".slice(0, 4 - bitClusterCount);
    }
    return str;
  }

  // node_modules/@smithy/util-stream/dist-es/blob/transforms.js
  function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
      return toBase64(payload);
    }
    return toUtf8(payload);
  }
  function transformFromString(str, encoding) {
    if (encoding === "base64") {
      return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
  }

  // node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
  var Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
      switch (typeof source) {
        case "string":
          return transformFromString(source, encoding);
        default:
          throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
    }
    static mutate(source) {
      Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      return transformToString(this, encoding);
    }
  };

  // node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
  init_esbuild_shims();

  // node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
  init_esbuild_shims();

  // node_modules/@smithy/fetch-http-handler/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
  init_esbuild_shims();

  // node_modules/@smithy/querystring-builder/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-uri-escape/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
  init_esbuild_shims();

  // node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
  init_esbuild_shims();

  // node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
  init_esbuild_shims();

  // node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
  var keepAliveSupport = {
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
  };

  // node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
  init_esbuild_shims();

  // node_modules/@smithy/util-hex-encoding/dist-es/index.js
  init_esbuild_shims();
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
  }

  // node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
  var collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
      return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
  };

  // node_modules/@smithy/smithy-client/dist-es/command.js
  init_esbuild_shims();
  var Command = class {
    constructor() {
      this.middlewareStack = constructStack();
    }
    static classBuilder() {
      return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger: logger2 } = configuration;
      const handlerExecutionContext = {
        logger: logger2,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [SMITHY_CONTEXT_KEY]: {
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
    }
  };
  var ClassBuilder = class {
    constructor() {
      this._init = () => {
      };
      this._ep = {};
      this._middlewareFn = () => [];
      this._commandName = "";
      this._clientName = "";
      this._additionalContext = {};
      this._smithyContext = {};
      this._inputFilterSensitiveLog = (_) => _;
      this._outputFilterSensitiveLog = (_) => _;
      this._serializer = null;
      this._deserializer = null;
    }
    init(cb) {
      this._init = cb;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    build() {
      const closure = this;
      let CommandRef;
      return CommandRef = class extends Command {
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        constructor(...[input]) {
          super();
          this.serialize = closure._serializer;
          this.deserialize = closure._deserializer;
          this.input = input ?? {};
          closure._init(this);
        }
        resolveMiddleware(stack, configuration, options) {
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
      };
    }
  };

  // node_modules/@smithy/smithy-client/dist-es/constants.js
  init_esbuild_shims();
  var SENSITIVE_STRING = "***SensitiveInformation***";

  // node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/date-utils.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/parse-utils.js
  init_esbuild_shims();
  var parseBoolean = (value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  };
  var expectNumber = (value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  };
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  };
  var expectLong = (value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  };
  var expectInt32 = (value) => expectSizedInt(value, 32);
  var expectShort = (value) => expectSizedInt(value, 16);
  var expectByte = (value) => expectSizedInt(value, 8);
  var expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== void 0 && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  };
  var castInt = (value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  };
  var expectNonNull = (value, location) => {
    if (value === null || value === void 0) {
      if (location) {
        throw new TypeError(`Expected a non-null value for ${location}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  };
  var expectString = (value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  };
  var strictParseFloat32 = (value) => {
    if (typeof value == "string") {
      return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
  };
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  };
  var strictParseLong = (value) => {
    if (typeof value === "string") {
      return expectLong(parseNumber(value));
    }
    return expectLong(value);
  };
  var strictParseInt32 = (value) => {
    if (typeof value === "string") {
      return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
  };
  var strictParseShort = (value) => {
    if (typeof value === "string") {
      return expectShort(parseNumber(value));
    }
    return expectShort(value);
  };
  var strictParseByte = (value) => {
    if (typeof value === "string") {
      return expectByte(parseNumber(value));
    }
    return expectByte(value);
  };
  var stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join("\n");
  };
  var logger = {
    warn: console.warn
  };

  // node_modules/@smithy/smithy-client/dist-es/date-utils.js
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
  };
  var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = (value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
      const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  };
  var buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
  };
  var parseTwoDigitYear = (value) => {
    const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  };
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
  var adjustRfc850Year = (input) => {
    if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  };
  var parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
  };
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
  };
  var isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  };
  var parseMilliseconds = (value) => {
    if (value === null || value === void 0) {
      return 0;
    }
    return strictParseFloat32("0." + value) * 1e3;
  };
  var parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1e3;
  };
  var stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  };

  // node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/exceptions.js
  init_esbuild_shims();
  var ServiceException = class _ServiceException extends Error {
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, _ServiceException.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
  };
  var decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions).filter(([, v]) => v !== void 0).forEach(([k, v]) => {
      if (exception[k] == void 0 || exception[k] === "") {
        exception[k] = v;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  };

  // node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
  var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
    const response = new exceptionCtor({
      name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response, parsedBody);
  };
  var withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });

  // node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/extensions/index.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
  init_esbuild_shims();
  function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }

  // node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
  init_esbuild_shims();
  var getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  };

  // node_modules/@smithy/smithy-client/dist-es/lazy-json.js
  init_esbuild_shims();
  var StringWrapper = function() {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
  };
  StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: StringWrapper,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Object.setPrototypeOf(StringWrapper, String);

  // node_modules/@smithy/smithy-client/dist-es/object-mapping.js
  init_esbuild_shims();
  function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  var mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  };
  var applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === void 0 && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  };
  var nonNullish = (_) => _ != null;
  var pass = (_) => _;

  // node_modules/@smithy/smithy-client/dist-es/resolve-path.js
  init_esbuild_shims();
  var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== void 0) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath2;
  };

  // node_modules/@smithy/smithy-client/dist-es/ser-utils.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/serde-json.js
  init_esbuild_shims();

  // node_modules/@smithy/smithy-client/dist-es/split-every.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
  init_esbuild_shims();
  var s3ExpiresMiddleware = (config) => {
    return (next, context) => async (args) => {
      const result = await next(args);
      const { response } = result;
      if (HttpResponse.isInstance(response)) {
        if (response.headers.expires) {
          response.headers.expiresstring = response.headers.expires;
          try {
            parseRfc7231DateTime(response.headers.expires);
          } catch (e2) {
            context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response.headers.expires}): ${e2}`);
            delete response.headers.expires;
          }
        }
      }
      return result;
    };
  };
  var s3ExpiresMiddlewareOptions = {
    tags: ["S3"],
    name: "s3ExpiresMiddleware",
    override: true,
    relation: "after",
    toMiddleware: "deserializerMiddleware"
  };
  var getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(s3ExpiresMiddleware(clientConfig), s3ExpiresMiddlewareOptions);
    }
  });

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
  init_esbuild_shims();
  var S3ExpressIdentityCache = class _S3ExpressIdentityCache {
    constructor(data = {}) {
      this.data = data;
      this.lastPurgeTime = Date.now();
    }
    get(key) {
      const entry = this.data[key];
      if (!entry) {
        return;
      }
      return entry;
    }
    set(key, entry) {
      this.data[key] = entry;
      return entry;
    }
    delete(key) {
      delete this.data[key];
    }
    async purgeExpired() {
      const now = Date.now();
      if (this.lastPurgeTime + _S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
        return;
      }
      for (const key in this.data) {
        const entry = this.data[key];
        if (!entry.isRefreshing) {
          const credential = await entry.identity;
          if (credential.expiration) {
            if (credential.expiration.getTime() < now) {
              delete this.data[key];
            }
          }
        }
      }
    }
  };
  S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
  init_esbuild_shims();
  var S3ExpressIdentityCacheEntry = class {
    constructor(_identity, isRefreshing = false, accessed = Date.now()) {
      this._identity = _identity;
      this.isRefreshing = isRefreshing;
      this.accessed = accessed;
    }
    get identity() {
      this.accessed = Date.now();
      return this._identity;
    }
  };

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
  init_esbuild_shims();
  var S3ExpressIdentityProviderImpl = class _S3ExpressIdentityProviderImpl {
    constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
      this.createSessionFn = createSessionFn;
      this.cache = cache;
    }
    async getS3ExpressIdentity(awsIdentity, identityProperties) {
      const key = identityProperties.Bucket;
      const { cache } = this;
      const entry = cache.get(key);
      if (entry) {
        return entry.identity.then((identity) => {
          const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
          if (isExpired) {
            return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
          }
          const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + _S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
          if (isExpiringSoon && !entry.isRefreshing) {
            entry.isRefreshing = true;
            this.getIdentity(key).then((id) => {
              cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
            });
          }
          return identity;
        });
      }
      return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
    }
    async getIdentity(key) {
      await this.cache.purgeExpired().catch((error) => {
        console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
      });
      const session = await this.createSessionFn(key);
      if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
        throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
      }
      const identity = {
        accessKeyId: session.Credentials.AccessKeyId,
        secretAccessKey: session.Credentials.SecretAccessKey,
        sessionToken: session.Credentials.SessionToken,
        expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
      };
      return identity;
    }
  };
  S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
  init_esbuild_shims();

  // node_modules/@smithy/util-middleware/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
  init_esbuild_shims();
  var getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

  // node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/constants.js
  init_esbuild_shims();
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

  // node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
  init_esbuild_shims();

  // node_modules/@smithy/is-array-buffer/dist-es/index.js
  init_esbuild_shims();
  var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

  // node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
  init_esbuild_shims();
  var HEADER_VALUE_TYPE;
  (function(HEADER_VALUE_TYPE2) {
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
  })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));

  // node_modules/@smithy/signature-v4/dist-es/headerUtil.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
  init_esbuild_shims();

  // node_modules/@smithy/signature-v4/dist-es/utilDate.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
  init_esbuild_shims();

  // node_modules/@smithy/util-config-provider/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
  init_esbuild_shims();

  // node_modules/@smithy/util-config-provider/dist-es/numberSelector.js
  init_esbuild_shims();

  // node_modules/@smithy/util-config-provider/dist-es/types.js
  init_esbuild_shims();
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["ENV"] = "env";
    SelectorType2["CONFIG"] = "shared config entry";
  })(SelectorType || (SelectorType = {}));

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
  var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
  var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
  init_esbuild_shims();
  var resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  };
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  var isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
  init_esbuild_shims();
  var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
      const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
      return async () => {
        const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
        const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
        return configValue;
      };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol, hostname, port, path } = endpoint;
            return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
  init_esbuild_shims();
  var getEndpointFromConfig = async (serviceId) => void 0;

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
  init_esbuild_shims();

  // node_modules/@smithy/url-parser/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/querystring-parser/dist-es/index.js
  init_esbuild_shims();
  function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  }

  // node_modules/@smithy/url-parser/dist-es/index.js
  var parseUrl = (url) => {
    if (typeof url === "string") {
      return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
      query = parseQueryString(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : void 0,
      protocol,
      path: pathname,
      query
    };
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
  var toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return parseUrl(endpoint.url);
      }
      return endpoint;
    }
    return parseUrl(endpoint);
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
  var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
      const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
      }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  };
  var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
  init_esbuild_shims();
  var endpointMiddleware = ({ config, instructions }) => {
    return (next, context) => async (args) => {
      const endpoint = await getEndpointFromInstructions(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = endpoint.properties?.authSchemes;
      const authScheme = context.authSchemes?.[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
        const smithyContext = getSmithyContext(context);
        const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
        if (httpAuthOption) {
          httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
            signing_region: authScheme.signingRegion,
            signingRegion: authScheme.signingRegion,
            signing_service: authScheme.signingName,
            signingName: authScheme.signingName,
            signingRegionSet: authScheme.signingRegionSet
          }, authScheme.properties);
        }
      }
      return next({
        ...args
      });
    };
  };

  // node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-serde/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
  init_esbuild_shims();
  var deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
      const parsed = await deserializer(response, options);
      return {
        response,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        error.message += "\n  " + hint;
        if (typeof error.$responseBodyText !== "undefined") {
          if (error.$response) {
            error.$response.body = error.$responseBodyText;
          }
        }
      }
      throw error;
    }
  };

  // node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
  init_esbuild_shims();
  var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request2 = await serializer(args.input, { ...options, endpoint });
    return next({
      ...args,
      request: request2
    });
  };

  // node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
      }
    };
  }

  // node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
  var endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name
  };
  var getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(endpointMiddleware({
        config,
        instructions
      }), endpointMiddlewareOptions);
    }
  });

  // node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-endpoint/dist-es/types.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/config.js
  init_esbuild_shims();
  var RETRY_MODES;
  (function(RETRY_MODES2) {
    RETRY_MODES2["STANDARD"] = "standard";
    RETRY_MODES2["ADAPTIVE"] = "adaptive";
  })(RETRY_MODES || (RETRY_MODES = {}));
  var DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

  // node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
  init_esbuild_shims();

  // node_modules/@smithy/service-error-classification/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/service-error-classification/dist-es/constants.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/constants.js
  init_esbuild_shims();
  var MAXIMUM_RETRY_DELAY = 20 * 1e3;

  // node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/util-retry/dist-es/types.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/util.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/configurations.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
  init_esbuild_shims();

  // node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
  var retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };

  // node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
  init_esbuild_shims();
  var commonParams = {
    ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
    UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
    DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
    Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
    DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };

  // node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
  init_esbuild_shims();
  var S3ServiceException = class _S3ServiceException extends ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, _S3ServiceException.prototype);
    }
  };

  // node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
  var NoSuchUpload = class _NoSuchUpload extends S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchUpload",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchUpload";
      this.$fault = "client";
      Object.setPrototypeOf(this, _NoSuchUpload.prototype);
    }
  };
  var ObjectNotInActiveTierError = class _ObjectNotInActiveTierError extends S3ServiceException {
    constructor(opts) {
      super({
        name: "ObjectNotInActiveTierError",
        $fault: "client",
        ...opts
      });
      this.name = "ObjectNotInActiveTierError";
      this.$fault = "client";
      Object.setPrototypeOf(this, _ObjectNotInActiveTierError.prototype);
    }
  };
  var BucketAlreadyExists = class _BucketAlreadyExists extends S3ServiceException {
    constructor(opts) {
      super({
        name: "BucketAlreadyExists",
        $fault: "client",
        ...opts
      });
      this.name = "BucketAlreadyExists";
      this.$fault = "client";
      Object.setPrototypeOf(this, _BucketAlreadyExists.prototype);
    }
  };
  var BucketAlreadyOwnedByYou = class _BucketAlreadyOwnedByYou extends S3ServiceException {
    constructor(opts) {
      super({
        name: "BucketAlreadyOwnedByYou",
        $fault: "client",
        ...opts
      });
      this.name = "BucketAlreadyOwnedByYou";
      this.$fault = "client";
      Object.setPrototypeOf(this, _BucketAlreadyOwnedByYou.prototype);
    }
  };
  var NoSuchBucket = class _NoSuchBucket extends S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchBucket",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchBucket";
      this.$fault = "client";
      Object.setPrototypeOf(this, _NoSuchBucket.prototype);
    }
  };
  var AnalyticsFilter;
  (function(AnalyticsFilter2) {
    AnalyticsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(AnalyticsFilter || (AnalyticsFilter = {}));
  var LifecycleRuleFilter;
  (function(LifecycleRuleFilter2) {
    LifecycleRuleFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.ObjectSizeGreaterThan !== void 0)
        return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
      if (value.ObjectSizeLessThan !== void 0)
        return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
  var MetricsFilter;
  (function(MetricsFilter2) {
    MetricsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.AccessPointArn !== void 0)
        return visitor.AccessPointArn(value.AccessPointArn);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(MetricsFilter || (MetricsFilter = {}));
  var ReplicationRuleFilter;
  (function(ReplicationRuleFilter2) {
    ReplicationRuleFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
  var InvalidObjectState = class _InvalidObjectState extends S3ServiceException {
    constructor(opts) {
      super({
        name: "InvalidObjectState",
        $fault: "client",
        ...opts
      });
      this.name = "InvalidObjectState";
      this.$fault = "client";
      Object.setPrototypeOf(this, _InvalidObjectState.prototype);
      this.StorageClass = opts.StorageClass;
      this.AccessTier = opts.AccessTier;
    }
  };
  var NoSuchKey = class _NoSuchKey extends S3ServiceException {
    constructor(opts) {
      super({
        name: "NoSuchKey",
        $fault: "client",
        ...opts
      });
      this.name = "NoSuchKey";
      this.$fault = "client";
      Object.setPrototypeOf(this, _NoSuchKey.prototype);
    }
  };
  var NotFound = class _NotFound extends S3ServiceException {
    constructor(opts) {
      super({
        name: "NotFound",
        $fault: "client",
        ...opts
      });
      this.name = "NotFound";
      this.$fault = "client";
      Object.setPrototypeOf(this, _NotFound.prototype);
    }
  };
  var GetObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
  });
  var GetObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
  });
  var HeadObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
  });
  var HeadObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
  });

  // node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
  init_esbuild_shims();
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: endpointMiddlewareOptions.name
  };

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
  init_esbuild_shims();
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name
  };

  // node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
  init_esbuild_shims();
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: retryMiddlewareOptions.name
  };

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
  init_esbuild_shims();
  var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
  var EXPIRATION_MS = 3e5;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;

  // node_modules/@smithy/core/dist-es/getSmithyContext.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/normalizeProvider.js
  init_esbuild_shims();

  // node_modules/@smithy/core/dist-es/protocols/requestBuilder.js
  init_esbuild_shims();
  function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
  }
  var RequestBuilder = class {
    constructor(input, context) {
      this.input = input;
      this.context = context;
      this.query = {};
      this.method = "";
      this.headers = {};
      this.path = "";
      this.body = null;
      this.hostname = "";
      this.resolvePathStack = [];
    }
    async build() {
      const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new HttpRequest({
        protocol,
        hostname: this.hostname || hostname,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname) {
      this.hostname = hostname;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path) => {
        this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  };

  // node_modules/@smithy/core/dist-es/pagination/createPaginator.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/core/dist-es/protocols/common.js
  init_esbuild_shims();
  var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

  // node_modules/@aws-sdk/core/dist-es/protocols/xml/parseXmlBody.js
  init_esbuild_shims();
  var import_fast_xml_parser = __toESM(require_fxp());
  var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parser = new import_fast_xml_parser.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", "\n");
      let parsedObj;
      try {
        parsedObj = parser.parse(encoded, true);
      } catch (e2) {
        if (e2 && typeof e2 === "object") {
          Object.defineProperty(e2, "$responseBodyText", {
            value: encoded
          });
        }
        throw e2;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });
  var parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== void 0) {
      return data.Error.Code;
    }
    if (data?.Code !== void 0) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };

  // node_modules/@aws-sdk/xml-builder/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
  init_esbuild_shims();
  var ObjectAlreadyInActiveTierError = class _ObjectAlreadyInActiveTierError extends S3ServiceException {
    constructor(opts) {
      super({
        name: "ObjectAlreadyInActiveTierError",
        $fault: "client",
        ...opts
      });
      this.name = "ObjectAlreadyInActiveTierError";
      this.$fault = "client";
      Object.setPrototypeOf(this, _ObjectAlreadyInActiveTierError.prototype);
    }
  };
  var SelectObjectContentEventStream;
  (function(SelectObjectContentEventStream2) {
    SelectObjectContentEventStream2.visit = (value, visitor) => {
      if (value.Records !== void 0)
        return visitor.Records(value.Records);
      if (value.Stats !== void 0)
        return visitor.Stats(value.Stats);
      if (value.Progress !== void 0)
        return visitor.Progress(value.Progress);
      if (value.Cont !== void 0)
        return visitor.Cont(value.Cont);
      if (value.End !== void 0)
        return visitor.End(value.End);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));

  // node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
  var se_GetObjectCommand = async (input, context) => {
    const b = requestBuilder(input, context);
    const headers = map({}, isSerializableHeaderValue, {
      [_im]: input[_IM],
      [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => dateToUtcString(input[_IMS]).toString()],
      [_inm]: input[_INM],
      [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
      [_ra]: input[_R],
      [_xasseca]: input[_SSECA],
      [_xasseck]: input[_SSECK],
      [_xasseckm]: input[_SSECKMD],
      [_xarp]: input[_RP],
      [_xaebo]: input[_EBO],
      [_xacm]: input[_CM]
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = map({
      [_xi]: [, "GetObject"],
      [_rcc]: [, input[_RCC]],
      [_rcd]: [, input[_RCD]],
      [_rce]: [, input[_RCE]],
      [_rcl]: [, input[_RCL]],
      [_rct]: [, input[_RCT]],
      [_re]: [() => input.ResponseExpires !== void 0, () => dateToUtcString(input[_RE]).toString()],
      [_vI]: [, input[_VI]],
      [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
  };
  var se_HeadObjectCommand = async (input, context) => {
    const b = requestBuilder(input, context);
    const headers = map({}, isSerializableHeaderValue, {
      [_im]: input[_IM],
      [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => dateToUtcString(input[_IMS]).toString()],
      [_inm]: input[_INM],
      [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
      [_ra]: input[_R],
      [_xasseca]: input[_SSECA],
      [_xasseck]: input[_SSECK],
      [_xasseckm]: input[_SSECKMD],
      [_xarp]: input[_RP],
      [_xaebo]: input[_EBO],
      [_xacm]: input[_CM]
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = map({
      [_vI]: [, input[_VI]],
      [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
    });
    let body;
    b.m("HEAD").h(headers).q(query).b(body);
    return b.build();
  };
  var de_GetObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError(output, context);
    }
    const contents = map({
      $metadata: deserializeMetadata2(output),
      [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
      [_AR]: [, output.headers[_ar]],
      [_Exp]: [, output.headers[_xae]],
      [_Re]: [, output.headers[_xar]],
      [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
      [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
      [_ETa]: [, output.headers[_eta]],
      [_CCRC]: [, output.headers[_xacc]],
      [_CCRCC]: [, output.headers[_xacc_]],
      [_CSHA]: [, output.headers[_xacs]],
      [_CSHAh]: [, output.headers[_xacs_]],
      [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
      [_VI]: [, output.headers[_xavi]],
      [_CC]: [, output.headers[_cc]],
      [_CD]: [, output.headers[_cd]],
      [_CE]: [, output.headers[_ce]],
      [_CL]: [, output.headers[_cl]],
      [_CR]: [, output.headers[_cr]],
      [_CT]: [, output.headers[_ct]],
      [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
      [_ES]: [, output.headers[_ex]],
      [_WRL]: [, output.headers[_xawrl]],
      [_SSE]: [, output.headers[_xasse]],
      [_SSECA]: [, output.headers[_xasseca]],
      [_SSECKMD]: [, output.headers[_xasseckm]],
      [_SSEKMSKI]: [, output.headers[_xasseakki]],
      [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
      [_SC]: [, output.headers[_xasc]],
      [_RC]: [, output.headers[_xarc]],
      [_RS]: [, output.headers[_xars]],
      [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
      [_TC]: [() => void 0 !== output.headers[_xatc], () => strictParseInt32(output.headers[_xatc])],
      [_OLM]: [, output.headers[_xaolm]],
      [_OLRUD]: [
        () => void 0 !== output.headers[_xaolrud],
        () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
      ],
      [_OLLHS]: [, output.headers[_xaollh]],
      Metadata: [
        ,
        Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
          acc[header.substring(11)] = output.headers[header];
          return acc;
        }, {})
      ]
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.Body = data;
    return contents;
  };
  var de_HeadObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError(output, context);
    }
    const contents = map({
      $metadata: deserializeMetadata2(output),
      [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
      [_AR]: [, output.headers[_ar]],
      [_Exp]: [, output.headers[_xae]],
      [_Re]: [, output.headers[_xar]],
      [_AS]: [, output.headers[_xaas]],
      [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
      [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
      [_CCRC]: [, output.headers[_xacc]],
      [_CCRCC]: [, output.headers[_xacc_]],
      [_CSHA]: [, output.headers[_xacs]],
      [_CSHAh]: [, output.headers[_xacs_]],
      [_ETa]: [, output.headers[_eta]],
      [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
      [_VI]: [, output.headers[_xavi]],
      [_CC]: [, output.headers[_cc]],
      [_CD]: [, output.headers[_cd]],
      [_CE]: [, output.headers[_ce]],
      [_CL]: [, output.headers[_cl]],
      [_CT]: [, output.headers[_ct]],
      [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
      [_ES]: [, output.headers[_ex]],
      [_WRL]: [, output.headers[_xawrl]],
      [_SSE]: [, output.headers[_xasse]],
      [_SSECA]: [, output.headers[_xasseca]],
      [_SSECKMD]: [, output.headers[_xasseckm]],
      [_SSEKMSKI]: [, output.headers[_xasseakki]],
      [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
      [_SC]: [, output.headers[_xasc]],
      [_RC]: [, output.headers[_xarc]],
      [_RS]: [, output.headers[_xars]],
      [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
      [_OLM]: [, output.headers[_xaolm]],
      [_OLRUD]: [
        () => void 0 !== output.headers[_xaolrud],
        () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
      ],
      [_OLLHS]: [, output.headers[_xaollh]],
      Metadata: [
        ,
        Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
          acc[header.substring(11)] = output.headers[header];
          return acc;
        }, {})
      ]
    });
    await collectBody(output.body, context);
    return contents;
  };
  var de_CommandError = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseXmlErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchUpload":
      case "com.amazonaws.s3#NoSuchUpload":
        throw await de_NoSuchUploadRes(parsedOutput, context);
      case "ObjectNotInActiveTierError":
      case "com.amazonaws.s3#ObjectNotInActiveTierError":
        throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
      case "BucketAlreadyExists":
      case "com.amazonaws.s3#BucketAlreadyExists":
        throw await de_BucketAlreadyExistsRes(parsedOutput, context);
      case "BucketAlreadyOwnedByYou":
      case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
        throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
      case "NoSuchBucket":
      case "com.amazonaws.s3#NoSuchBucket":
        throw await de_NoSuchBucketRes(parsedOutput, context);
      case "InvalidObjectState":
      case "com.amazonaws.s3#InvalidObjectState":
        throw await de_InvalidObjectStateRes(parsedOutput, context);
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      case "NotFound":
      case "com.amazonaws.s3#NotFound":
        throw await de_NotFoundRes(parsedOutput, context);
      case "ObjectAlreadyInActiveTierError":
      case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
        throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError2({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var throwDefaultError2 = withBaseException(S3ServiceException);
  var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new BucketAlreadyExists({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new BucketAlreadyOwnedByYou({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_InvalidObjectStateRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data[_AT] != null) {
      contents[_AT] = expectString(data[_AT]);
    }
    if (data[_SC] != null) {
      contents[_SC] = expectString(data[_SC]);
    }
    const exception = new InvalidObjectState({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_NoSuchBucketRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchBucket({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_NoSuchKeyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchKey({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_NoSuchUploadRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchUpload({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_NotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NotFound({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new ObjectAlreadyInActiveTierError({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new ObjectNotInActiveTierError({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  };
  var deserializeMetadata2 = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
  var _AR = "AcceptRanges";
  var _AS = "ArchiveStatus";
  var _AT = "AccessTier";
  var _BKE = "BucketKeyEnabled";
  var _CC = "CacheControl";
  var _CCRC = "ChecksumCRC32";
  var _CCRCC = "ChecksumCRC32C";
  var _CD = "ContentDisposition";
  var _CE = "ContentEncoding";
  var _CL = "ContentLanguage";
  var _CLo = "ContentLength";
  var _CM = "ChecksumMode";
  var _CR = "ContentRange";
  var _CSHA = "ChecksumSHA1";
  var _CSHAh = "ChecksumSHA256";
  var _CT = "ContentType";
  var _DM = "DeleteMarker";
  var _E = "Expires";
  var _EBO = "ExpectedBucketOwner";
  var _ES = "ExpiresString";
  var _ETa = "ETag";
  var _Exp = "Expiration";
  var _IM = "IfMatch";
  var _IMS = "IfModifiedSince";
  var _INM = "IfNoneMatch";
  var _IUS = "IfUnmodifiedSince";
  var _LM = "LastModified";
  var _MM = "MissingMeta";
  var _OLLHS = "ObjectLockLegalHoldStatus";
  var _OLM = "ObjectLockMode";
  var _OLRUD = "ObjectLockRetainUntilDate";
  var _PC = "PartsCount";
  var _PN = "PartNumber";
  var _R = "Range";
  var _RC = "RequestCharged";
  var _RCC = "ResponseCacheControl";
  var _RCD = "ResponseContentDisposition";
  var _RCE = "ResponseContentEncoding";
  var _RCL = "ResponseContentLanguage";
  var _RCT = "ResponseContentType";
  var _RE = "ResponseExpires";
  var _RP = "RequestPayer";
  var _RS = "ReplicationStatus";
  var _Re = "Restore";
  var _SC = "StorageClass";
  var _SSE = "ServerSideEncryption";
  var _SSECA = "SSECustomerAlgorithm";
  var _SSECK = "SSECustomerKey";
  var _SSECKMD = "SSECustomerKeyMD5";
  var _SSEKMSKI = "SSEKMSKeyId";
  var _TC = "TagCount";
  var _VI = "VersionId";
  var _WRL = "WebsiteRedirectLocation";
  var _ar = "accept-ranges";
  var _cc = "cache-control";
  var _cd = "content-disposition";
  var _ce = "content-encoding";
  var _cl = "content-language";
  var _cl_ = "content-length";
  var _cr = "content-range";
  var _ct = "content-type";
  var _e = "expires";
  var _eta = "etag";
  var _ex = "expiresstring";
  var _im = "if-match";
  var _ims = "if-modified-since";
  var _inm = "if-none-match";
  var _ius = "if-unmodified-since";
  var _lm = "last-modified";
  var _pN = "partNumber";
  var _ra = "range";
  var _rcc = "response-cache-control";
  var _rcd = "response-content-disposition";
  var _rce = "response-content-encoding";
  var _rcl = "response-content-language";
  var _rct = "response-content-type";
  var _re = "response-expires";
  var _vI = "versionId";
  var _xaas = "x-amz-archive-status";
  var _xacc = "x-amz-checksum-crc32";
  var _xacc_ = "x-amz-checksum-crc32c";
  var _xacm = "x-amz-checksum-mode";
  var _xacs = "x-amz-checksum-sha1";
  var _xacs_ = "x-amz-checksum-sha256";
  var _xadm = "x-amz-delete-marker";
  var _xae = "x-amz-expiration";
  var _xaebo = "x-amz-expected-bucket-owner";
  var _xamm = "x-amz-missing-meta";
  var _xampc = "x-amz-mp-parts-count";
  var _xaollh = "x-amz-object-lock-legal-hold";
  var _xaolm = "x-amz-object-lock-mode";
  var _xaolrud = "x-amz-object-lock-retain-until-date";
  var _xar = "x-amz-restore";
  var _xarc = "x-amz-request-charged";
  var _xarp = "x-amz-request-payer";
  var _xars = "x-amz-replication-status";
  var _xasc = "x-amz-storage-class";
  var _xasse = "x-amz-server-side-encryption";
  var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
  var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
  var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
  var _xasseck = "x-amz-server-side-encryption-customer-key";
  var _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
  var _xatc = "x-amz-tagging-count";
  var _xavi = "x-amz-version-id";
  var _xawrl = "x-amz-website-redirect-location";
  var _xi = "x-id";

  // node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
  init_esbuild_shims();
  function ssecMiddleware(options) {
    return (next) => async (args) => {
      const input = { ...args.input };
      const properties = [
        {
          target: "SSECustomerKey",
          hash: "SSECustomerKeyMD5"
        },
        {
          target: "CopySourceSSECustomerKey",
          hash: "CopySourceSSECustomerKeyMD5"
        }
      ];
      for (const prop of properties) {
        const value = input[prop.target];
        if (value) {
          let valueForHash;
          if (typeof value === "string") {
            if (isValidBase64EncodedSSECustomerKey(value, options)) {
              valueForHash = options.base64Decoder(value);
            } else {
              valueForHash = options.utf8Decoder(value);
              input[prop.target] = options.base64Encoder(valueForHash);
            }
          } else {
            valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
          const hash = new options.md5();
          hash.update(valueForHash);
          input[prop.hash] = options.base64Encoder(await hash.digest());
        }
      }
      return next({
        ...args,
        input
      });
    };
  }
  var ssecMiddlewareOptions = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: true
  };
  var getSsecPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
    }
  });
  function isValidBase64EncodedSSECustomerKey(str, options) {
    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    if (!base64Regex.test(str))
      return false;
    try {
      const decodedBytes = options.base64Decoder(str);
      return decodedBytes.length === 32;
    } catch {
      return false;
    }
  }

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
  init_esbuild_shims();
  var ChecksumAlgorithm;
  (function(ChecksumAlgorithm2) {
    ChecksumAlgorithm2["MD5"] = "MD5";
    ChecksumAlgorithm2["CRC32"] = "CRC32";
    ChecksumAlgorithm2["CRC32C"] = "CRC32C";
    ChecksumAlgorithm2["SHA1"] = "SHA1";
    ChecksumAlgorithm2["SHA256"] = "SHA256";
  })(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
  var ChecksumLocation;
  (function(ChecksumLocation2) {
    ChecksumLocation2["HEADER"] = "header";
    ChecksumLocation2["TRAILER"] = "trailer";
  })(ChecksumLocation || (ChecksumLocation = {}));
  var DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.MD5;
  var S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
  init_esbuild_shims();
  var CLIENT_SUPPORTED_ALGORITHMS = [
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.SHA256
  ];
  var PRIORITY_ORDER_ALGORITHMS = [
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.SHA256
  ];

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
  var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }, isS3Express) => {
    const defaultAlgorithm = isS3Express ? S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM : DEFAULT_CHECKSUM_ALGORITHM;
    if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
      return requestChecksumRequired ? defaultAlgorithm : void 0;
    }
    const checksumAlgorithm = input[requestAlgorithmMember];
    if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
      throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
    }
    return checksumAlgorithm;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
  init_esbuild_shims();
  var getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
  init_esbuild_shims();
  var hasHeader2 = (header, headers) => {
    const soughtHeader = header.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
  init_esbuild_shims();
  var isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
  init_esbuild_shims();
  var import_crc32 = __toESM(require_build2());
  var import_crc32c = __toESM(require_build3());
  var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
    [ChecksumAlgorithm.MD5]: config.md5,
    [ChecksumAlgorithm.CRC32]: import_crc32.AwsCrc32,
    [ChecksumAlgorithm.CRC32C]: import_crc32c.AwsCrc32c,
    [ChecksumAlgorithm.SHA1]: config.sha1,
    [ChecksumAlgorithm.SHA256]: config.sha256
  })[checksumAlgorithm];

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
  init_esbuild_shims();
  var stringHasher = (checksumAlgorithmFn, body) => {
    const hash = new checksumAlgorithmFn();
    hash.update(toUint8Array(body || ""));
    return hash.digest();
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
  var flexibleChecksumsMiddlewareOptions = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const { request: request2 } = args;
    const { body: requestBody, headers } = request2;
    const { base64Encoder, streamHasher } = config;
    const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
    const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
      requestChecksumRequired,
      requestAlgorithmMember
    }, !!context.isS3ExpressBucket);
    let updatedBody = requestBody;
    let updatedHeaders = headers;
    if (checksumAlgorithm) {
      const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
      if (isStreaming(requestBody)) {
        const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
        updatedBody = getAwsChunkedEncodingStream(requestBody, {
          base64Encoder,
          bodyLengthChecker,
          checksumLocationName,
          checksumAlgorithmFn,
          streamHasher
        });
        updatedHeaders = {
          ...headers,
          "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
          "transfer-encoding": "chunked",
          "x-amz-decoded-content-length": headers["content-length"],
          "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
          "x-amz-trailer": checksumLocationName
        };
        delete updatedHeaders["content-length"];
      } else if (!hasHeader2(checksumLocationName, headers)) {
        const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
        updatedHeaders = {
          ...headers,
          [checksumLocationName]: base64Encoder(rawChecksum)
        };
      }
    }
    const result = await next({
      ...args,
      request: {
        ...request2,
        headers: updatedHeaders,
        body: updatedBody
      }
    });
    return result;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
  init_esbuild_shims();
  var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
    const validChecksumAlgorithms = [];
    for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
      if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
        continue;
      }
      validChecksumAlgorithms.push(algorithm);
    }
    return validChecksumAlgorithms;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
  init_esbuild_shims();
  var isChecksumWithPartNumber = (checksum) => {
    const lastHyphenIndex = checksum.lastIndexOf("-");
    if (lastHyphenIndex !== -1) {
      const numberPart = checksum.slice(lastHyphenIndex + 1);
      if (!numberPart.startsWith("0")) {
        const number = parseInt(numberPart, 10);
        if (!isNaN(number) && number >= 1 && number <= 1e4) {
          return true;
        }
      }
    }
    return false;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/streams/create-read-stream-on-buffer.browser.js
  init_esbuild_shims();
  function createReadStreamOnBuffer(buffer2) {
    return new Blob([buffer2]).stream();
  }

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
  init_esbuild_shims();

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
  init_esbuild_shims();
  var getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
    const digest = isStreaming(body) ? streamHasher(checksumAlgorithmFn, body) : stringHasher(checksumAlgorithmFn, body);
    return base64Encoder(await digest);
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
  var validateChecksumFromResponse = async (response, { config, responseAlgorithms }) => {
    const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
    const { body: responseBody, headers: responseHeaders } = response;
    for (const algorithm of checksumAlgorithms) {
      const responseHeader = getChecksumLocationName(algorithm);
      const checksumFromResponse = responseHeaders[responseHeader];
      if (checksumFromResponse) {
        const checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
        const { streamHasher, base64Encoder } = config;
        const checksum = await getChecksum(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
        if (checksum === checksumFromResponse) {
          break;
        }
        throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
      }
    }
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
  var flexibleChecksumsResponseMiddlewareOptions = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const input = args.input;
    const result = await next(args);
    const response = result.response;
    let collectedStream = void 0;
    const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
    if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
      const { clientName, commandName } = context;
      const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = response.headers[responseHeader];
        return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
      });
      if (isS3WholeObjectMultipartGetResponseChecksum) {
        return result;
      }
      const isStreamingBody = isStreaming(response.body);
      if (isStreamingBody) {
        collectedStream = await config.streamCollector(response.body);
        response.body = createReadStreamOnBuffer(collectedStream);
      }
      await validateChecksumFromResponse(result.response, {
        config,
        responseAlgorithms
      });
      if (isStreamingBody && collectedStream) {
        response.body = createReadStreamOnBuffer(collectedStream);
      }
    }
    return result;
  };

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
  var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
      clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
    }
  });

  // node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js
  init_esbuild_shims();
  var GetObjectCommand = class extends Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command2, cs, config, o) {
    return [
      getSerdePlugin(config, this.serialize, this.deserialize),
      getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
      getSsecPlugin(config),
      getS3ExpiresMiddlewarePlugin(config),
      getFlexibleChecksumsPlugin(config, {
        input: this.input,
        requestChecksumRequired: false,
        requestValidationModeMember: "ChecksumMode",
        responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"]
      })
    ];
  }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").f(GetObjectRequestFilterSensitiveLog, GetObjectOutputFilterSensitiveLog).ser(se_GetObjectCommand).de(de_GetObjectCommand).build() {
  };

  // node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js
  init_esbuild_shims();
  var HeadObjectCommand = class extends Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command2, cs, config, o) {
    return [
      getSerdePlugin(config, this.serialize, this.deserialize),
      getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
      getSsecPlugin(config),
      getS3ExpiresMiddlewarePlugin(config)
    ];
  }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").f(HeadObjectRequestFilterSensitiveLog, HeadObjectOutputFilterSensitiveLog).ser(se_HeadObjectCommand).de(de_HeadObjectCommand).build() {
  };

  // lib/reader.ts
  var { getBloomFiltersFor: getBloomFiltersFor2 } = bloomFilterReader_exports;
  var PARQUET_MAGIC = "PAR1";
  var PARQUET_VERSIONS = [1, 2];
  var PARQUET_RDLVL_TYPE = "INT32";
  var PARQUET_RDLVL_ENCODING = "RLE";
  var ParquetCursor = class {
    metadata;
    envelopeReader;
    schema;
    columnList;
    rowGroup;
    rowGroupIndex;
    cursorIndex;
    /**
     * Create a new parquet reader from the file metadata and an envelope reader.
     * It is usually not recommended to call this constructor directly except for
     * advanced and internal use cases. Consider using getCursor() on the
     * ParquetReader instead
     */
    constructor(metadata2, envelopeReader, schema, columnList) {
      this.metadata = metadata2;
      this.envelopeReader = envelopeReader;
      this.schema = schema;
      this.columnList = columnList;
      this.rowGroup = [];
      this.rowGroupIndex = 0;
      this.cursorIndex = 0;
    }
    /**
     * Retrieve the next row from the cursor. Returns a row or NULL if the end
     * of the file was reached
     */
    async next() {
      if (this.cursorIndex >= this.rowGroup.length) {
        if (this.rowGroupIndex >= this.metadata.row_groups.length) {
          return null;
        }
        const rowBuffer = await this.envelopeReader.readRowGroup(
          this.schema,
          this.metadata.row_groups[this.rowGroupIndex],
          this.columnList
        );
        this.rowGroup = materializeRecords(this.schema, rowBuffer);
        this.rowGroupIndex++;
        this.cursorIndex = 0;
      }
      return this.rowGroup[this.cursorIndex++];
    }
    /**
     * Rewind the cursor to the beginning of the file
     */
    rewind() {
      this.rowGroup = [];
      this.rowGroupIndex = 0;
      this.cursorIndex = 0;
    }
  };
  var ParquetReader = class _ParquetReader {
    envelopeReader;
    metadata;
    schema;
    /**
     * Open the parquet file pointed to by the specified path and return a new
     * parquet reader
     */
    static async openFile(filePath, options) {
      const envelopeReader = await ParquetEnvelopeReader.openFile(filePath, options);
      return this.openEnvelopeReader(envelopeReader, options);
    }
    static async openBuffer(buffer2, options) {
      const envelopeReader = await ParquetEnvelopeReader.openBuffer(buffer2, options);
      return this.openEnvelopeReader(envelopeReader, options);
    }
    /**
     * Open the parquet file from S3 using the supplied aws client [, commands] and params
     * The params have to include `Bucket` and `Key` to the file requested,
     * If using v3 of the AWS SDK, combine the client and commands into an object wiht keys matching
     * the original module names, and do not instantiate the commands; pass them as classes/modules.
     *
     * This function returns a new parquet reader [ or throws an Error.]
     */
    static async openS3(client, params, options) {
      try {
        const envelopeReader = "function" === typeof client["headObject"] ? await ParquetEnvelopeReader.openS3(client, params, options) : await ParquetEnvelopeReader.openS3v3(client, params, options);
        return this.openEnvelopeReader(envelopeReader, options);
      } catch (e2) {
        throw new Error(`Error accessing S3 Bucket ${params.Bucket}. Message: ${e2.message}`);
      }
    }
    /**
     * Open the parquet file from a url using the supplied request module
     * params should either be a string (url) or an object that includes
     * a `url` property.
     * This function returns a new parquet reader
     */
    static async openUrl(params, options) {
      const envelopeReader = await ParquetEnvelopeReader.openUrl(params, options);
      return this.openEnvelopeReader(envelopeReader, options);
    }
    static async openEnvelopeReader(envelopeReader, opts) {
      if (opts?.metadata) {
        return new _ParquetReader(opts.metadata, envelopeReader, opts);
      }
      try {
        await envelopeReader.readHeader();
        const metadata2 = await envelopeReader.readFooter();
        return new _ParquetReader(metadata2, envelopeReader, opts);
      } catch (err) {
        await envelopeReader.close();
        throw err;
      }
    }
    /**
     * Create a new parquet reader from the file metadata and an envelope reader.
     * It is not recommended to call this constructor directly except for advanced
     * and internal use cases. Consider using one of the open{File,Buffer} methods
     * instead
     */
    constructor(metadata2, envelopeReader, opts) {
      opts = opts || {};
      if (!PARQUET_VERSIONS.includes(metadata2.version)) {
        throw "invalid parquet version";
      }
      if (metadata2.json) {
        const convert = (o) => {
          if (o && typeof o === "object") {
            Object.keys(o).forEach((key) => o[key] = convert(o[key]));
            if (o.parquetType === "CTIME") {
              return new Date(o.value);
            } else if (o.parquetType === "INT64") {
              return new import_node_int64.default(Buffer2.from(o.value));
            }
          }
          return o;
        };
        metadata2.row_groups.forEach((rowGroup) => {
          rowGroup.columns.forEach((column) => {
            if (column.offsetIndex) {
              Promise.resolve(column.offsetIndex).then(
                (offset) => offset.page_locations.forEach((d) => {
                  if (Array.isArray(d)) {
                    Object.setPrototypeOf(d, import_parquet_types4.default.PageLocation.prototype);
                  }
                })
              );
            }
          });
        });
        convert(metadata2);
      }
      this.metadata = envelopeReader.metadata = metadata2;
      this.envelopeReader = envelopeReader;
      this.schema = envelopeReader.schema = new ParquetSchema(
        decodeSchema(this.metadata.schema.slice(1))
      );
      if (this.metadata.row_groups && !this.metadata.json && !opts.rawStatistics) {
        this.metadata.row_groups.forEach(
          (row) => row.columns.forEach((col) => {
            const stats = col.meta_data.statistics;
            if (stats) {
              const field = this.schema.findField(col.meta_data.path_in_schema);
              stats.max_value = decodeStatisticsValue(stats.max_value, field);
              stats.min_value = decodeStatisticsValue(stats.min_value, field);
              stats.min = decodeStatisticsValue(stats.min, field);
              stats.max = decodeStatisticsValue(stats.max, field);
            }
          })
        );
      }
    }
    /**
     * Support `for await` iterators on the reader object
     * Uses `ParquetCursor` still under the hood.
     *
     * ```js
     *  for await (const record of reader) {
     *    console.log(record);
     *  }
     * ```
     */
    async *[Symbol.asyncIterator]() {
      const cursor = this.getCursor();
      let record = null;
      while (record = await cursor.next()) {
        yield record;
      }
    }
    /**
     * Return a cursor to the file. You may open more than one cursor and use
     * them concurrently. All cursors become invalid once close() is called on
     * the reader object.
     *
     * The required_columns parameter controls which columns are actually read
     * from disk. An empty array or no value implies all columns. A list of column
     * names means that only those columns should be loaded from disk.
     */
    getCursor(columnList) {
      if (!columnList) {
        columnList = [];
      }
      columnList = columnList.map((x) => x.constructor === Array ? x : [x]);
      return new ParquetCursor(this.metadata, this.envelopeReader, this.schema, columnList);
    }
    async getBloomFiltersFor(columnNames) {
      const bloomFilterData = await getBloomFiltersFor2(columnNames, this.envelopeReader);
      return bloomFilterData.reduce((acc, value) => {
        if (acc[value.columnName]) acc[value.columnName].push(value);
        else acc[value.columnName] = [value];
        return acc;
      }, {});
    }
    /**
     * Return the number of rows in this file. Note that the number of rows is
     * not necessarily equal to the number of rows in each column.
     */
    getRowCount() {
      return this.metadata.num_rows;
    }
    /**
     * Returns the ParquetSchema for this file
     */
    getSchema() {
      return this.schema;
    }
    /**
     * Returns the user (key/value) metadata for this file
     */
    getMetadata() {
      const md = {};
      for (const kv of this.metadata.key_value_metadata) {
        md[kv.key] = kv.value;
      }
      return md;
    }
    async exportMetadata(indent) {
      function replacer(_key, value) {
        if (value instanceof import_parquet_types4.default.PageLocation) {
          return [value.offset, value.compressed_page_size, value.first_row_index];
        }
        if (typeof value === "object") {
          for (const k in value) {
            if (value[k] instanceof Date) {
              value[k].toJSON = () => JSON.stringify({
                parquetType: "CTIME",
                value: value[k].valueOf()
              });
            }
          }
        }
        if (typeof value === "bigint") {
          return value.toString();
        }
        if (value instanceof import_node_int64.default) {
          if (isFinite(Number(value))) {
            return Number(value);
          } else {
            return {
              parquetType: "INT64",
              value: [...value.buffer]
            };
          }
        } else {
          return value;
        }
      }
      const metadata2 = Object.assign({}, this.metadata, { json: true });
      for (let i = 0; i < metadata2.row_groups.length; i++) {
        const rowGroup = metadata2.row_groups[i];
        for (let j = 0; j < rowGroup.columns.length; j++) {
          const column = rowGroup.columns[j];
          if (column.offsetIndex instanceof Promise) {
            column.offsetIndex = await column.offsetIndex;
          }
          if (column.columnIndex instanceof Promise) {
            column.columnIndex = await column.columnIndex;
          }
        }
      }
      return JSON.stringify(metadata2, replacer, indent);
    }
    /**
     * Close this parquet reader. You MUST call this method once you're finished
     * reading rows
     */
    async close() {
      await this.envelopeReader.close();
      this.envelopeReader = null;
      this.metadata = null;
    }
    decodePages(buffer2, opts) {
      return decodePages(buffer2, opts);
    }
  };
  var ParquetEnvelopeReaderIdCounter = 0;
  var ParquetEnvelopeReader = class _ParquetEnvelopeReader {
    readFn;
    close;
    id;
    fileSize;
    default_dictionary_size;
    metadata;
    schema;
    static async openFile(filePath, options) {
      const fileStat = await fstat2(filePath);
      const fileDescriptor = await fopen(filePath);
      const readFn = (offset, length, file) => {
        if (file) {
          return Promise.reject("external references are not supported");
        }
        return fread(fileDescriptor, offset, length);
      };
      const closeFn = fclose.bind(void 0, fileDescriptor);
      return new _ParquetEnvelopeReader(readFn, closeFn, fileStat.size, options);
    }
    static async openBuffer(buffer2, options) {
      const readFn = (offset, length, file) => {
        if (file) {
          return Promise.reject("external references are not supported");
        }
        return Promise.resolve(buffer2.subarray(offset, offset + length));
      };
      const closeFn = () => ({});
      return new _ParquetEnvelopeReader(readFn, closeFn, buffer2.length, options);
    }
    static async openS3(client, params, options) {
      const fileStat = async () => client.headObject(params).promise().then((d) => d.ContentLength);
      const readFn = async (offset, length, file) => {
        if (file) {
          return Promise.reject("external references are not supported");
        }
        const Range = `bytes=${offset}-${offset + length - 1}`;
        const res = await client.getObject(Object.assign({ Range }, params)).promise();
        return Promise.resolve(res.Body);
      };
      const closeFn = () => ({});
      return new _ParquetEnvelopeReader(readFn, closeFn, fileStat, options);
    }
    static async openS3v3(client, params, options) {
      const fileStat = async () => {
        try {
          const headObjectCommand = await client.send(new HeadObjectCommand(params));
          if (headObjectCommand.ContentLength === void 0) {
            throw new Error("Content Length is undefined!");
          }
          return Promise.resolve(headObjectCommand.ContentLength);
        } catch (e2) {
          return Promise.reject("rejected headObjectCommand: " + e2.message);
        }
      };
      const readFn = async (offset, length, file) => {
        if (file) {
          return Promise.reject("external references are not supported");
        }
        const Range = `bytes=${offset}-${offset + length - 1}`;
        const input = { ...{ Range }, ...params };
        const response = await client.send(new GetObjectCommand(input));
        const body = response.Body;
        if (body) {
          return _ParquetEnvelopeReader.streamToBuffer(body);
        }
        return Buffer2.of();
      };
      const closeFn = () => ({});
      return new _ParquetEnvelopeReader(readFn, closeFn, fileStat, options);
    }
    static async streamToBuffer(body) {
      const blob = body;
      if (blob.arrayBuffer !== void 0) {
        const arrayBuffer = await blob.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        return Buffer2.from(uint8Array);
      }
      const readable = body;
      return await new Promise((resolve2, reject) => {
        const chunks = [];
        readable.on("data", (chunk) => chunks.push(chunk));
        readable.on("error", reject);
        readable.on("end", () => resolve2(Buffer2.concat(chunks)));
      });
    }
    static async openUrl(url, options) {
      let params;
      if (typeof url === "string") params = { url };
      else if (url instanceof URL) params = { url: url.toString() };
      else params = url;
      if (!params.url) throw new Error("URL missing");
      const baseArr = params.url.split("/");
      const base = baseArr.slice(0, baseArr.length - 1).join("/") + "/";
      const defaultHeaders = params.headers || {};
      const filesize = async () => {
        const { headers } = await (0, import_cross_fetch.default)(params.url);
        return Number(headers.get("Content-Length")) || 0;
      };
      const readFn = async (offset, length, file) => {
        const url2 = file ? base + file : params.url;
        const range = `bytes=${offset}-${offset + length - 1}`;
        const headers = Object.assign({}, defaultHeaders, { range });
        const response = await (0, import_cross_fetch.default)(url2, { headers });
        const arrayBuffer = await response.arrayBuffer();
        const buffer2 = Buffer2.from(arrayBuffer);
        return buffer2;
      };
      const closeFn = () => ({});
      return new _ParquetEnvelopeReader(readFn, closeFn, filesize, options);
    }
    constructor(readFn, closeFn, fileSize, options, metadata2) {
      options = options || {};
      this.readFn = readFn;
      this.id = ++ParquetEnvelopeReaderIdCounter;
      this.close = closeFn;
      this.fileSize = fileSize;
      this.default_dictionary_size = options.default_dictionary_size || 1e7;
      this.metadata = metadata2;
      if (options.maxLength || options.maxSpan || options.queueWait) {
        const bufferReader = new BufferReader(this, options);
        this.read = (offset, length) => bufferReader.read(offset, length);
      }
    }
    read(offset, length, file) {
      return this.readFn(offset, length, file);
    }
    readHeader() {
      return this.read(0, PARQUET_MAGIC.length).then((buf) => {
        if (buf.toString() != PARQUET_MAGIC) {
          throw "not valid parquet file";
        }
      });
    }
    // Helper function to get the column object for a particular path and row_group
    getColumn(path, row_group) {
      let column;
      let parsedRowGroup;
      if (!isNaN(Number(row_group))) {
        parsedRowGroup = this.metadata?.row_groups[Number(row_group)];
      } else if (row_group instanceof import_parquet_types4.default.RowGroup) {
        parsedRowGroup = row_group;
      }
      if (typeof path === "string") {
        if (!parsedRowGroup) {
          throw `Missing RowGroup ${row_group}`;
        }
        column = parsedRowGroup.columns.find((d) => d.meta_data.path_in_schema.join(",") === path);
        if (!column) {
          throw `Column ${path} Not Found`;
        }
      } else {
        column = path;
      }
      return column;
    }
    getAllColumnChunkDataFor(paths, row_groups) {
      if (!row_groups) {
        row_groups = this.metadata.row_groups;
      }
      return row_groups.flatMap(
        (rowGroup, index) => paths.map((columnName) => ({
          rowGroupIndex: index,
          column: this.getColumn(columnName, rowGroup)
        }))
      );
    }
    readOffsetIndex(path, row_group, opts) {
      const column = this.getColumn(path, row_group);
      if (column.offsetIndex) {
        return Promise.resolve(column.offsetIndex);
      } else if (!column.offset_index_offset || !column.offset_index_length) {
        return Promise.reject("Offset Index Missing");
      }
      const data = this.read(+column.offset_index_offset, column.offset_index_length).then((data2) => {
        const offset_index = new import_parquet_types4.default.OffsetIndex();
        decodeThrift(offset_index, data2);
        Object.defineProperty(offset_index, "column", { value: column, enumerable: false });
        return offset_index;
      });
      if (opts?.cache) {
        column.offsetIndex = data;
      }
      return data;
    }
    readColumnIndex(path, row_group, opts) {
      const column = this.getColumn(path, row_group);
      if (column.columnIndex) {
        return Promise.resolve(column.columnIndex);
      } else if (!column.column_index_offset) {
        return Promise.reject(new Error("Column Index Missing"));
      }
      const data = this.read(+column.column_index_offset, column.column_index_length).then((buf) => {
        const column_index = new import_parquet_types4.default.ColumnIndex();
        decodeThrift(column_index, buf);
        Object.defineProperty(column_index, "column", { value: column });
        const field = this.schema.findField(column.meta_data.path_in_schema);
        if (column_index.max_values) {
          column_index.max_values = column_index.max_values.map((max_value) => decodeStatisticsValue(max_value, field));
        }
        if (column_index.min_values) {
          column_index.min_values = column_index.min_values.map((min_value) => decodeStatisticsValue(min_value, field));
        }
        return column_index;
      });
      if (opts?.cache) {
        column.columnIndex = data;
      }
      return data;
    }
    async readPage(column, page, records, opts) {
      column = Object.assign({}, column);
      column.meta_data = Object.assign({}, column.meta_data);
      if (page instanceof import_parquet_types4.default.PageLocation && page.offset !== void 0) {
        if (isNaN(Number(page.offset)) || isNaN(page.compressed_page_size)) {
          throw Error("page offset and/or size missing");
        }
        column.meta_data.data_page_offset = cloneInteger(page.offset);
        column.meta_data.total_compressed_size = new import_node_int64.default(page.compressed_page_size);
      } else {
        const offsetIndex = await this.readOffsetIndex(column, null, opts);
        column.meta_data.data_page_offset = cloneInteger(offsetIndex.page_locations[page].offset);
        column.meta_data.total_compressed_size = new import_node_int64.default(
          offsetIndex.page_locations[page].compressed_page_size
        );
      }
      const chunk = await this.readColumnChunk(this.schema, column);
      Object.defineProperty(chunk, "column", { value: column });
      const data = {
        columnData: { [chunk.column.meta_data.path_in_schema.join(",")]: chunk }
      };
      return materializeRecords(this.schema, data, records);
    }
    async readRowGroup(schema, rowGroup, columnList) {
      const buffer2 = {
        rowCount: +rowGroup.num_rows,
        columnData: {},
        pageRowCount: 0,
        pages: {}
      };
      for (const colChunk of rowGroup.columns) {
        const colMetadata = colChunk.meta_data;
        const colKey = colMetadata.path_in_schema;
        if (columnList.length > 0 && fieldIndexOf(columnList, colKey) < 0) {
          continue;
        }
        buffer2.columnData[colKey.join(",")] = await this.readColumnChunk(schema, colChunk);
      }
      return buffer2;
    }
    async readColumnChunk(schema, colChunk, opts) {
      const metadata2 = colChunk.meta_data;
      const field = schema.findField(metadata2.path_in_schema);
      const type = getThriftEnum(import_parquet_types4.default.Type, metadata2.type);
      const compression = getThriftEnum(import_parquet_types4.default.CompressionCodec, metadata2.codec);
      const pagesOffset = +metadata2.data_page_offset;
      let pagesSize = +metadata2.total_compressed_size;
      if (!colChunk.file_path) {
        pagesSize = Math.min(this.fileSize - pagesOffset, +metadata2.total_compressed_size);
      }
      opts = Object.assign({}, opts, {
        type,
        rLevelMax: field.rLevelMax,
        dLevelMax: field.dLevelMax,
        compression,
        column: field,
        num_values: metadata2.num_values
      });
      if (metadata2.dictionary_page_offset && +metadata2.dictionary_page_offset > 0) {
        const offset = +metadata2.dictionary_page_offset;
        const size = Math.min(+this.fileSize - offset, this.default_dictionary_size);
        await this.read(offset, size, colChunk.file_path).then(async (buffer2) => {
          await decodePage({ offset: 0, buffer: buffer2, size: buffer2.length }, opts).then((dict) => {
            opts.dictionary = opts.dictionary || dict.dictionary;
          });
        });
      }
      return this.read(pagesOffset, pagesSize, colChunk.file_path).then(
        (pagesBuf) => decodePages(pagesBuf, opts)
      );
    }
    async readFooter() {
      if (typeof this.fileSize === "function") {
        this.fileSize = await this.fileSize();
      }
      const trailerLen = PARQUET_MAGIC.length + 4;
      const offset = this.fileSize - trailerLen;
      const trailerBuf = await this.read(offset, trailerLen);
      if (trailerBuf.subarray(4).toString() != PARQUET_MAGIC) {
        throw "not a valid parquet file";
      }
      const metadataSize = trailerBuf.readUInt32LE(0);
      const metadataOffset = this.fileSize - metadataSize - trailerLen;
      if (metadataOffset < PARQUET_MAGIC.length) {
        throw "invalid metadata size";
      }
      const metadataBuf = await this.read(metadataOffset, metadataSize);
      const metadata2 = new import_parquet_types4.default.FileMetaData();
      decodeThrift(metadata2, metadataBuf);
      return metadata2;
    }
  };
  function decodeValues4(type, encoding, cursor, count, opts) {
    if (!(encoding in codec_exports)) {
      throw "invalid encoding: " + encoding;
    }
    return codec_exports[encoding].decodeValues(type, cursor, count, opts);
  }
  function decodeStatisticsValue(value, column) {
    if (value === null || !value.length) {
      return void 0;
    }
    if (!column.primitiveType.includes("BYTE_ARRAY")) {
      value = decodeValues4(
        column.primitiveType,
        "PLAIN",
        { buffer: Buffer2.from(value), offset: 0 },
        1,
        column
      );
      if (value.length === 1) value = value[0];
    }
    if (column.originalType) {
      value = fromPrimitive(column.originalType, value, column);
    }
    return value;
  }
  function decodeStatistics(statistics, column) {
    if (!statistics) {
      return;
    }
    if (statistics.min_value !== null) {
      statistics.min_value = decodeStatisticsValue(statistics.min_value, column);
    }
    if (statistics.max_value !== null) {
      statistics.max_value = decodeStatisticsValue(statistics.max_value, column);
    }
    statistics.min = decodeStatisticsValue(statistics.min, column) || statistics.min_value;
    statistics.max = decodeStatisticsValue(statistics.max, column) || statistics.max_value;
    return statistics;
  }
  async function decodePage(cursor, opts) {
    opts = opts || {};
    let page;
    const pageHeader = new NewPageHeader();
    const headerOffset = cursor.offset;
    const headerSize = decodeThrift(pageHeader, cursor.buffer.subarray(cursor.offset));
    cursor.offset += headerSize;
    const pageType = getThriftEnum(import_parquet_types4.default.PageType, pageHeader.type);
    switch (pageType) {
      case "DATA_PAGE":
        if (!opts.rawStatistics) {
          pageHeader.data_page_header.statistics = decodeStatistics(
            pageHeader.data_page_header.statistics,
            opts.column
          );
        }
        page = await decodeDataPage(cursor, pageHeader, opts);
        break;
      case "DATA_PAGE_V2":
        if (!opts.rawStatistics) {
          pageHeader.data_page_header_v2.statistics = decodeStatistics(
            pageHeader.data_page_header_v2.statistics,
            opts.column
          );
        }
        page = await decodeDataPageV2(cursor, pageHeader, opts);
        break;
      case "DICTIONARY_PAGE":
        page = {
          dictionary: await decodeDictionaryPage(cursor, pageHeader, opts)
        };
        break;
      default:
        throw `invalid page type: ${pageType}`;
    }
    pageHeader.offset = headerOffset;
    pageHeader.headerSize = headerSize;
    page.pageHeader = pageHeader;
    return page;
  }
  async function decodePages(buffer2, opts) {
    opts = opts || {};
    const cursor = {
      buffer: buffer2,
      offset: 0,
      size: buffer2.length
    };
    const data = {
      rlevels: [],
      dlevels: [],
      values: [],
      pageHeaders: [],
      count: 0
    };
    while (cursor.offset < cursor.size && (!opts.num_values || data.dlevels.length < opts.num_values)) {
      const pageData = await decodePage(cursor, opts);
      if (pageData.dictionary) {
        opts.dictionary = pageData.dictionary;
        continue;
      }
      if (opts.dictionary && pageData.useDictionary) {
        pageData.values = pageData.values.map((d) => opts.dictionary[d]);
      }
      const length = pageData.rlevels != void 0 ? pageData.rlevels.length : 0;
      for (let i = 0; i < length; i++) {
        data.rlevels.push(pageData.rlevels[i]);
        data.dlevels.push(pageData.dlevels[i]);
        const value = pageData.values[i];
        if (value !== void 0) {
          data.values.push(value);
        }
      }
      data.count += pageData.count;
      data.pageHeaders.push(pageData.pageHeader);
    }
    return data;
  }
  async function decodeDictionaryPage(cursor, header, opts) {
    const cursorEnd = cursor.offset + header.compressed_page_size;
    let dictCursor = {
      offset: 0,
      buffer: cursor.buffer.subarray(cursor.offset, cursorEnd),
      size: cursorEnd - cursor.offset
    };
    cursor.offset = cursorEnd;
    if (opts.compression && opts.compression !== "UNCOMPRESSED") {
      const valuesBuf = await inflate(
        opts.compression,
        dictCursor.buffer.subarray(dictCursor.offset, cursorEnd)
      );
      dictCursor = {
        buffer: valuesBuf,
        offset: 0,
        size: valuesBuf.length
      };
    }
    return decodeValues4(
      opts.column.primitiveType,
      opts.column.encoding,
      dictCursor,
      header.dictionary_page_header.num_values,
      opts
    ).map((d) => d.toString());
  }
  async function decodeDataPage(cursor, header, opts) {
    const cursorEnd = cursor.offset + header.compressed_page_size;
    const dataPageHeader = header.data_page_header;
    const valueCount = dataPageHeader.num_values;
    const valueEncoding = getThriftEnum(import_parquet_types4.default.Encoding, dataPageHeader.encoding);
    let valuesBufCursor = cursor;
    if (opts.compression && opts.compression !== "UNCOMPRESSED") {
      const valuesBuf = await inflate(
        opts.compression,
        cursor.buffer.subarray(cursor.offset, cursorEnd)
      );
      valuesBufCursor = {
        buffer: valuesBuf,
        offset: 0,
        size: valuesBuf.length
      };
    }
    const rLevelEncoding = getThriftEnum(import_parquet_types4.default.Encoding, dataPageHeader.repetition_level_encoding);
    let rLevels = new Array(valueCount);
    if (opts.rLevelMax > 0) {
      rLevels = decodeValues4(PARQUET_RDLVL_TYPE, rLevelEncoding, valuesBufCursor, valueCount, {
        bitWidth: getBitWidth(opts.rLevelMax)
      });
    } else {
      rLevels.fill(0);
    }
    const dLevelEncoding = getThriftEnum(import_parquet_types4.default.Encoding, dataPageHeader.definition_level_encoding);
    let dLevels = new Array(valueCount);
    if (opts.dLevelMax > 0) {
      dLevels = decodeValues4(PARQUET_RDLVL_TYPE, dLevelEncoding, valuesBufCursor, valueCount, {
        bitWidth: getBitWidth(opts.dLevelMax)
      });
    } else {
      dLevels.fill(0);
    }
    let valueCountNonNull = 0;
    for (const dlvl of dLevels) {
      if (dlvl === opts.dLevelMax) {
        ++valueCountNonNull;
      }
    }
    const values = decodeValues4(opts.type, valueEncoding, valuesBufCursor, valueCountNonNull, {
      typeLength: opts.column.typeLength,
      bitWidth: opts.column.typeLength,
      disableEnvelope: opts.column.disableEnvelope,
      originalType: opts.column.originalType,
      precision: opts.column.precision,
      scale: opts.column.scale,
      name: opts.column.name
    });
    cursor.offset = cursorEnd;
    return {
      dlevels: dLevels,
      rlevels: rLevels,
      values,
      count: valueCount,
      useDictionary: valueEncoding === "PLAIN_DICTIONARY" || valueEncoding === "RLE_DICTIONARY"
    };
  }
  async function decodeDataPageV2(cursor, header, opts) {
    const cursorEnd = cursor.offset + header.compressed_page_size;
    const dataPageHeaderV2 = header.data_page_header_v2;
    const valueCount = dataPageHeaderV2.num_values;
    const valueCountNonNull = valueCount - dataPageHeaderV2.num_nulls;
    const valueEncoding = getThriftEnum(import_parquet_types4.default.Encoding, dataPageHeaderV2.encoding);
    let rLevels = new Array(valueCount);
    if (opts.rLevelMax > 0) {
      rLevels = decodeValues4(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, cursor, valueCount, {
        bitWidth: getBitWidth(opts.rLevelMax),
        disableEnvelope: true
      });
    } else {
      rLevels.fill(0);
    }
    let dLevels = new Array(valueCount);
    if (opts.dLevelMax > 0) {
      dLevels = decodeValues4(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, cursor, valueCount, {
        bitWidth: getBitWidth(opts.dLevelMax),
        disableEnvelope: true
      });
    } else {
      dLevels.fill(0);
    }
    let valuesBufCursor = cursor;
    if (dataPageHeaderV2.is_compressed) {
      const valuesBuf = await inflate(
        opts.compression,
        cursor.buffer.subarray(cursor.offset, cursorEnd)
      );
      valuesBufCursor = {
        buffer: valuesBuf,
        offset: 0,
        size: valuesBuf.length
      };
      cursor.offset = cursorEnd;
    }
    const values = decodeValues4(opts.type, valueEncoding, valuesBufCursor, valueCountNonNull, {
      bitWidth: opts.column.typeLength,
      ...opts.column
    });
    return {
      dlevels: dLevels,
      rlevels: rLevels,
      values,
      count: valueCount,
      useDictionary: valueEncoding === "PLAIN_DICTIONARY" || valueEncoding === "RLE_DICTIONARY"
    };
  }
  function decodeSchema(schemaElements) {
    let schema = {};
    schemaElements.forEach((schemaElement) => {
      const repetitionType = getThriftEnum(
        import_parquet_types4.default.FieldRepetitionType,
        schemaElement.repetition_type
      );
      let optional = false;
      let repeated = false;
      switch (repetitionType) {
        case "REQUIRED":
          break;
        case "OPTIONAL":
          optional = true;
          break;
        case "REPEATED":
          repeated = true;
          break;
      }
      if (schemaElement.num_children != void 0 && schemaElement.num_children > 0) {
        schema[schemaElement.name] = {
          optional,
          repeated,
          fields: Object.create(
            {},
            {
              /* define parent and num_children as non-enumerable */
              parent: {
                value: schema,
                enumerable: false
              },
              num_children: {
                value: schemaElement.num_children,
                enumerable: false
              }
            }
          )
        };
        schema = schema[schemaElement.name].fields;
      } else {
        let logicalType = getThriftEnum(import_parquet_types4.default.Type, schemaElement.type);
        if (schemaElement.converted_type != null) {
          logicalType = getThriftEnum(import_parquet_types4.default.ConvertedType, schemaElement.converted_type);
        }
        schema[schemaElement.name] = {
          type: logicalType,
          typeLength: schemaElement.type_length,
          optional,
          repeated,
          scale: schemaElement.scale,
          precision: schemaElement.precision
        };
      }
      while (schema.parent && Object.keys(schema).length === schema.num_children) {
        schema = schema.parent;
      }
    });
    return schema;
  }

  // lib/writer.ts
  init_esbuild_shims();
  var import_stream = __toESM(require_readable_browser());
  var import_parquet_types6 = __toESM(require_parquet_types());

  // lib/bloomFilterIO/bloomFilterWriter.ts
  init_esbuild_shims();
  var import_parquet_types5 = __toESM(require_parquet_types());
  var createSBBF = (params) => {
    const { numFilterBytes, falsePositiveRate, numDistinct } = params;
    const bloomFilter = new sbbf_default();
    const hasOptions = numFilterBytes || falsePositiveRate || numDistinct;
    if (!hasOptions) return bloomFilter.init();
    if (numFilterBytes) return bloomFilter.setOptionNumFilterBytes(numFilterBytes).init();
    if (falsePositiveRate) bloomFilter.setOptionFalsePositiveRate(falsePositiveRate);
    if (numDistinct) bloomFilter.setOptionNumDistinct(numDistinct);
    return bloomFilter.init();
  };
  var serializeFilterBlocks = (blocks) => Buffer2.concat(blocks.map((block) => Buffer2.from(block.buffer)));
  var buildFilterHeader = (numBytes) => {
    const bloomFilterHeader = new import_parquet_types5.default.BloomFilterHeader();
    bloomFilterHeader.numBytes = numBytes;
    bloomFilterHeader.algorithm = new import_parquet_types5.default.BloomFilterAlgorithm();
    bloomFilterHeader.hash = new import_parquet_types5.default.BloomFilterHash();
    bloomFilterHeader.compression = new import_parquet_types5.default.BloomFilterCompression();
    return bloomFilterHeader;
  };
  var serializeFilterHeaders = (numberOfBytes) => {
    const bloomFilterHeader = buildFilterHeader(numberOfBytes);
    return serializeThrift(bloomFilterHeader);
  };
  var serializeFilterData = (params) => {
    const serializedFilterBlocks = serializeFilterBlocks(params.filterBlocks);
    const serializedFilterHeaders = serializeFilterHeaders(params.filterByteSize);
    return Buffer2.concat([serializedFilterHeaders, serializedFilterBlocks]);
  };
  var setFilterOffset = (column, offset) => {
    column.meta_data.bloom_filter_offset = cloneInteger(offset);
  };
  var getSerializedBloomFilterData = (splitBlockBloomFilter) => {
    const filterBlocks = splitBlockBloomFilter.getFilter();
    const filterByteSize = splitBlockBloomFilter.getNumFilterBytes();
    return serializeFilterData({ filterBlocks, filterByteSize });
  };

  // lib/writer.ts
  var import_node_int642 = __toESM(require_Int64());
  var PARQUET_MAGIC2 = "PAR1";
  var PARQUET_VERSION = 1;
  var PARQUET_DEFAULT_PAGE_SIZE = 8192;
  var PARQUET_DEFAULT_ROW_GROUP_SIZE = 4096;
  var PARQUET_RDLVL_TYPE2 = "INT32";
  var PARQUET_RDLVL_ENCODING2 = "RLE";
  var ParquetWriter = class _ParquetWriter {
    schema;
    envelopeWriter;
    rowBuffer;
    rowGroupSize;
    closed;
    userMetadata;
    /**
     * Convenience method to create a new buffered parquet writer that writes to
     * the specified file
     */
    static async openFile(schema, path, opts) {
      const outputStream = await osopen(path, opts);
      return _ParquetWriter.openStream(schema, outputStream, opts);
    }
    /**
     * Convenience method to create a new buffered parquet writer that writes to
     * the specified stream
     */
    static async openStream(schema, outputStream, opts) {
      if (!opts) {
        opts = {};
      }
      const envelopeWriter = await ParquetEnvelopeWriter.openStream(schema, outputStream, opts);
      return new _ParquetWriter(schema, envelopeWriter, opts);
    }
    /**
     * Create a new buffered parquet writer for a given envelope writer
     */
    constructor(schema, envelopeWriter, opts) {
      this.schema = schema;
      this.envelopeWriter = envelopeWriter;
      this.rowBuffer = {};
      this.rowGroupSize = opts.rowGroupSize || PARQUET_DEFAULT_ROW_GROUP_SIZE;
      this.closed = false;
      this.userMetadata = {};
      try {
        envelopeWriter.writeHeader();
      } catch (err) {
        envelopeWriter.close();
        throw err;
      }
    }
    /**
     * Append a single row to the parquet file. Rows are buffered in memory until
     * rowGroupSize rows are in the buffer or close() is called
     */
    async appendRow(row) {
      if (this.closed || this.envelopeWriter === null) {
        throw "writer was closed";
      }
      shredRecord(this.schema, row, this.rowBuffer);
      const options = {
        useDataPageV2: this.envelopeWriter.useDataPageV2,
        bloomFilters: this.envelopeWriter.bloomFilters
      };
      if (this.rowBuffer.pageRowCount >= this.envelopeWriter.pageSize) {
        await encodePages(this.schema, this.rowBuffer, options);
      }
      if (this.rowBuffer.rowCount >= this.rowGroupSize) {
        await encodePages(this.schema, this.rowBuffer, options);
        await this.envelopeWriter.writeRowGroup(this.rowBuffer);
        this.rowBuffer = {};
      }
    }
    /**
     * Finish writing the parquet file and commit the footer to disk. This method
     * MUST be called after you are finished adding rows. You must not call this
     * method twice on the same object or add any rows after the close() method has
     * been called
     */
    async close(callback) {
      if (this.closed) {
        throw "writer was closed";
      }
      this.closed = true;
      if (this.envelopeWriter) {
        if (this.rowBuffer.rowCount > 0 || this.rowBuffer.rowCount >= this.rowGroupSize) {
          await encodePages(this.schema, this.rowBuffer, {
            useDataPageV2: this.envelopeWriter.useDataPageV2,
            bloomFilters: this.envelopeWriter.bloomFilters
          });
          await this.envelopeWriter.writeRowGroup(this.rowBuffer);
          this.rowBuffer = {};
        }
        await this.envelopeWriter.writeBloomFilters();
        await this.envelopeWriter.writeIndex();
        await this.envelopeWriter.writeFooter(this.userMetadata);
        await this.envelopeWriter.close();
        this.envelopeWriter = null;
      }
      if (callback) {
        callback();
      }
    }
    /**
     * Add key<>value metadata to the file
     */
    setMetadata(key, value) {
      this.userMetadata[key.toString()] = value.toString();
    }
    /**
     * Set the parquet row group size. This values controls the maximum number
     * of rows that are buffered in memory at any given time as well as the number
     * of rows that are co-located on disk. A higher value is generally better for
     * read-time I/O performance at the tradeoff of write-time memory usage.
     */
    setRowGroupSize(cnt) {
      this.rowGroupSize = cnt;
    }
    /**
     * Set the parquet data page size. The data page size controls the maximum
     * number of column values that are written to disk as a consecutive array
     */
    setPageSize(cnt) {
      this.envelopeWriter.setPageSize(cnt);
    }
  };
  var ParquetEnvelopeWriter = class _ParquetEnvelopeWriter {
    schema;
    write;
    close;
    offset;
    rowCount;
    rowGroups;
    pageSize;
    useDataPageV2;
    pageIndex;
    bloomFilters;
    // TODO: OR filterCollection
    /**
     * Create a new parquet envelope writer that writes to the specified stream
     */
    static async openStream(schema, outputStream, opts) {
      const writeFn = oswrite.bind(void 0, outputStream);
      const closeFn = osend.bind(void 0, outputStream);
      return new _ParquetEnvelopeWriter(schema, writeFn, closeFn, new import_node_int642.default(0), opts);
    }
    constructor(schema, writeFn, closeFn, fileOffset, opts) {
      this.schema = schema;
      this.write = writeFn;
      this.close = closeFn;
      this.offset = fileOffset;
      this.rowCount = new import_node_int642.default(0);
      this.rowGroups = [];
      this.pageSize = opts.pageSize || PARQUET_DEFAULT_PAGE_SIZE;
      this.useDataPageV2 = "useDataPageV2" in opts ? opts.useDataPageV2 : true;
      this.pageIndex = opts.pageIndex;
      this.bloomFilters = {};
      (opts.bloomFilters || []).forEach((bloomOption) => {
        this.bloomFilters[bloomOption.column] = createSBBF(bloomOption);
      });
    }
    writeSection(buf) {
      this.offset.setValue(this.offset.valueOf() + buf.length);
      return this.write(buf);
    }
    /**
     * Encode the parquet file header
     */
    writeHeader() {
      return this.writeSection(Buffer2.from(PARQUET_MAGIC2));
    }
    /**
     * Encode a parquet row group. The records object should be created using the
     * shredRecord method
     */
    async writeRowGroup(records) {
      const rgroup = await encodeRowGroup(this.schema, records, {
        baseOffset: this.offset,
        pageSize: this.pageSize,
        useDataPageV2: this.useDataPageV2,
        pageIndex: this.pageIndex
      });
      this.rowCount.setValue(this.rowCount.valueOf() + records.rowCount);
      this.rowGroups.push(rgroup.metadata);
      return this.writeSection(rgroup.body);
    }
    writeBloomFilters() {
      this.rowGroups.forEach((group) => {
        group.columns.forEach((column) => {
          if (!column.meta_data?.path_in_schema.length) {
            return;
          }
          const filterName = column.meta_data?.path_in_schema.join(",");
          if (!(filterName in this.bloomFilters)) {
            return;
          }
          const serializedBloomFilterData = getSerializedBloomFilterData(this.bloomFilters[filterName]);
          setFilterOffset(column, this.offset);
          this.writeSection(serializedBloomFilterData);
        });
      });
    }
    /**
     * Write the columnIndices and offsetIndices
     */
    writeIndex() {
      this.schema.fieldList.forEach((c, i) => {
        this.rowGroups.forEach((group) => {
          const column = group.columns[i];
          if (!column) return;
          if (column.meta_data?.columnIndex) {
            const columnBody = serializeThrift(column.meta_data.columnIndex);
            delete column.meta_data.columnIndex;
            column.column_index_offset = cloneInteger(this.offset);
            column.column_index_length = columnBody.length;
            this.writeSection(columnBody);
          }
          if (column.meta_data?.offsetIndex) {
            const offsetBody = serializeThrift(column.meta_data.offsetIndex);
            delete column.meta_data.offsetIndex;
            column.offset_index_offset = cloneInteger(this.offset);
            column.offset_index_length = offsetBody.length;
            this.writeSection(offsetBody);
          }
        });
      });
    }
    /**
     * Write the parquet file footer
     */
    writeFooter(userMetadata) {
      if (!userMetadata) {
        userMetadata = {};
      }
      if (this.schema.fieldList.length === 0) {
        throw "cannot write parquet file with zero fieldList";
      }
      return this.writeSection(encodeFooter(this.schema, this.rowCount, this.rowGroups, userMetadata));
    }
    /**
     * Set the parquet data page size. The data page size controls the maximum
     * number of column values that are written to disk as a consecutive array
     */
    setPageSize(cnt) {
      this.pageSize = cnt;
    }
  };
  var ParquetTransformer = class extends import_stream.default.Transform {
    writer;
    constructor(schema, opts = {}) {
      super({ objectMode: true });
      const writeProxy = /* @__PURE__ */ function(t2) {
        return function(b) {
          t2.push(b);
        };
      }(this);
      this.writer = new ParquetWriter(
        schema,
        new ParquetEnvelopeWriter(
          schema,
          writeProxy,
          () => {
          },
          new import_node_int642.default(0),
          opts
        ),
        opts
      );
    }
    _transform(row, _encoding, callback) {
      if (row) {
        this.writer.appendRow(row).then(
          (data) => callback(null, data),
          (err) => {
            const fullErr = new Error(`Error transforming to parquet: ${err.toString()} row:${row}`);
            fullErr.message = err;
            callback(fullErr);
          }
        );
      } else {
        callback();
      }
    }
    _flush(callback) {
      this.writer.close().then((d) => callback(null, d), callback);
    }
  };
  function encodeValues3(type, encoding, values, opts) {
    if (!(encoding in codec_exports)) {
      throw "invalid encoding: " + encoding;
    }
    return codec_exports[encoding].encodeValues(type, values, opts);
  }
  function encodeStatisticsValue(value, column) {
    if (value === void 0) {
      return Buffer2.alloc(0);
    }
    if (column.originalType) {
      value = toPrimitive(column.originalType, value, column);
    }
    if (column.primitiveType !== "BYTE_ARRAY") {
      value = encodeValues3(column.primitiveType, "PLAIN", [value], column);
    }
    return value;
  }
  function encodeStatistics(statistics, column) {
    statistics = Object.assign({}, statistics);
    statistics.min_value = statistics.min_value === void 0 ? null : encodeStatisticsValue(statistics.min_value, column);
    statistics.max_value = statistics.max_value === void 0 ? null : encodeStatisticsValue(statistics.max_value, column);
    statistics.max = statistics.max_value;
    statistics.min = statistics.min_value;
    return new import_parquet_types6.default.Statistics(statistics);
  }
  async function encodePages(schema, rowBuffer, opts) {
    if (!rowBuffer.pageRowCount) {
      return;
    }
    for (const field of schema.fieldList) {
      if (field.isNested) {
        continue;
      }
      let page;
      const columnPath = field.path.join(",");
      const values = rowBuffer.columnData[columnPath];
      if (opts.bloomFilters && columnPath in opts.bloomFilters) {
        const splitBlockBloomFilter = opts.bloomFilters[columnPath];
        values.values.forEach((v) => splitBlockBloomFilter.insert(v));
      }
      let statistics = {};
      if (field.statistics !== false) {
        statistics = {};
        [...values.distinct_values].forEach((v, i) => {
          if (i === 0 || v > statistics.max_value) {
            statistics.max_value = v;
          }
          if (i === 0 || v < statistics.min_value) {
            statistics.min_value = v;
          }
        });
        statistics.null_count = new import_node_int642.default(values.dlevels.length - values.values.length);
        statistics.distinct_count = new import_node_int642.default(values.distinct_values.size);
      }
      if (opts.useDataPageV2) {
        page = await encodeDataPageV2(
          field,
          values.count,
          values.values,
          values.rlevels,
          values.dlevels,
          statistics
        );
      } else {
        page = await encodeDataPage(field, values.values || [], values.rlevels || [], values.dlevels || [], statistics);
      }
      const pages = rowBuffer.pages[field.path.join(",")];
      const lastPage = pages[pages.length - 1];
      const first_row_index = lastPage ? lastPage.first_row_index + lastPage.count : 0;
      pages.push({
        page,
        statistics,
        first_row_index,
        distinct_values: values.distinct_values,
        num_values: values.dlevels.length
      });
      values.distinct_values = /* @__PURE__ */ new Set();
      values.values = [];
      values.rlevels = [];
      values.dlevels = [];
      values.count = 0;
    }
    rowBuffer.pageRowCount = 0;
  }
  async function encodeDataPage(column, values, rlevels, dlevels, statistics) {
    const valuesBuf = encodeValues3(column.primitiveType, column.encoding, values, {
      bitWidth: column.typeLength,
      ...column
    });
    let rLevelsBuf = Buffer2.alloc(0);
    if (column.rLevelMax > 0) {
      rLevelsBuf = encodeValues3(PARQUET_RDLVL_TYPE2, PARQUET_RDLVL_ENCODING2, rlevels, {
        bitWidth: getBitWidth(column.rLevelMax)
      });
    }
    let dLevelsBuf = Buffer2.alloc(0);
    if (column.dLevelMax > 0) {
      dLevelsBuf = encodeValues3(PARQUET_RDLVL_TYPE2, PARQUET_RDLVL_ENCODING2, dlevels, {
        bitWidth: getBitWidth(column.dLevelMax)
      });
    }
    let pageBody = Buffer2.concat([rLevelsBuf, dLevelsBuf, valuesBuf]);
    pageBody = await deflate(column.compression, pageBody);
    const pageHeader = new import_parquet_types6.default.PageHeader();
    pageHeader.type = import_parquet_types6.default.PageType["DATA_PAGE"];
    pageHeader.uncompressed_page_size = rLevelsBuf.length + dLevelsBuf.length + valuesBuf.length;
    pageHeader.compressed_page_size = pageBody.length;
    pageHeader.data_page_header = new import_parquet_types6.default.DataPageHeader();
    pageHeader.data_page_header.num_values = dlevels.length;
    if (column.statistics !== false) {
      pageHeader.data_page_header.statistics = encodeStatistics(statistics, column);
    }
    pageHeader.data_page_header.encoding = import_parquet_types6.default.Encoding[column.encoding];
    pageHeader.data_page_header.definition_level_encoding = import_parquet_types6.default.Encoding[PARQUET_RDLVL_ENCODING2];
    pageHeader.data_page_header.repetition_level_encoding = import_parquet_types6.default.Encoding[PARQUET_RDLVL_ENCODING2];
    return Buffer2.concat([serializeThrift(pageHeader), pageBody]);
  }
  async function encodeDataPageV2(column, rowCount, values, rlevels, dlevels, statistics) {
    const valuesBuf = encodeValues3(column.primitiveType, column.encoding, values, {
      bitWidth: column.typeLength,
      ...column
    });
    const valuesBufCompressed = await deflate(column.compression, valuesBuf);
    let rLevelsBuf = Buffer2.alloc(0);
    if (column.rLevelMax > 0) {
      rLevelsBuf = encodeValues3(PARQUET_RDLVL_TYPE2, PARQUET_RDLVL_ENCODING2, rlevels, {
        bitWidth: getBitWidth(column.rLevelMax),
        disableEnvelope: true
      });
    }
    let dLevelsBuf = Buffer2.alloc(0);
    if (column.dLevelMax > 0) {
      dLevelsBuf = encodeValues3(PARQUET_RDLVL_TYPE2, PARQUET_RDLVL_ENCODING2, dlevels, {
        bitWidth: getBitWidth(column.dLevelMax),
        disableEnvelope: true
      });
    }
    const pageHeader = new import_parquet_types6.default.PageHeader();
    pageHeader.type = import_parquet_types6.default.PageType["DATA_PAGE_V2"];
    pageHeader.data_page_header_v2 = new import_parquet_types6.default.DataPageHeaderV2();
    pageHeader.data_page_header_v2.num_values = dlevels.length;
    pageHeader.data_page_header_v2.num_nulls = dlevels.length - values.length;
    pageHeader.data_page_header_v2.num_rows = rowCount;
    if (column.statistics !== false) {
      pageHeader.data_page_header_v2.statistics = encodeStatistics(statistics, column);
    }
    pageHeader.uncompressed_page_size = rLevelsBuf.length + dLevelsBuf.length + valuesBuf.length;
    pageHeader.compressed_page_size = rLevelsBuf.length + dLevelsBuf.length + valuesBufCompressed.length;
    pageHeader.data_page_header_v2.encoding = import_parquet_types6.default.Encoding[column.encoding];
    pageHeader.data_page_header_v2.definition_levels_byte_length = dLevelsBuf.length;
    pageHeader.data_page_header_v2.repetition_levels_byte_length = rLevelsBuf.length;
    pageHeader.data_page_header_v2.is_compressed = column.compression !== "UNCOMPRESSED";
    return Buffer2.concat([serializeThrift(pageHeader), rLevelsBuf, dLevelsBuf, valuesBufCompressed]);
  }
  async function encodeColumnChunk(pages, opts) {
    const pagesBuf = Buffer2.concat(pages.map((d) => d.page));
    const num_values = pages.reduce((p, d) => p + d.num_values, 0);
    let offset = opts.baseOffset;
    const metadata2 = new import_parquet_types6.default.ColumnMetaData();
    metadata2.path_in_schema = opts.column.path;
    metadata2.num_values = new import_node_int642.default(num_values);
    metadata2.data_page_offset = new import_node_int642.default(opts.baseOffset);
    metadata2.encodings = [];
    metadata2.total_uncompressed_size = new import_node_int642.default(pagesBuf.length);
    metadata2.total_compressed_size = new import_node_int642.default(pagesBuf.length);
    metadata2.type = import_parquet_types6.default.Type[opts.column.primitiveType];
    metadata2.codec = await import_parquet_types6.default.CompressionCodec[opts.column.compression];
    const columnIndex = new import_parquet_types6.default.ColumnIndex();
    columnIndex.null_pages = [];
    columnIndex.max_values = [];
    columnIndex.min_values = [];
    columnIndex.boundary_order = 0;
    const offsetIndex = new import_parquet_types6.default.OffsetIndex();
    offsetIndex.page_locations = [];
    const statistics = {};
    const distinct_values = /* @__PURE__ */ new Set();
    statistics.null_count = new import_node_int642.default(0);
    statistics.distinct_count = new import_node_int642.default(0);
    for (let i = 0; i < pages.length; i++) {
      const page = pages[i];
      if (opts.column.statistics !== false) {
        if (page.statistics.max_value > statistics.max_value || i == 0) {
          statistics.max_value = page.statistics.max_value;
        }
        if (page.statistics.min_value < statistics.min_value || i == 0) {
          statistics.min_value = page.statistics.min_value;
        }
        statistics.null_count.setValue(statistics.null_count.valueOf() + (page.statistics.null_count?.valueOf() || 0));
        page.distinct_values.forEach((value) => distinct_values.add(value));
        columnIndex.null_pages.push(page.num_values === statistics.null_count.valueOf());
        columnIndex.max_values.push(encodeStatisticsValue(page.statistics.max_value, opts.column));
        columnIndex.min_values.push(encodeStatisticsValue(page.statistics.min_value, opts.column));
      }
      const pageLocation = new import_parquet_types6.default.PageLocation();
      pageLocation.offset = new import_node_int642.default(offset);
      offset += page.page.length;
      pageLocation.compressed_page_size = page.page.length;
      pageLocation.first_row_index = new import_node_int642.default(page.first_row_index);
      offsetIndex.page_locations.push(pageLocation);
    }
    if (opts.pageIndex !== false) {
      metadata2.offsetIndex = offsetIndex;
    }
    if (opts.column.statistics !== false) {
      statistics.distinct_count = new import_node_int642.default(distinct_values.size);
      metadata2.statistics = encodeStatistics(statistics, opts.column);
      if (opts.pageIndex !== false) {
        metadata2.columnIndex = columnIndex;
      }
    }
    metadata2.encodings.push(import_parquet_types6.default.Encoding[PARQUET_RDLVL_ENCODING2]);
    metadata2.encodings.push(import_parquet_types6.default.Encoding[opts.column.encoding]);
    const metadataOffset = opts.baseOffset + pagesBuf.length;
    const body = Buffer2.concat([pagesBuf, serializeThrift(metadata2)]);
    return { body, metadata: metadata2, metadataOffset };
  }
  async function encodeRowGroup(schema, data, opts) {
    const metadata2 = new import_parquet_types6.default.RowGroup();
    metadata2.num_rows = new import_node_int642.default(data.rowCount);
    metadata2.columns = [];
    metadata2.total_byte_size = new import_node_int642.default(0);
    let body = Buffer2.alloc(0);
    for (const field of schema.fieldList) {
      if (field.isNested) {
        continue;
      }
      const cchunkData = await encodeColumnChunk(data.pages[field.path.join(",")], {
        column: field,
        baseOffset: opts.baseOffset.valueOf() + body.length,
        pageSize: opts.pageSize || 0,
        rowCount: data.rowCount || 0,
        useDataPageV2: opts.useDataPageV2 ?? true,
        pageIndex: opts.pageIndex ?? true
      });
      const cchunk = new import_parquet_types6.default.ColumnChunk();
      cchunk.file_offset = new import_node_int642.default(cchunkData.metadataOffset);
      cchunk.meta_data = cchunkData.metadata;
      metadata2.columns.push(cchunk);
      metadata2.total_byte_size = new import_node_int642.default(metadata2.total_byte_size.valueOf() + cchunkData.body.length);
      body = Buffer2.concat([body, cchunkData.body]);
    }
    return { body, metadata: metadata2 };
  }
  function encodeFooter(schema, rowCount, rowGroups, userMetadata) {
    const metadata2 = new import_parquet_types6.default.FileMetaData();
    metadata2.version = PARQUET_VERSION;
    metadata2.created_by = "@dsnp/parquetjs";
    metadata2.num_rows = rowCount;
    metadata2.row_groups = rowGroups;
    metadata2.schema = [];
    metadata2.key_value_metadata = [];
    for (const k in userMetadata) {
      const kv = new import_parquet_types6.default.KeyValue();
      kv.key = k;
      kv.value = userMetadata[k];
      metadata2.key_value_metadata.push(kv);
    }
    {
      const schemaRoot = new import_parquet_types6.default.SchemaElement();
      schemaRoot.name = "root";
      schemaRoot.num_children = Object.keys(schema.fields).length;
      metadata2.schema.push(schemaRoot);
    }
    for (const field of schema.fieldList) {
      const schemaElem = new import_parquet_types6.default.SchemaElement();
      schemaElem.name = field.name;
      schemaElem.repetition_type = import_parquet_types6.default.FieldRepetitionType[field.repetitionType];
      if (field.isNested) {
        schemaElem.num_children = field.fieldCount;
      } else {
        schemaElem.type = import_parquet_types6.default.Type[field.primitiveType];
      }
      if (field.originalType) {
        schemaElem.converted_type = import_parquet_types6.default.ConvertedType[field.originalType];
      }
      switch (schemaElem.converted_type) {
        case import_parquet_types6.ConvertedType.DECIMAL:
          schemaElem.precision = field.precision;
          schemaElem.scale = field.scale || 0;
          break;
      }
      schemaElem.type_length = field.typeLength;
      metadata2.schema.push(schemaElem);
    }
    const metadataEncoded = serializeThrift(metadata2);
    const footerEncoded = Buffer2.alloc(metadataEncoded.length + 8);
    metadataEncoded.copy(footerEncoded);
    footerEncoded.writeUInt32LE(metadataEncoded.length, metadataEncoded.length);
    footerEncoded.write(PARQUET_MAGIC2, metadataEncoded.length + 4);
    return footerEncoded;
  }

  // parquet.ts
  var ParquetEnvelopeReader2 = ParquetEnvelopeReader;
  var ParquetReader2 = ParquetReader;
  var ParquetEnvelopeWriter2 = ParquetEnvelopeWriter;
  var ParquetWriter2 = ParquetWriter;
  var ParquetTransformer2 = ParquetTransformer;
  var ParquetSchema2 = ParquetSchema;
  var ParquetShredder = shred_exports;
  var ParquetFieldBuilder = fields_exports;
  var parquet_default = {
    ParquetEnvelopeReader: ParquetEnvelopeReader2,
    ParquetReader: ParquetReader2,
    ParquetEnvelopeWriter: ParquetEnvelopeWriter2,
    ParquetWriter: ParquetWriter2,
    ParquetTransformer: ParquetTransformer2,
    ParquetSchema: ParquetSchema2,
    ParquetShredder,
    ParquetFieldBuilder
  };
  return __toCommonJS(parquet_exports);
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

q/q.js:
  (*!
   *
   * Copyright 2009-2017 Kris Kowal under the terms of the MIT
   * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
